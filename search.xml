<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS Runtime 详解]]></title>
    <url>%2F2019%2F07%2F18%2F2019-07-18.html</url>
    <content type="text"></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS NSTimer 解决循环引用问题]]></title>
    <url>%2F2019%2F06%2F25%2F2019-06-25.html</url>
    <content type="text"><![CDATA[在我们平时的开发过程中，经常会使用一些定时器跑定时任务，常用的 NSTimer，大家应该很熟悉 1self.timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(timeDownAction) userInfo:nil repeats:true]; 造成循环引用的原因是因为 timer 被 self 强引用，在创建 timer 对象时，控制器VC 作为 target 被 timer 强引用，形成一个引用循环。所以在pop出控制器的时候，dealloc 方法不会被执行,在里面 停止计时器[self.timer invalidate]; 也不会被执行，计时器也没有停止，仍然在继续跑。 解决办法NSProxy 解决方案添加一个继承NSProxy的子类ZJProxy，这个类添加一个 weak 修饰的 id 类型 target，将timer的target设置为ZJProxy实例，重写消息转发方法 123456// ZJProxy.h 文件@interface ZJProxy : NSProxy+(instancetype)proxyWithTarget:(id)target;@end 1234567891011121314151617181920212223242526272829// ZJProxy.m 文件 实现@interface ZJProxy ()// 定义一个 weak 修饰的 id 类型 target@property (nonatomic, weak) id target;@end@implementation ZJProxy+(instancetype)proxyWithTarget:(id)target&#123; return [[self alloc]initWithTarget:target];&#125;- (instancetype)initWithTarget:(id)target&#123; _target = target; return self;&#125;// 重写消息转发方法- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123; return [self.target methodSignatureForSelector:sel];&#125;- (void)forwardInvocation:(NSInvocation *)invocation&#123; [invocation invokeWithTarget:self.target];&#125; 使用123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; // 初始化定时器，使用 ZJProxy self.timer = [NSTimer timerWithTimeInterval:2 target:[ZJProxy proxyWithTarget:self] selector:@selector(timeDownAction) userInfo:nil repeats:true]; NSRunLoop *runloop = [NSRunLoop currentRunLoop]; // 计时器添加 runloop [runloop addTimer:self.timer forMode:NSDefaultRunLoopMode]; // 启动计时器 [self.timer fire]; &#125;- (void)dealloc&#123; // 暂停计时器 [self.timer invalidate]; // 将计时器置位 nil self.timer = nil; NSLog(@"TestViewController 控制器销毁了");&#125;]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-命令模式-泛型命令、复合命令、多线程并发处理、闭包命令（四)]]></title>
    <url>%2F2019%2F01%2F28%2Fdesignpatterncommand04.html</url>
    <content type="text"><![CDATA[泛型命令]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-命令模式-动态命令（三)]]></title>
    <url>%2F2019%2F01%2F17%2Fdesignpatterncommand03.html</url>
    <content type="text"><![CDATA[设计模式-命令模式-动态命令命令模式优化第一步：思考问题🤔？在前面讲的命令模式中，我们的每一个命令都需要创建一个对象来实现，这样如果多个类的情况下就会有非常对的命令类，导致类文件过多，冗余，如何才能更好地使用命令模式呢，优化我们的代码呢？ 第二步：解决方案：动态命令：好处在于我们不需要新建各种命令类block 实现 第三步：解决问题命令模式变种，采用回调的方式实现命令回调方式可以有 通知，协议，block 动态命令管理器-&gt; DynamicCommandManager 分析调用流程1.添加命令 -&gt; 调用addCommand 方法2.创建命令 -&gt; createCommand 创建命令 创建了一个 block，将 block 作为参数传递3.保存 block -&gt; 赋值属性4.调用撤销 -&gt; undo5.执行命令 -&gt; 执行DynamicCommand对象中的方法 execute 方法6.回调 block7.执行 tm 的方法 动态命令实现动态命令对象 DynamicCommand首先创建一个动态命令对象，继承 TMCommandProtocol 协议，然后定义一个 block 作为动态命令的回调方法，并作为初始化参数回调。代码如下： 1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;#import "TetrisMachineManager.h"#import "TetrisMachine.h"NS_ASSUME_NONNULL_BEGIN/** * 特点一: 实现命令协议 * 特点二: 传递接收者 */typedef void(^DynamicBlock)(TetrisMachine *tm);@interface DynamicCommand : NSObject&lt;TMCommandProtocol&gt;-(instancetype)initTetrisMachine:(TetrisMachine *)tm block:(DynamicBlock)tmBlock;+(id&lt;TMCommandProtocol&gt;)createCommand:(TetrisMachine *)tm block:(DynamicBlock)tmBlock;@endNS_ASSUME_NONNULL_END 12345678910111213141516171819202122232425262728293031323334#import "DynamicCommand.h"@interface DynamicCommand ()@property (nonatomic, strong) TetrisMachine *tm;@property (nonatomic, copy) DynamicBlock tmblock;@end// 解决方案:block 实现@implementation DynamicCommand-(instancetype)initTetrisMachine:(TetrisMachine *)tm block:(DynamicBlock)tmBlock&#123; if (self = [super init]) &#123; self.tm = tm; self.tmblock = tmBlock; &#125; return self;&#125;-(void)execute&#123; self.tmblock(self.tm);&#125;// 创建对象的时候由于有的时候初始化参数过于复杂,这个我们可以内部提供 // 动态命令的创建,专门有了实现,外部只需要调用即可// 类方法+(id&lt;TMCommandProtocol&gt;)createCommand:(TetrisMachine *)tm block:(DynamicBlock)tmBlock&#123; return [[DynamicCommand alloc]initTetrisMachine:tm block:tmBlock];&#125;@end 动态命令管理器 DynamicCommandManager动态命令管理其中，动态加载对应命令，使用 Runtime 的动态添加方式，把对应的方法名称加载进去，在调用 12345678910111213141516171819202122232425262728// 向左命令-(void)toLeftCommand&#123; [self addCommand:@"toLeft"]; [self.tm toLeft];&#125;// 向右命令-(void)toRightCommand&#123; [self addCommand:@"toRight"]; [self.tm toRight];&#125;// 变形命令-(void)toTransformCommand&#123; [self addCommand:@"toTransform"]; [self.tm toTransform];&#125;-(void)addCommand:(NSString *)methodName&#123; // 根据方法名称,动态加载执行对象的方法 // 获取方法对象 SEL method = NSSelectorFromString(methodName); // 添加命令 [self.commands addObject:[DynamicCommand createCommand:self.tm block:^(TetrisMachine * _Nonnull tm) &#123; [self.tm performSelector:method]; &#125;]]; &#125; 复合命令命令模式中的 各个Command 还可以组合成一个复合命令。 12345678910111213141516171819202122#import "CompoundCommand.h"@interface CompoundCommand ()@property(nonatomic, strong) NSMutableArray* commands;@end@implementation CompoundCommand-(instancetype)initWithCommands:(NSMutableArray *)commands&#123; if (self = [super init]) &#123; self.commands = commands; &#125; return self;&#125;//在复合命令中，调用执行多个命令，就叫做复合命令//复合：多个-(void)execute&#123; // 执行命令 for (id&lt;TMCommandProtocol&gt; command in self.commands) &#123; [command execute]; &#125;&#125;@end Demo 下载点击获取Demo]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-命令模式具体案例分析（二）]]></title>
    <url>%2F2019%2F01%2F12%2Fdesignpatterncommand02.html</url>
    <content type="text"><![CDATA[对于第一讲的命令模式的原理分析可能大家会感到懵懵懂懂，下面我们通过一个俄罗斯方块的案例的实践一下。 俄罗斯方块案例在使用每一个模式之前，我们都要先对功能角色进行分析，每一个操作都是一个命令，左命令、右命令、变形命令等等。 俄罗斯方块的角色分析有角色一：命令接口（抽象命令）TMCommandProtocol角色二：具体命令 1. 向左命令 -&gt; TMLeftCommand 2. 向右命令 -&gt; TMRightCommand 3. 变形命令 -&gt; TMTransformCommand .... 角色三：接收者 -&gt; TetrisMachine角色四：请求者 -&gt; 命令管理器 TetrisMachineManager 具体实现角色一：命令接口（抽象命令）TMCommandProtocol 先定义一个抽象命令接口 TMCommandProtocol，所有具体命令继承这个接口协议，把命令对象关联起来。 123456789101112131415#ifndef TMCommandProtocol_h#define TMCommandProtocol_h/** * 命令接口 -&gt; CommandProtocol(协议) */@protocol TMCommandProtocol&lt;NSObject&gt;/** * 具体方法 */-(void)execute;@end#endif /* TMCommandProtocol_h */ 角色二：具体命令 具体命令抽象成对象，继承TMCommandProtocol接口协议，初始化传入接收者对象与其关联，通过接收者对象执行具体操作命令。 向左命令 TMToLeftCommand1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;#import "TMCommandProtocol.h"#import "TetrisMachine.h"NS_ASSUME_NONNULL_BEGIN/** * 角色二：具体命令-&gt; 向左命令 TMToLeftCommand */@interface TMToLeftCommand : NSObject&lt;TMCommandProtocol&gt;-(instancetype)initWithTetrisMachine:(TetrisMachine *)tm;@endNS_ASSUME_NONNULL_END 123456789101112131415161718192021#import "TMToLeftCommand.h"@interface TMToLeftCommand ()@property (nonatomic, strong) TetrisMachine *tm;@end@implementation TMToLeftCommand-(instancetype)initWithTetrisMachine:(TetrisMachine *)tm&#123; if (self = [super init]) &#123; self.tm = tm; &#125; return self;&#125;// 执行具体命令-(void)execute&#123; [self.tm toLeft];&#125;@end 向右命令 -&gt; TMRightCommand123456789101112131415#import &lt;Foundation/Foundation.h&gt;#import "TMCommandProtocol.h"#import "TetrisMachine.h"NS_ASSUME_NONNULL_BEGIN/** * 角色二：具体命令-&gt; 向右命令 TMToLeftCommand */@interface TMToRightCommand : NSObject&lt;TMCommandProtocol&gt;-(instancetype)initWithTetrisMachine:(TetrisMachine *)tm;@endNS_ASSUME_NONNULL_END 123456789101112131415161718192021#import "TMToRightCommand.h"@interface TMToRightCommand ()@property (nonatomic, strong) TetrisMachine *tm;@end@implementation TMToRightCommand-(instancetype)initWithTetrisMachine:(TetrisMachine *)tm&#123; if (self = [super init]) &#123; self.tm = tm; &#125; return self;&#125;// 执行具体命令- (void)execute&#123; [self.tm toRight];&#125;@end 变形命令 TMToLeftCommand1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;#import "TMCommandProtocol.h"#import "TetrisMachine.h"NS_ASSUME_NONNULL_BEGIN/** * 角色二：具体命令-&gt; 变形命令 TMToLeftCommand */@interface TMToTransformCommand : NSObject&lt;TMCommandProtocol&gt;-(instancetype)initWithTetrisMachine:(TetrisMachine *)tm;@endNS_ASSUME_NONNULL_END 1234567891011121314151617181920#import "TMToTransformCommand.h"@interface TMToTransformCommand ()@property (nonatomic, strong) TetrisMachine *tm;@end@implementation TMToTransformCommand-(instancetype)initWithTetrisMachine:(TetrisMachine *)tm&#123; if (self = [super init]) &#123; self.tm = tm; &#125; return self;&#125;// 执行具体命令- (void)execute&#123; [self.tm toTransform];&#125;@end 角色三：接收者 -&gt; TetrisMachine 接收者，每个命令操作的接收对象，在本案例中就相当于俄罗斯方块，给一个命令，该对象就执行哪一个命令。 12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN/** * 角色三:接收者 */@interface TetrisMachine : NSObject// 向左-(void)toLeft;// 向右-(void)toRight;// 变形-(void)toTransform;@endNS_ASSUME_NONNULL_END 123456789101112131415161718#import "TetrisMachine.h"@implementation TetrisMachine// 向左-(void)toLeft&#123; NSLog(@"向左走");&#125;// 向右-(void)toRight&#123; NSLog(@"向右走");&#125;// 变形-(void)toTransform&#123; NSLog(@"变形");&#125;@end 角色四：请求者 -&gt; 命令管理器 TetrisMachineManager 请求者，本案例是一个抽象的请求者对象-&gt;命令管理器 TetrisMachineManager, 通过这个请求者把接收者和命令关联起来，调用相应命令操作。命令模式支持撤销操作。 1234567891011121314151617181920212223242526272829#import &lt;Foundation/Foundation.h&gt;#import "TMToLeftCommand.h"#import "TMToRightCommand.h"#import "TMToTransformCommand.h"NS_ASSUME_NONNULL_BEGIN/** * 角色四：请求者 -&gt;命令管理器 TetrisMachineManager */@interface TetrisMachineManager : NSObject-(instancetype)initWithTetrisMachine:(TetrisMachine *)tm leftCommand:(TMToLeftCommand *)leftCommand rightCommand:(TMToRightCommand *)rightCommand transformCommand:(TMToTransformCommand *)transformCommand;// 向左命令-(void)toLeftCommand;// 向右命令-(void)toRightCommand;// 变形命令-(void)toTransformCommand;// 撤销操作-(void)undoOpreation;// 撤销所有操作-(void)undoAllOpreation;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#import "TetrisMachineManager.h"@interface TetrisMachineManager ()@property (nonatomic, strong) TetrisMachine *tm;@property (nonatomic, strong) TMToLeftCommand *leftCommand;@property (nonatomic, strong) TMToRightCommand *rightCommand;@property (nonatomic, strong) TMToTransformCommand *transformCommand;// 保存所有操作@property (nonatomic, strong) NSMutableArray *commands;@end@implementation TetrisMachineManager-(instancetype)initWithTetrisMachine:(TetrisMachine *)tm leftCommand:(TMToLeftCommand *)leftCommand rightCommand:(TMToRightCommand *)rightCommand transformCommand:(TMToTransformCommand *)transformCommand&#123; if (self = [super init]) &#123; self.tm = tm; self.leftCommand = leftCommand; self.rightCommand = rightCommand; self.transformCommand = transformCommand; &#125; return self;&#125;// 调用命令-(void)toLeftCommand &#123; [self.leftCommand execute]; // 保存向左命令操作到数组中 [self.commands addObject:[[TMToLeftCommand alloc] initWithTetrisMachine:self.tm]];&#125;-(void)toRightCommand &#123; [self.rightCommand execute]; // 保存向右命令操作到数组中 [self.commands addObject:[[TMToRightCommand alloc] initWithTetrisMachine:self.tm]];&#125;-(void)toTransformCommand &#123; [self.transformCommand execute]; // 保存变形命令操作到数组中 [self.commands addObject:[[TMToTransformCommand alloc] initWithTetrisMachine:self.tm]];&#125;// 撤销操作-(void)undoOpreation&#123; NSLog(@"撤销操作"); if (self.commands.count &gt; 0 ) &#123; // 撤销操作 [[self.commands lastObject] execute]; // 移除保存在数组中的最后一个操作 [self.commands removeLastObject]; &#125;&#125;// 撤销所有操作-(void)undoAllOpreation&#123; NSLog(@"撤销所有操作"); for (id&lt;TMCommandProtocol&gt; command in self.commands) &#123; [command execute]; &#125; // 移除所有操作 [self.commands removeAllObjects];&#125;-(NSMutableArray *)commands&#123; if (!_commands) &#123; _commands = [NSMutableArray array]; &#125; return _commands;&#125;@end 调用实现 在需要调用的 Viewcontroller 实现，先创建一个接收者对象，然后创建具体命令对象，再创建请求者对象，分别调用对应的命令操作，实现需要的操作。把命令保存起来支持撤销命令。 12345678910111213141516171819202122232425262728#pragma mark - 命令模式 - 俄罗斯方块具体案例-(void)commandPatternTMTest&#123; NSLog(@"\n\n********************** 命令模式 - 俄罗斯方块具体案例 *************************\n"); // 创建接收者 TetrisMachine *tm = [[TetrisMachine alloc]init]; // 创建命令对象 TMToLeftCommand *left = [[TMToLeftCommand alloc]initWithTetrisMachine:tm]; TMToRightCommand *right = [[TMToRightCommand alloc]initWithTetrisMachine:tm]; TMToTransformCommand *transform = [[TMToTransformCommand alloc]initWithTetrisMachine:tm]; // 创建请求者对象 TetrisMachineManager *tmManager = [[TetrisMachineManager alloc]initWithTetrisMachine:tm leftCommand:left rightCommand:right transformCommand:transform]; // 向左命令 [tmManager toLeftCommand]; // 向右命令 [tmManager toRightCommand]; // 变形命令 [tmManager toTransformCommand]; // 撤销操作 [tmManager undoOpreation]; // 撤销所有操作 [tmManager undoAllOpreation];&#125; 打印结果如下 1234567891011122019-01-16 23:58:10.042927+0800 CommandPattern[65551:14472177] ********************** 命令模式 - 俄罗斯方块具体案例 *************************2019-01-16 23:58:10.043016+0800 CommandPattern[65551:14472177] 向左走2019-01-16 23:58:10.043103+0800 CommandPattern[65551:14472177] 向右走2019-01-16 23:58:10.043182+0800 CommandPattern[65551:14472177] 变形2019-01-16 23:58:10.043269+0800 CommandPattern[65551:14472177] 撤销操作2019-01-16 23:58:10.043349+0800 CommandPattern[65551:14472177] 变形2019-01-16 23:58:10.043418+0800 CommandPattern[65551:14472177] 撤销所有操作2019-01-16 23:58:10.043494+0800 CommandPattern[65551:14472177] 向左走2019-01-16 23:58:10.043568+0800 CommandPattern[65551:14472177] 向右走 Demo 下载点击获取Demo]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-命令模式原理分析（一）]]></title>
    <url>%2F2019%2F01%2F10%2Fdesignpatterncommand01.html</url>
    <content type="text"><![CDATA[架构学习经验分析架构，已学习架构的方法来学习设计模式，学的主要是思想第一步：了解基本概念第二步：确定架构模式第二步：分析角色：每一个设计模式里面都有角色的划分，不同的场景下，角色不同，一个类担当的角色会是多个 例如: User 类，可以是一个具体产品类，抽象产品类。在架构设计中，存在多种角色划分。要看它到底属于哪一种模式，属于哪一种模式就属于哪一种模式下的角色。 第四步：分析单个角色类结构第五步：分析单个角色意义（子类意义所在）第六步：分析模块第七步：性能优化问题 命令模式（Command Pattern）命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口 优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。缺点：使用命令模式可能会导致某些系统有过多的具体命令类。使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。 应用场景当需要将方法调用包装成一个对象，以延时方法调用，或者让其他的组件在对其内部实现细节不了解的情况下进行调用的时候可以使用命令模式 场景一：应用程序支持撤销和恢复操作场景二：记录请求日志，当系统故障这些命令可以重复执行场景三：想用对象参数化一个动作以执行操作，并用不同命令对象来替换回调函数 命令模式角色划分命令模式分至少会有四个角色，学习框架，分析每一个类是什么角色。角色一：接收者角色二：命令接口角色三：具体命令角色四：请求者 命令模式原理案例命令模式规范面向协议编程：将所有的功能抽象为协议 1.角色一：接收者 -&gt; Receiver1234567891011121314151617181920212223242526272829303132333435363738394041#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN/** * 接收者 -&gt; Receiver */@interface Receiver : NSObject// 定义一个 run 方法-(void)run;@endNS_ASSUME_NONNULL_END-(void)run&#123; // 具体实现 NSLog(@"跑呀跑,跑一跑....🏃");&#125;@end``` #### 2.角色二：命令接口 -&gt; CommandProtocol(协议) iOS称为协议，Java称为接口 ```objc/** * 命令接口 -&gt; CommandProtocol(协议) */@protocol CommandProtocol&lt;NSObject&gt;/** * 具体命令 */-(void)execute;@end 3.角色三：具体命令 -&gt; ConcreteCommand具体方法要遵循协议（接口） 123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;#import "CommandProtocol.h"#import "Receiver.h"NS_ASSUME_NONNULL_BEGIN/** * 角色三：具体命令 -&gt; ConcreteCommand * 特点: 持有接受者的引用, 实现具体命令 */@interface ConcreteCommand : NSObject&lt;CommandProtocol&gt;-(instancetype)initWithRecevicer:(Receiver *)recevier;@endNS_ASSUME_NONNULL_END 1234567891011121314151617181920212223#import "ConcreteCommand.h"@interface ConcreteCommand ()@property (nonatomic, strong) Receiver *receiver;@end@implementation ConcreteCommand-(instancetype)initWithRecevicer:(Receiver *)recevier &#123; if (self = [super init]) &#123; self.receiver = recevier; &#125; return self;&#125;-(void)execute&#123; NSLog(@"具体的代码逻辑实现"); [self.receiver run];&#125;@end 4.角色四：请求者 -&gt; invoker123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;#import "ConcreteCommand.h"NS_ASSUME_NONNULL_BEGIN/** * 角色四：请求者 -&gt; invoker */@interface Invoker : NSObject// 所有命令都是由客户端来决定-(instancetype)initConcreteCommand:(ConcreteCommand *)concreteCommand;// 方法实现-(void)concreteCommand;@endNS_ASSUME_NONNULL_END 12345678910111213141516171819202122232425262728#import "Invoker.h"@interface Invoker ()/** * 父类引用指向子类实例对象(面向对象编程) */@property (nonatomic, strong) id&lt;CommandProtocol&gt; concreteCom;@end/** * 请求者/执行者 * 请求者特点: 执行命令 * 持有命令对象引用(指针) */@implementation Invoker-(instancetype)initConcreteCommand:(ConcreteCommand *)concreteCommand&#123; if (self = [super init]) &#123; self.concreteCom = concreteCommand; &#125;## return self;&#125;-(void)concreteCommand&#123; // 调用命令 [self.concreteCom execute] ;&#125;@end 关联角色 首先：关联请求者 接着：实现接收者 最后：实现命令角色 调用实现 创建接受者对象 创建命令对象 创建请求者对象 执行命令 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; // 原理案例 [self commandPatternTheoryTest];&#125;#pragma mark - 命令模式-原理案例-(void)commandPatternTheoryTest&#123; // 创建接受者 Receiver *receiver = [[Receiver alloc]init]; // 创建命令对象 ConcreteCommand *concreteCom = [[ConcreteCommand alloc]initWithRecevicer:receiver]; // 创建请求者对象 Invoker *invoker = [[Invoker alloc]initConcreteCommand:concreteCom]; // 执行命令 [invoker concreteCommand];&#125; Demo 下载点击获取Demo]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式学习]]></title>
    <url>%2F2019%2F01%2F09%2Fdesignpattern01.html</url>
    <content type="text"><![CDATA[学前杂谈不知不觉 ，已经在深圳摸爬滚打做了两年iOS开发了，两年下来所积累的技术自我感觉并不多，经常会感觉到自己处在一个瓶颈上，想往上爬，却不知路在哪里。没有技术大佬的带领，靠自己一点一点的学习，过程肯定会很曲折。后来自己报了一个线上培训班，课程包括OpenGL、iOS逆向安全攻防、框架设计。对于这些课程的学习我会全部记录成文章，分享给大家一起学习，希望能与大家一起前进。 设计模式主要学的是设计的思想，编程思维，它适用于很多编程语言，如：C++、Objective-c、Swift、Java、Python、Kotlin等等。因为我是一名 iOS 开发者，所以 案例 Demo 我会用 OC 或 Swift 语言来写，对一些常用的设计模式做详细的讲解。 其实，大多数程序员每天都在写着重复的代码，实实在在的搬砖工，然后就形成了一种自己的固定思维，会觉自己的代码写的多优秀，多牛逼，感觉无所不能。工作经验是积累了不少，但是技术却是毫无提升。多去看看人家写的代码，才知道什么叫差距。如果你是一名开发者，你想着每天的工作任务完成就可以了，那么你永远只能是一名低级的程序猿。不要把工作当成是在为老板打工，而应该是想着如何为自己打工。 为何人家那么优秀，为何你自己不可以呢？当你下班在打游戏的时候，人家可能在加班，当你半夜在刷微博，刷抖音的时候，人家还在坚持自我学习提升。不是你不可以，是你在放弃自己，淘汰自己。如果你还年轻，如果你热爱这一行业，请坚持学习下去。。。哈哈哈 何为设计模式（Design pattern）？设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 合理的使用设计模式能帮我们解决开发中的很多问题，可以使我们的项目代码更容易维护。 设计模式的类型设计模式分为三种类型，一共有23种。 一、创建型模式 创建型模式: 这类模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern） 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。 抽象工厂模式（Abstract Factory Pattern） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 单例模式（Singleton Pattern） 保证一个类仅有一个实例，并提供一个访问它的全局访问点，单例模式是最简单的设计模式之一。 建造者模式（Builder Pattern） 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 原型模式（Prototype Pattern） 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 二、结构型模式 结构型模式：这类模式关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern） 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 桥接模式（Bridge Pattern） 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 组合模式（Composite Pattern） 将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 装饰器模式（Decorator Pattern） 动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。 外观模式（Facade Pattern） 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 享元模式（Flyweight Pattern） 运用共享技术有效地支持大量细粒度的对象。 代理模式（Proxy Pattern） 为其他对象提供一个代理以控制对这个对象的访问。 三、行为模式 行为模式：这类模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern） 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它 命令模式（Command Pattern） 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 解释器模式（Interpreter Pattern） 给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。 迭代器模式（Iterator Pattern） 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。 中介者模式（Mediator Pattern） 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 备忘录模式（Memento Pattern） 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 观察者模式（Observer Pattern） 定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。 状态模式（State Pattern） 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 策略模式（Strategy Pattern） 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。 模板模式（Template Pattern）定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 访问者模式（Visitor Pattern）表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-年终总结]]></title>
    <url>%2F2019%2F01%2F02%2F2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>个人记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS 深拷贝与浅拷贝的理解]]></title>
    <url>%2F2018%2F10%2F15%2F2020-09-06.html</url>
    <content type="text"><![CDATA[概念理解浅拷贝浅拷贝是指针拷贝，创建一个新的指针，指向原指针指向的内存，实际的内存并没有发生拷贝，也就是共用同一内存区域, 让目标对象指针和源对象指向同一片内存空间，当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。 深拷贝深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。 总结深拷贝就是内容拷贝，浅拷贝就是指针拷贝。本质区别在于： 是否开启新的内存地址 是否影响内存地址的引用计数 实例讲解非集合类对象不可变对象 NSString 的拷贝123456789101112131415161718// 初始 stringNSString *string = @"hello world";// copy ,浅拷贝(拷贝一个新的指针,指向 string 的内存地址)NSString *cpStr = [string copy];// mutableCopy ,深拷贝(拷贝一个新的指针,并且拷贝一份 新的 string 的内存并指向它)NSMutableString *mutableCpStr = [string mutableCopy]; // 未修改 mutableCpStr 的打印NSLog(@"string : %@, 地址: %p",string,string);NSLog(@"cpStr : %@, 地址: %p",cpStr,cpStr);NSLog(@"mutableCpStr: %@, 地址: %p",mutableCpStr,mutableCpStr); [mutableCpStr setString:@"hello"];// 修改 mutableCpStr 后的打印NSLog(@"修改 mutableCpStr 后的打印:");NSLog(@"修改后:string : %@, 地址: %p",string,string);NSLog(@"修改后:cpStr : %@, 地址: %p",cpStr,cpStr);NSLog(@"修改后:mutableCpStr: %@, 地址: %p",mutableCpStr,mutableCpStr); 打印结果 1234567string : hello world, 地址: 0x1079995e0cpStr : hello world, 地址: 0x1079995e0mutableCpStr: hello world, 地址: 0x60000399a220修改 mutableCpStr 后的打印修改后:string : hello world, 地址: 0x1079995e0修改后:cpStr : hello world, 地址: 0x1079995e0修改后:mutableCpStr: hello, 地址: 0x60000399a220 结论：string与cpStr的内存地址相同,指向同一个内存地址； string与mutableCpStr的内存地址不同，分配了新的内存，修改mutableCpStr的值，不影响 string 的值 可变对象 NSMutableString 的拷贝12345678910111213// 可变对象NSMutableString *mutableString = [NSMutableString stringWithString: @"Hello"];//copy 深拷贝，返回对象不可变id mutableStringCopy = [mutableString copy]; //mutableCopy 深拷贝，返回对象可变NSMutableString *mutableStrMutCp = [mutableString mutableCopy];[mutableStrMutCp appendString:@" world"]; //内存地址都不同NSLog(@"mutableString : %@ ,内存地址: %p", mutableString,mutableString);NSLog(@"mutableStringCopy : %@ ,内存地址: %p", mutableStringCopy,mutableStringCopy);NSLog(@"mutableStrMutCp : %@ ,内存地址: %p", mutableStrMutCp,mutableStrMutCp); 打印结果 123mutableString : Hello ,内存地址: 0x600001b60630mutableStringCopy : Hello ,内存地址: 0xb1642d4e504a8acbmutableStrMutCp : Hello world ,内存地址: 0x600001b606c0 结论：对可变对象 copy，内存地址不同，返回的对象不可变对可变对象 mutableCopy，内存地址也不同，返回的对象可以改变 集合类对象NSArray，NAMutableArray；NSDictionary，NSMutableDictionary；NSSet等集合类对象遵循非集合类对象的拷贝原则 1234567891011121314151617NSArray *array = [NSArray arrayWithObjects:[NSMutableString stringWithString:@"hello"],@"world",@"good", nil];//未创建了新的容器，容器内的元素是指针赋值（浅拷贝）NSArray *arrayCopy = [array copy];//创建了新的容器，容器内的元素是指针赋值（浅拷贝）NSMutableArray *arrayMutableCopy = [array mutableCopy]; NSLog(@"array : %p", array);NSLog(@"arrayCopy : %p", arrayCopy);NSLog(@"arrayMutableCopy: %p", arrayMutableCopy); //容器内的对象是浅拷贝，即它们在内存中只有一份NSMutableString *testString = [array objectAtIndex:0];[testString appendString:@" you"];//三个数组的内容同时改变NSLog(@"array[0] : %@", array[0]);NSLog(@"arrayCopy[0] : %@", arrayCopy[0]);NSLog(@"arrayMutableCopy[0] : %@", arrayMutableCopy[0]); 打印结果 123456array : 0x60000190d9e0arrayCopy : 0x60000190d9e0arrayMutableCopy: 0x60000190da10array[0] : hello youarrayCopy[0] : hello youarrayMutableCopy[0] : hello you]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发-Socket通信原理]]></title>
    <url>%2F2018%2F09%2F10%2FiOSSocketStudy.html</url>
    <content type="text"><![CDATA[网络协议1.网络协议有：TCP/IP、Scoket、HTTP等等。 OSI七层网络模型由上到下分别是 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 http协议对应于应用层 tcp协议对应于传输层 ip协议对应于网络层 TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。三者本质上没有可比性。 何况HTTP协议是基于TCP连接的。网络层的”ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程 TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。TCP/IP协议存在于OS中，网络服务通过OS提供，在OS中增加支持TCP/IP的系统调用——Berkeley套接字，如Socket，Connect，Send，Recv等UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。如图： TCP/IP协议族包括运输层、网络层、链路层，而socket所在位置如图，Socket是应用层与TCP/IP协议族通信的中间软件抽象层。 Http和Socket连接的区别TCP连接TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。 建立起一个TCP连接需要经过“三次握手”： 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 一个完整的三次握手也就是： 请求—应答—再次确认。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手” HTTP连接HTTP协议即超文本传送协议(HypertextTransferProtocol )是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。 HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。 1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。 2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。 由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。 Socket原理socket概念Socket:又称”套接字”,应用程序通过”套接字”向网络发送请求或应答,它是一个针对TCP和UDP编程的接口，借助它建立TCP/UDP连接。socket连接就是所谓的长连接,理论上客户端和服务器端一旦建立起连接将不会主动断掉.它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。 应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。 服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。 建立socket连接建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 SOCKET连接与TCP连接创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。 Socket连接与HTTP连接由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。 而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。 HTTP协议—Socket连接–TCP连接关系: HTTP协议提供了封装或者显示数据的具体形式; Socket连接提供了网络通信的能力; TCP连接提供如何在网络中传输; socket是纯C语言的,跨平台; HTTP协议是基于socket的,底层使用的就是socket; 创建Socket连接时，可以指定使用的传输层协议(TCP或UDP),当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。 TCP和UDP区别 基于连接和无连接 对系统资源要求(TCP较多,UDP较少) UDP程序结构较简单 TCP是流模式,UDP是数据报模式 可靠性:TCP保证数据正确性,UDP可能丢包,不保证数据准确性]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-Swif Moya(一) 网络抽象层学习]]></title>
    <url>%2F2018%2F08%2F10%2FiOS-Swift-Moya%E4%B8%80.html</url>
    <content type="text"><![CDATA[什么是Moya？Moya是基于 Alamofire 的更高网络请求抽象层。我们可以看做是网络管理层，用来封装 URL、请求头、请求体、请求参数等网络请求信息。客户端代码直接操作Moya管理请求，而不与Alamofire进行直接接触，形成更高层次的网络请求层，易于维护更新。 Moya Github地址: https://github.com/`Moya`/`Moya` Moya的一些特色功能: 对正确的API端点访问进行编译时检查. 让您使用关联的枚举值定义不同端点的清晰用法. 把test stub作为一等公民，所以单元测试超级简单. 提供了 ReactiveSwift 和 RxSwift 扩展 Moya图解 安装配置CocoaPods 在您的Podfile文件中使用Moya: 123456789pod &apos;Moya&apos;, &apos;~&gt; 11.0&apos;# or pod &apos;Moya/RxSwift&apos;, &apos;~&gt; 11.0&apos;# orpod &apos;Moya/ReactiveSwift&apos;, &apos;~&gt; 11.0&apos; 然后运行 pod install. 在任何您想使用Moya的文件中，请导入框架，通过 import Moya 示例代码 首先创建一个 Moya 网络请求管理器 ZJHomeAPI.swift, 导入 Moya框架 然后定义一个 MoyaProvider 对象 HomeProvider，即请求发起对象,如果要首页发起网络请求就使用这个 HomeProvider。 接着声明一个 enum 枚举来对请求进行明确分类，这里我们定义两个枚举值分别表示获取斗鱼直播的推荐分类列表、分类列表 最后让这个 enum 实现 TargetType 协议，在这里面定义我们各个请求的 url、参数、header 等信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//// ZJHomeAPI.swift// DouYuLive//// Created by 邓志坚 on 2018/8/5.// Copyright © 2018年 邓志坚. All rights reserved.//import UIKitimport Moyalet HomeProvider = MoyaProvider&lt;HomeAPI&gt;()public enum HomeAPI &#123; case recommendCategoryList //推荐分类列表 case liveCateList //分类列表 &#125;// 实现 TargetType 协议extension HomeAPI : TargetType &#123; //服务器基地址 public var baseURL: URL &#123; switch self &#123; case .recommendCategoryList: return URL(string: "https://apiv2.douyucdn.cn")! case .liveCateList: return URL(string: "https://apiv2.douyucdn.cn")! &#125; &#125; //请求的具体URL public var path: String &#123; switch self &#123; case .recommendCategoryList: return "/live/cate/getLiveRecommendCate2" case .liveCateList: return "/live/cate/getLiveCate1List" &#125; &#125; //请求类型 public var method: Moya.Method &#123; switch self &#123; case .recommendCategoryList: return .get case .liveCateList: return .get &#125; &#125; //请求任务事件（这里附带上参数） public var task: Task &#123; switch self &#123; case .recommendCategoryList: var params: [String: Any] = [:] params["client_sys"] = "ios" return .requestParameters(parameters: params, encoding: URLEncoding.default) case .liveCateList: var params: [String: Any] = [:] params["client_sys"] = "ios" return .requestParameters(parameters: params, encoding: URLEncoding.default) &#125; &#125; //是否执行Alamofire验证 public var validate: Bool &#123; return false &#125; //这个就是做单元测试模拟的数据，只会在单元测试文件中有作用 public var sampleData: Data &#123; return "&#123;&#125;".data(using: String.Encoding.utf8)! &#125; //配置请求头 public var headers: [String : String]? &#123; return nil &#125; &#125; 在 ViewController 中导入 import SwiftyJSON,如果没有这个框架 则使用 CocoaPods 导入 SwiftyJSON 框架 pod &#39;SwiftyJSON&#39; 12345678910111213141516//推荐分类列表数据var cateList:Array&lt;JSON&gt; = []// 获取推荐分类数据private func loadCateListData() &#123; HomeProvider.request(HomeAPI.recommendCategoryList) &#123; (response) in if case let .success(result) = response &#123; //使用 SwiftJSON解析数据 let data = try? result.mapJSON() let json = JSON(data!) self.cateList = json["data"]["cate2_list"].arrayValue self.collectionView.reloadData() print(json) &#125; &#125;&#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Moya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式学习笔记(一)]]></title>
    <url>%2F2018%2F07%2F23%2FCSS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80.html</url>
    <content type="text"><![CDATA[1. z-index定义和用法z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 注释：元素可拥有负的 z-index 属性值。注释：Z-index 仅能在定位元素上奏效（例如 position:absolute;） 说明该属性设置一个定位元素沿 z 轴的位置，z 轴定义为垂直延伸到显示区的轴。如果为正数，则离用户更近，为负数则表示离用户更远。 2.box-shadowbox-shadow是向盒子添加阴影。支持添加一个或者多个 1、阴影模糊半径与阴影扩展半径的区别 阴影模糊半径：此参数可选，其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊； 阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小； 2、X轴偏移量和Y轴偏移量值可以设置为负数 1box-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式]; 示例代码： 123.box_shadow&#123; box-shadow:4px 2px 6px #333333; &#125; 注意：inset 可以写在参数的第一个或最后一个，其它位置是无效的。 3.border-imageborder-image 给边框添加背景图片 4.渐变色彩CSS3 Gradient 分为线性渐变(linear)和径向渐变(radial).由于不同的渲染引擎实现渐变的语法不同，这里我们只针对线性渐变的 W3C 标准语法来分析其用法，其余大家可以查阅相关资料。W3C 语法已经得到了 IE10+、Firefox19.0+、Chrome26.0+ 和 Opera12.1+等浏览器的支持。 线性渐变: 参数： 第一个参数:指定渐变方向，可以用“角度”的关键词或“英文”来表示：第一个参数省略时，默认为“180deg”，等同于“to bottom”。 第二个和第三个参数，表示颜色的起始点和结束点，可以有多个颜色值。 示例代码 1background-image:linear-gradient(to left, red, orange,yellow,green,blue,indigo,violet); 效果图： 5.文字与字体text-overflow用来设置是否使用一个省略标记（…）标示对象内文本的溢出。语法： 但是text-overflow只是用来说明文字溢出时用什么方式显示，要实现溢出时产生省略号的效果，还须定义强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省略号的效果，代码如下： 123text-overflow:ellipsis; overflow:hidden; white-space:nowrap; 同时，word-wrap也可以用来设置文本行为，当前行超过指定容器的边界时是否断开转行。 语法：normal为浏览器默认值，break-word设置在长单词或 URL地址内部进行换行，此属性不常用，用浏览器默认值即可。 嵌入字体@font-face@font-face能够加载服务器端的字体文件，让浏览器端可以显示用户电脑里没有安装的字体 语法： 1234@font-face &#123; font-family : 字体名称; src : 字体文件在服务器上的相对或绝对路径;&#125; 这样设置之后，就可以像使用普通字体一样在（font-*）中设置字体样式。 比如： 12345p &#123; font-size :12px; font-family : &quot;My Font&quot;; /*必须项，设置@font-face中font-family同样的值*/&#125; text-shadow可以用来设置文本的阴影效果。语法： 1text-shadow: X-Offset Y-Offset blur color; X-Offset：表示阴影的水平偏移距离，其值为正值时阴影向右偏移，反之向左偏移； Y-Offset：是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移，反之向上偏移； Blur：是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将Blur值设置为0； Color：是指阴影的颜色，其可以使用rgba色。 比如，我们可以用下面代码实现设置阴影效果。 1text-shadow: 0 1px 1px #fff 6.背景background-origin background-origin 设置元素背景图片的原始起始位置。 语法： 1background-origin ： border-box | padding-box | content-box; 参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。 效果如下： 注意：如果背景不是no-repeat，这个属性无效，它会从边框开始显示。 background-size 设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。 语法： 1background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain 取值说明： 1、auto：默认值，不改变背景图片的原始高度和宽度； 2、&lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放； 3、&lt;百分比&gt;：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上； 4、cover：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器； 5、contain：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。 提示：大家可以在右边的编辑窗口输入自己的代码尝试不同取值的效果。 multiple backgrounds 多重背景 多重背景，也就是CSS2里background的属性外加origin、clip和size组成的新background的多次叠加，缩写时为用逗号隔开的每组值；用分解写法时，如果有多个背景图片，而其他属性只有一个（例如background-repeat只有一个），表明所有背景图片应用该属性值。 语法缩写如下： 123background ： [background-color] | [background-image] | [background-position][/background-size] | [background-repeat] | [background-attachment] | [background-clip] | [background-origin],... 可以把上面的缩写拆解成以下形式： 1background-image:url1,url2,...,urlN; 1234567background-repeat : repeat1,repeat2,...,repeatN;backround-position : position1,position2,...,positionN;background-size : size1,size2,...,sizeN;background-attachment : attachment1,attachment2,...,attachmentN;background-clip : clip1,clip2,...,clipN;background-origin : origin1,origin2,...,originN;background-color : color; 注意： 用逗号隔开每组 background 的缩写值；如果有 size 值，需要紧跟 position 并且用 “/“ 隔开；如果有多个背景图片，而其他属性只有一个（例如 background-repeat 只有一个），表明所有背景图片应用该属性值。background-color 只能设置一个。]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发 蓝牙通信基础知识(一)]]></title>
    <url>%2F2018%2F07%2F03%2FiOS%E5%BC%80%E5%8F%91-%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[一、 蓝牙常见名称与类别 MFI ： make for ipad ,iphone, itouch 专们为苹果设备制作的设备，只有少数的硬件厂商才有苹果的MFI认证 BLE ： buletouch low energy，蓝牙4.0设备因为低耗电，所以也叫做BLE peripheral,central ：外设和中心,发起连接的时central，被连接的设备为perilheralservice and characteristic ： 服务和特征 每个设备会提供服务和特征，类似于服务端的api，但是机构不同。每个外设会有很多服务，每个服务中包含很多字段，这些字段的权限一般分为 读read，写write，通知notiy几种，就是我们连接设备后具体需要操作的内容。Description 每个characteristic可以对应一个或多个Description用户描述characteristic的信息或属性MFI 开发使用ExternalAccessory 框架4.0 BLE 开发使用CoreBluetooth 框架 蓝牙和版本的使用限制 蓝牙2.0 ：需要越狱设备才能使用，否则只有IOS设备和苹果认证的MFI设备才可以被IOS设备检索到蓝牙4.0 ：IOS6以上系统，苹果开放了BLE通道，没有MFI认证的蓝牙设备可以连接。（4s之后的设备）MFI认证设备（Make For ipod/ipad/iphone）无限制 二、CoreBluetooth框架介绍CoreBluetooth框架的核心其实是两个东西，peripheral和central, 可以理解成外设和中心。对应他们分别有一组相关的API和类 CoreBluetooth框架有两种模式：一种是中心模式，以App 作为中心，连接其他的外部设备。 另一种是外设模式，使用手机作为其他中心设备的场景。 每个设备都会有一些服务，每个服务里面都会有一些特征，特征就是具体键值对，提供数据的地方。每个特征属性分为这么几种：读，写，通知这么几种方式。 12345678910111213//objcetive c特征的定义枚举 typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties) &#123; CBCharacteristicPropertyBroadcast = 0x01, CBCharacteristicPropertyRead = 0x02, CBCharacteristicPropertyWriteWithoutResponse = 0x04, CBCharacteristicPropertyWrite = 0x08, CBCharacteristicPropertyNotify = 0x10, CBCharacteristicPropertyIndicate = 0x20, CBCharacteristicPropertyAuthenticatedSignedWrites = 0x40, CBCharacteristicPropertyExtendedProperties = 0x80, CBCharacteristicPropertyNotifyEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x100, CBCharacteristicPropertyIndicateEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x200 &#125;; 外设、服务、特征间的关系 三、蓝牙开发流程1.蓝牙中心模式流程 建立中心角色 扫描外设（discover） 连接外设(connect) 扫描外设中的服务和特征(discover) 4.1 获取外设的services 4.2 获取外设的Characteristics,获取Characteristics的值，获取Characteristics的Descriptor和Descriptor的值 与外设做数据交互(explore and interact) 订阅Characteristic的通知 断开连接(disconnect)** 蓝牙外设模式流程 启动一个Peripheral管理对象 本地Peripheral设置服务,特性,描述，权限等等 Peripheral发送广告 设置处理订阅、取消订阅、读characteristic、写characteristic的委托方法 蓝牙设备状态 待机状态（standby）：设备没有传输和发送数据，并且没有连接到任何设 广播状态（Advertiser）：周期性广播状态 扫描状态（Scanner）：主动寻找正在广播的设备 发起链接状态（Initiator）：主动向扫描设备发起连接。 主设备（Master）：作为主设备连接到其他设备。 从设备（Slave）：作为从设备连接到其他设备。 蓝牙设备的五种工作状态 准备（standby） 广播（advertising） 监听扫描（Scanning 发起连接（Initiating） 已连接（Connected） 四、蓝牙开发注意点 关于Mac地址的获取自iOS7之后，苹果不支持获取Mac地址，只能用UUID来标识设备，要注意的是同一个设备在不同手机上显示的UUID不相同，但有的设备可以通过 “180A”这个服务来发现特征，再来读取 “2A23”这个特征值，可以获得Mac地址。如果你的蓝牙设备不支持这样获取,你可以跟硬件工程师沟通，来获得Mac地址，添加一个获取地址命令或者增加一个含地址的特征值都可以很容易的获取。上面获取地址的前提都是需要先建立连接，如果一定要在扫描的时候获得Mac地址，让硬件工程师把数据写入广播包里，看是否可行。 数据传输大小问题，最适宜的传输大小应该小于20字节，大于这个20个字节，数据丢失比较大，如果数据大于这个20字节可以分段发送 数据转换的问题发送的蓝牙数据是一个数据包前三位是固定的所以前三位先不管，但是我们后面的数据是需要去获取的，需要获取系统的当前时间和 chensum（前三位+时间 = chensum） 下载一个LightBlue 协助开发一个设备有很多服务，服务中又有很多特性，特性中又分读的，写的等，使用LightBlue，可以很快的找到你需要的特性。 一般的蓝牙都要支持重连和后台运行，如果扫描设备的时候,用这个方法- (void)scanForPeripheralsWithServices:options:没有指定特定的服务，而是用nil代替，设备在后台断开的时候是不会重连的。 蓝牙是可以同时连接多个外部设备。 关于readValueForCharacteristic和 setNotifyValue:forCharacteristic: 的区别， readValueForCharacteristic适合用来读取数据不怎么更新的特征值， 如果获取的数据是经常更新的，那就 一定要用setNotifyValue:forCharacteristic:来订阅这个特征。 当我们写入命令时writeValue:forCharacteristic:type:,这个type类用CBCharacteristicWriteWithoutResponse，这个特征值可读，还可以通知。 代理方法- (void)centralManagerDidUpdateState:(CBCentralManager *)central;一定要调用，否则会报错，这个方法只要设置中心设备的代理之后，就一定会走，我们最开始的扫描外设应放在这个方法里； IOS对连接参数要求另外附上苹果对connection interval的要求, 其实还有其他的连接参数要求, 比如slave latency, supervision timeout, 如果不满足这些, IOS设备会拒绝. ● Interval Max (Slave Latency + 1) ≤ 2 seconds● Interval Min ≥ 20 ms● Interval Min + 20 ms ≤ Interval Max Slave Latency ≤ 4 //这个是这样么？？？● connSupervisionTimeout ≤ 6 seconds● Interval Max (Slave Latency + 1) * 3 &lt; connSupervisionTimeout 五、名词解释 GAAT : Generic Attribute Profile , GATT配置文件是一个通用规范，用于在BLE链路上发送和接收被称为“属性”的数据块。目前所有的BLE应用都基于GATT。 蓝牙SIG规定了许多低功耗设备的配置文件。配置文件是设备如何在特定的应用程序中工作的规格说明。注意一个设备可以实现多个配置文件。例如，一个设备可能包括心率监测仪和电量检测。 Characteristic 一个characteristic包括一个单一变量和0-n个用来描述characteristic变量的descriptor，characteristic可以被认为是一个类型，类 似于类。 Descriptor Descriptor用来描述characteristic变量的属性。例如，一个descriptor可以规定一个可读的描述，或者一个characteristic变量可接受的范围，或者一个characteristic变量特定的测量单位。 Service service是characteristic的集合。例如，你可能有一个叫“Heart Rate Monitor(心率监测仪)”的service，它包括了很多characteristics，如“heart rate measurement(心率测量)”等。你可以在bluetooth.org 找到一个目前支持的基于GATT的配置文件和服务列表。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发 NSPredicate-谓词的学习与使用]]></title>
    <url>%2F2018%2F07%2F03%2FiOS%E5%BC%80%E5%8F%91-NSPredicate-%E8%B0%93%E8%AF%8D%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[NSPredicateCocoa 中提供了一个NSPredicate的类,该类主要用于指定过滤器的条件, 每一个对象通过谓词进行筛选,判断条件是否匹配。一种逻辑条件的定义，用于约束对获取或内存过滤的搜索。 概述 谓词表示逻辑条件，可用于筛选对象集合。虽然直接从ns比较谓词、NSCompoundPredicate和NSExpression的实例创建谓词很常见，但是您经常从格式字符串创建谓词，该格式字符串由NSPredicate上的类方法解析。谓词格式字符串的例子包括:简单的比较，例如grade = “7”或firstName如”Shaffiq”大小写不敏感查找，如名称包含[cd] “itroen”逻辑操作，例如(firstName like“Mark”)或(lastName like“Adderley”)时间范围限制，例如日期介于{ $YESTERDAY， $TOMORROW}。关系条件，如group.name，如“work*”聚合操作，如@sum.items。价格&lt; 1000有关完整的语法引用，请参阅谓词编程指南。您还可以使用evaluate(with: substitute variables:)方法创建包含变量的谓词，以便在运行时.v替换具体值之前预定义谓词 方法1.+ (NSPredicate *)predicateWithFormat:(NSString *)predicateFormat, ...;创建并返回一个新的谓词，该谓词通过创建一个具有给定格式的新字符串并解析结果而形成。有关格式字符串的格式和变量替换的限制的详细信息，请参阅谓词格式字符串语法。 2.+ (NSPredicate *)predicateWithFormat:(NSString *)predicateFormat argumentArray:(nullable NSArray *)arguments;通过将给定数组中的值替换为格式字符串并解析结果来初始化谓词。有关格式字符串的格式和变量替换的限制的详细信息，请参阅谓词格式字符串语法。 3.+ (NSPredicate *)predicateWithFormat:(NSString *)predicateFormat arguments:(va_list)argList;通过将参数列表中的值替换为格式字符串并解析结果来初始化谓词。有关格式字符串的格式和变量替换的限制的详细信息，请参阅谓词格式字符串语法。将argList中的值替换为谓词格式并解析结果的新谓词。 4.+ (NSPredicate *)predicateWithValue:(BOOL)value;创建并返回一个谓词，该谓词总是计算为给定的布尔值 5.+ (NSPredicate*)predicateWithBlock:(BOOL (^)(id _Nullable evaluatedObject, NSDictionary&lt;NSString *, id&gt; * _Nullable bindings))block API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));初始化使用指定块对象和绑定字典计算的谓词。在macOS 10.6和以后版本中，核心数据支持内存和原子存储中的基于块的谓词，但不支持基于sql的存储。 使用使用条件字符表 检索出某个范围的元素12345678NSArray *array = @[@123,@66,@89,@45,@101,@18,@666,@75];NSPredicate *predicte = [NSPredicate predicateWithFormat:@"SELF BETWEEN &#123;60,100&#125;"];NSArray *tmp = [array filteredArrayUsingPredicate:predicte];NSLog(@"%@",tmp); 123452018-07-03 12:20:11.469946+0800 NewDemo[20729:4562901] ( 66, 89, 75)]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>NSPredicate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods 创建公有库,配置podspec文件]]></title>
    <url>%2F2018%2F06%2F19%2FCocoaPods-%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E5%BA%93-%E9%85%8D%E7%BD%AEpodspec%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[目录 如何创建podspec文件 如何编写podspec文件 如何实现目录分层 如何校验podspec文件 更新维护 1.如何创建podspec文件创建podspec文件只需要一行命令，在你自己的三方库的根目录下输入下面的命令： 1pod spec create XXXKit 然后在项目目录下将会生成一个podspec文件 2.如何编写podspec文件我们先来打开ZJKitTool.podspec文件看看里面的内容。基本都是针对ZJKitTool的描述和介绍 一些常用的信息介绍： name：框架名version：当前版本（注意，是当前版本，假如你后续更新了新版本，需要修改此处）summary：简要描述，在pod search ZCPKit的时候会显示该信息。description：详细描述homepage：页面链接license：开源协议author：作者source：源码git地址platform：支持最低ios版本source_files：源文件（可以包含.h和.m）public_header_files：头文件(.h文件)resources：资源文件（配置的文件都会被放到mainBundle中）resource_bundles：资源文件（配置的文件会放到你自己指定的bundle中）frameworks：依赖的系统框架vendored_frameworks：依赖的非系统框架libraries：依赖的系统库vendored_libraries：依赖的非系统的静态库dependency：依赖的三方库 上面列举的信息大部分来自pod默认生成的podspec文件中的给的，其中需要重点注意标识黑体的这几个信息。 你在三方库中看到的那些文件都是通过这些配置来确定的。当pod install引入三方库时，只会引入你在podspec中配置的那些文件。 下面我会举例说明该如何写podsepc中的每项配置。 如图所示的目录结构，每个配置项的写法如下： source_files：配置三方库的源文件（.h或.m文件） 写法：source_files = ‘ZJKitTool/ZJHelperKit.h’ // 直接指定文件名或：source_files = ‘ZJKitTool/.{h,m}’ // ZJKitTool文件夹下的所有匹配文件source_files = ‘ZJKitTool/**/.{h,m}’ // ZJKitTool所有路径下的所有匹配文件public_header_files：配置公有的头文件（.h文件） vendored_frameworks：配置需要引用的非系统框架（*/的写法后面不再赘述） 写法：vendored_frameworks = ‘Frameworks/MyFramework.framework’frameworks：配置依赖的系统框架 写法：frameworks = ‘AVFoundation’, ‘CoreGraphics’, ‘Security’, ‘SystemConfiguration’vendored_libraries：配置需要引用的非系统静态库（要注意，这里的.a静态库名字必须要带lib前缀，如果引用的静态库名字没lib前缀会导致编译报错，只需要重命名加上即可） 写法：vendored_libraries = ‘Frameworks/libZCPKit.a’libraries：配置依赖的系统库（要注意，这里的写法需要忽略lib前缀） 写法：libraries = ‘c++’, ‘sqlite3’, ‘stdc++.6.0.9’, ‘z’resources：配置资源文件（.bundle，.png，.txt等资源文件，这些资源文件会被放到mainBundle中，要注意避免发生命名重复的问题） 写法：resources = ‘Resources/MyRes.bundle’resource_bundles：配置指定bundle的资源文件（可以解决resources导致的命名冲突问题） 写法：resource_bundles = { ‘ZJKitToolBundle’ =&gt; [‘Resources/MyRes.bundle’],}dependency：依赖的三方库，pod库或者可以是自身的subspec 写法：dependency ‘AFNetworking’, ‘~&gt;3.1.0’ // pod三方库dependency ‘Util’ // 自身的subspec或dependency ‘AFNetworking’附上官网链接，可以去看一看：specs-and-specs-repo关于资源文件更详细的写法，可以看这篇文章：给 Pod 添加资源文件 3.如何实现目录分层使用subspec来实现目录分层。目录分层的好处： 目录分层，结构清晰；使用pod引入一个三方库时，可以只引入一个subspec而不用将整个三方库引入。 如果想有多层的目录结构还可以继续嵌套下去。 有几个需要注意的地方： 12345678910111213141.层级不能出现循环依赖。* 比如类 UIAlertView+ZJHelperKitUIKit.h 中引用#import &quot;NSArray+ZJHelperKit.h&quot;，同时 NSArray+ZJHelperKit.h中引用 #import &quot;UIAlertView+ZJHelperKitUIKit.h&quot;。这样当写podspec时就需要在Object层级中写dependency &apos;ZCCategory/UIKit&apos;，在UIKit层级中写dependency &apos;ZCCategory/Object&apos;。如此便存在UIKit与Object层级之间的循环依赖。出现循环依赖时，三方库是无法成功提交到repo上的，会报依赖错误。解决办法是，层级间要尽量解耦。2.分层的层级不要太多，层级不要太深。为了避免出现上述的循环依赖错误。3.source_files使用的是真实的物理路径，而dependency依赖其他层级时使用的是层级路径，不是真实的物理路径例如：NSArray+ZJHelperKit.h 文件的真实路径是：ZJKitTool/ZJCategory/Object，而Object层级是属于ZJCategory层级下的一个子subspec，所以当写UIKit层级依赖Object层级时要写：dependency &apos;ZJCategory/Object&apos;而不是dependency &apos;ZJKitTool/ZJCategory/Object&apos; 4.如何校验podspec文件在podspec写好之后我们需要验证一下编写的内容是否有误。可以在命令行的三方库当前路径下使用下面的命令： lib lint （从本地验证你的pod能否通过验证）12345pod spec lint （从本地和远程验证你的pod能否通过验证）pod lib lint --verbose （加--verbose可以显示详细的检测过程，出错时会显示详细的错误信息）pod lib lint --allow-warnings (允许警告，用来解决由于代码中存在警告导致不能通过校验的问题)pod lib lint --help （查看所有可选参数，可选参数可以加多个） 我们目前只是在本地写的三方库，所以只需要使用pod lib lint验证即可（这个过程会较为费时，需要稍微等待）。 需要注意的：在检测的时候会很经常会出现各种乱七八糟的错误，在文件多的情况下不太容易一次通过，并且即使你的代码在Xcode中编译通过了，但是也还是会出现很多错误。所以你需要尽量去注意下面的几个问题： 1.当代码中存在警告时要记得使用–allow-warnings参数。 2.如果引入的文件或分好的层级需要依赖系统库或三方库，要记得使用上面介绍的libararies，frameworks等属性。 3.如果你的三方库是在一个xcode项目中编写调试，那么尽量不要用pch。 因为很多类之间的小依赖会被pch给遮掩过去，这会导致在校验时出现大量错误。4.如果想要分层，那么尽量解耦使模块能够单独存在。 原因是当分层较多层级较深时，很可能产生循环依赖的问题。 更新维护当你的代码更新维护后，就需要重写发布，流程是： 更新ZJKitTool.podspec中的版本号打上标签推送远程pod trunk push ZJKitTool.podspec 推送到pods仓库 如果有引用到库framwork或C语言库的话必须使用 –use-libraries –allow-warnings 允许警告 检测本地与远程是否通过 pod spec lint –allow-warnings pod spec lint ZJKitTool.podspec –use-libraries –allow-warnings 检测本地与是否通过pod lib lint –allow-warnings pod lib lint ZJKitTool.podspec –use-libraries –allow-warnings 上传到 cocoapodspod trunk push ZJKitTool.podspec –use-libraries –allow-warnings 必须保证github上有上传框架代码和示例代码，同时保证统一和上传tag版本–use-libraries (有引用框架时，需加入 –use-libraries) 最后回到项目的根目录 pod update 更新最新版本]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发 UIBezierPath学习]]></title>
    <url>%2F2018%2F06%2F16%2FiOS%E5%BC%80%E5%8F%91-UIBezierPath%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[一、属性1234567891011121314151617181920212223242526272829303132333435363738394041// 将UIBezierPath类转换成CGPath，类似于UIColor的CGColor@property(nonatomic) CGPathRef CGPath; // empty：只读类型，路径上是否有有效的元素@property(readonly,getter=isEmpty) BOOL empty;// bounds：和view的bounds是不一样的，它获取path的X坐标、Y坐标、宽度，但是高度为0@property(nonatomic,readonly) CGRect bounds;// currentPoint：当前path的位置，可以理解为path的终点@property(nonatomic,readonly) CGPoint currentPoint;// lineWidth：path线的宽度@property(nonatomic) CGFloat lineWidth;// lineCapStylepath端点样式，有3种样式@property(nonatomic) CGLineCap lineCapStyle;/* Line cap styles. */typedef CF_ENUM(int32_t, CGLineCap) &#123; kCGLineCapButt, // 无端点 kCGLineCapRound, // 圆形端点 kCGLineCapSquare // 方形端点（样式上和kCGLineCapButt是一样的，但是比kCGLineCapButt长一点）&#125;;// 拐角样式@property(nonatomic) CGLineJoin lineJoinStyle;/* Line join styles. */typedef CF_ENUM(int32_t, CGLineJoin) &#123; kCGLineJoinMiter, // 尖角 kCGLineJoinRound, // 圆角 kCGLineJoinBevel // 缺角&#125;;// miterLimit:最大斜接长度（只有在使用kCGLineJoinMiter是才有效）， 边角的角度越小，斜接长度就会越大@property(nonatomic) CGFloat miterLimit; // Used when lineJoinStyle is kCGLineJoinMiter// flatness:弯曲路径的渲染精度，默认为0.6，越小精度越高，相应的更加消耗性能。@property(nonatomic) CGFloat flatness;//usesEvenOddFillRule：单双数圈规则是否用于绘制路径，默认是NO。@property(nonatomic) BOOL usesEvenOddFillRule; // Default is NO. When YES, the even-odd fill rule is used for drawing, clipping, and hit testing. 二、UIBezierPath创建方法1、实例化UIBezierPath对象 + (instancetype)bezierPath;12345- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path = [UIBezierPath bezierPath]; &#125; 2、 在Rect里面画一个矩形+ (instancetype)bezierPathWithRect:(CGRect)rect; 12345678- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path1 = [UIBezierPath bezierPathWithRect:CGRectMake(100, 80, 80, 80)]; [[UIColor orangeColor] set]; path1.lineWidth = 3; [path1 stroke]; &#125; 3.在rect里的画一个内切曲线:+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect; 12345678- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path2 = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 180, 100)]; [[UIColor orangeColor] set]; path2.lineWidth = 3; [path2 stroke]; &#125; 3.根据一个Rect 画一个圆角矩形曲线 (Radius:圆角半径) 当Rect为正方形时且Radius等于边长一半时画的是一个圆+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius; 12345678910111213- (void)drawRect:(CGRect)rect &#123; rect = CGRectMake(130,100, 150,90); UIBezierPath *path3 = [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:8]; [[UIColor blueColor] set]; [path3 fill]; path3.lineWidth = 3; [[UIColor redColor] set]; [path3 stroke]; &#125; 4.根据Rect针对四角中的某个或多个角设置圆角1234567891011121314151617181920/** * 参数： * rect-&gt;矩形的Frame * corners-&gt;指定的圆角 * cornerRadii-&gt;圆角的大小 */+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii;// 使用- (void)drawRect:(CGRect)rect &#123; rect = CGRectMake(130,100, 150,90); UIBezierPath *path4 = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners: UIRectCornerTopLeft|UIRectCornerBottomRight cornerRadii:CGSizeMake(10,50)]; [[UIColor purpleColor] set]; [path4 fill]; [[UIColor yellowColor] set]; [path4 stroke]; &#125; 5.以某个中心点画弧线123456789101112131415161718192021/** * 参数： * center-&gt;圆点 * radius-&gt;半径 * startAngle-&gt;起始位置 * endAngle-&gt;结束位置 * clockwise-&gt;是否顺时针方向 */+ (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise;// 使用- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path5 = [UIBezierPath bezierPathWithArcCenter:CGPointMake(180, 180) radius:100 startAngle:0 endAngle:90 clockwise:YES]; [[UIColor purpleColor] set]; [path5 fill]; path5.lineWidth = 3; [[UIColor orangeColor] set]; [path5 stroke]; &#125; 6.根据CGPath创建并返回一个新的UIBezierPath对象1+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath 7.建并返回一个新的BezierPath, 这个 BezierPath 的方向是原 BezierPath 的反方向123456/** * 通过该方法反转一条路径, 并不会修改该路径的样子. 它仅仅是修改了绘制的方向 * @return: 返回一个新的 UIBezierPath 对象, 形状和原来路径的形状一样, * 但是绘制的方向相反. */- (UIBezierPath *) bezierPathByReversingPath; 三、构造路径1.将 UIBezierPath 对象的 currentPoint 移动到指定的点123456789/** * 如果当前有正在绘制的子路径, 该方法则会隐式的结束当前路径, * 并将 currentPoint 设置为指定点. 当上一条子路径被终止, 该方法 * 实际上并不会去闭合上一条子路径. 所以上一条自路径的起始点 和 * 结束点并没有被链接. * 对于大多数构造路径相关的方法而言, 在你绘制直线或曲线之前, 需要先调用这个方法. * @param point: 当前坐标系统中的某一点 */- (void)moveToPoint:(CGPoint)point; 2.在当前子路径中追加一条直线123456789/** * 该方法将会从 currentPoint 到 指定点 链接一条直线. * Note: 在追加完这条直线后, 该方法将会更新 currentPoint 为 指定点 * 调用该方法之前, 你必须先设置 currentPoint. 如果当前绘制路径 * 为空, 并且未设置 currentPoint, 那么调用该方法将不会产生任何 * 效果. * @param point: 绘制直线的终点坐标, 当前坐标系统中的某一点 */- (void)addLineToPoint:(CGPoint)point; 3.在当前子路径中追加一条圆弧1234567891011121314/** * 该方法将会从 currentPoint 添加一条指定的圆弧. * 该方法的介绍和构造方法中的一样. 请前往上文查看 * @param center: 圆心 * @param radius: 半径 * @param startAngle: 起始角度 * @param endAngle: 结束角度 * @param clockwise: 是否顺时针绘制 */- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0); 4.在当前 子路经中追加一条 三次贝塞尔曲线1234567891011121314/** * 该方法将会从 currentPoint 到 指定的 endPoint 追加一条三次贝塞尔曲线. * 三次贝塞尔曲线的弯曲由两个控制点来控制. 如下图所示 * Note: 调用该方法前, 你必须先设置 currentPoint, 如果路径为空, * 并且尚未设置 currentPoint, 调用该方法则不会产生任何效果. * 当添加完贝塞尔曲线后, 该方法将会自动更新 currentPoint 为 * 指定的结束点 * @param endPoint: 终点 * @param controlPoint1: 控制点1 * @param controlPoint2: 控制点2 */- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2; 5.当前 子路经中追加一条 二次贝塞尔曲线12345678910111213/** * 该方法将会从 currentPoint 到 指定的 endPoint 追加一条二次贝塞尔曲线. * currentPoint、endPoint、controlPoint 三者的关系最终定义了二次贝塞尔曲线的形状. * 二次贝塞尔曲线的弯曲由一个控制点来控制. 如下图所示 * Note: 调用该方法前, 你必须先设置 currentPoint, 如果路径为空, * 并且尚未设置 currentPoint, 调用该方法则不会产生任何效果. * 当添加完贝塞尔曲线后, 该方法将会自动更新 currentPoint 为 * 指定的结束点 * @param endPoint: 终点 * @param controlPoint: 控制点 */- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint; 6.关闭当前子路经123456/** * 该方法将会从 currentPoint 到子路经的起点 绘制一条直线, * 以此来关闭当前的自路径. 紧接着该方法将会更新 currentPoint * 为 刚添加的这条直线的终点, 也就是当前子路经的起点. */- (void)closePath; 7.删除 UIBezierPath 对象中的所有点, 效果也就等同于删除了所有子路经1234567- (void)removeAllPoints;将指定 UIBezierPath 中的内容添加到当前 UIBezierPath 对象中/** * 该方法将会在当前 UIBezierPath 对象的路径中追加 * 指定的 UIBezierPath 对象中的内容. */- (void)appendPath:(UIBezierPath *)bezierPath; 8.UIBezierPath 中的 CGPath 对象12345678/** * 获取这个属性, 你将会获得一个不可变的 CGPathRef 对象, * 他可以传入 CoreGraphics 提供的函数中 * 你可以是用 CoreGraphics 框架提供的方法创建一个路径, * 并给这个属性赋值, 当时设置了一个新的路径后, * 这个将会对你给出的路径对象进行 Copy 操作 */@property(nonatomic) CGPathRef CGPath; 9.绘图路径中的当前点12345/** * 该属性的值, 将会是下一条绘制的直线或曲线的起始点. * 如果当前路径为空, 那么该属性的值将会是 CGPointZero */@property(nonatomic, readonly) CGPoint currentPoint; 五、绘制路径 1.填充路径1234567/** * 该方法当前的填充颜色 和 绘图属性对路径的封闭区域进行填充. * 如果当前路径是一条开放路径, 该方法将会隐式的将路径进行关闭后进行填充 * 该方法在进行填充操作之前, 会自动保存当前绘图的状态, 所以我们不需要 * 自己手动的去保存绘图状态了. */- (void)fill; 2.使用混合模式进行填充123456789101112131415161718/** * 该方法当前的填充颜色 和 绘图属性 (外加指定的混合模式 和 透明度) * 对路径的封闭区域进行填充. 如果当前路径是一条开放路径, 该方法将 * 会隐式的将路径进行关闭后进行填充 * 该方法在进行填充操作之前, 会自动保存当前绘图的状态, 所以我们不需要 * 自己手动的去保存绘图状态了. * * @param blendMode: 混合模式决定了如何和已经存在的被渲染过的内容进行合成 * @param alpha: 填充路径时的透明度 */- (void)fillWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha; ``` #### 3.绘制路径``` Objc- (void)stroke; 4.使用混合模式进行填充123456/** * @param blendMode: 混合模式决定了如何和已经存在的被渲染过的内容进行合成 * @param alpha: 填充路径时的透明度 */- (void)strokeWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha; 5.剪切路径123456789101112131415/** * 该方法将会修改当前绘图上下文的可视区域. * 当调用这个方法之后, 会导致接下来所有的渲染 * 操作, 只会在剪切下来的区域内进行, 区域外的 * 内容将不会被渲染. * 如果你希望执行接下来的绘图时, 删除剪切区域, * 那么你必须在调用该方法前, 先使用 CGContextSaveGState 方法 * 保存当前的绘图状态, 当你不再需要这个剪切区域 * 的时候, 你只需要使用 CGContextRestoreGState 方法 * 来恢复之前保存的绘图状态就可以了. * @param blendMode: 混合模式决定了如何和 * 已经存在的被渲染过的内容进行合成 * @param alpha: 填充路径时的透明度 */- (void)addClip; 六、Hit Detection1.是否包含某个点123456789101112/** * 该方法返回一个布尔值, 当曲线的覆盖区域包含 * 指定的点(内部点)， 则返回 YES, 否则返回 NO. * Note: 如果当前的路径是一个开放的路径, 那么 * 就算指定点在路径覆盖范围内, 该方法仍然会 * 返回 NO, 所以如果你想判断一个点是否在一个 * 开放路径的范围内时, 你需要先Copy一份路径, * 并调用 -(void)closePath; 将路径封闭, 然后 * 再调用此方法来判断指定点是否是内部点. * @param point: 指定点. */- (BOOL) containsPoint:(CGPoint)point; 2.路径是否为空123456/** * 检测当前路径是否绘制过直线或曲线. * Note: 记住, 就算你仅仅调用了 moveToPoint 方法 * 那么当前路径也被看做不为空. */@property (readonly, getter=isEmpty) BOOL empty; 3.路径覆盖的矩形区域123456/** * 该属性描述的是一个能够完全包含路径中所有点 * 的一个最小的矩形区域. 该区域包含二次贝塞尔 * 曲线和三次贝塞尔曲线的控制点. */@property (nonatomic, readonly) CGRect bounds; 4.Apply Transform12345/** * 该方法将会直接对路径中的所有点进行指定的放射 * 变换操作. */- (void)applyTransform:(CGAffineTransform)transform;]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>UIBezierPath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发NSString详解]]></title>
    <url>%2F2018%2F06%2F13%2FiOS%E5%BC%80%E5%8F%91NSString%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[一、前言NSString 是Foundation框架下的一个处理字符串的类，也是我们平常开发过程中使用的比较多的类。 二、详解1. 属性@property (readonly) NSUInteger length; length 文本长度，只读。 2.字符串的获取1234567891011121314151617/* 为了避免像表情符号这样的字符序列被破坏，你可以这么做: [str substringFromIndex:[str rangeOfComposedCharacterSequenceAtIndex:index].location] [str substringToIndex:NSMaxRange([str rangeOfComposedCharacterSequenceAtIndex:index])] [str substringWithRange:[str rangeOfComposedCharacterSequencesForRange:range]*///截取指定位置之后的字符串- (NSString *)substringFromIndex:(NSUInteger)from;//从0下标开始截取到指定位置的字符串 - (NSString *)substringToIndex:(NSUInteger)to;//截取指定范围的字符串 - (NSString *)substringWithRange:(NSRange)range; //截取字符串指定范围的字符 - (void)getCharacters:(unichar *)buffer range:(NSRange)range; 3.字符串的比较3.1用NSComparisonResult作为比较返回结果的方法：12345678910111213141516/* 在compare:方法中，range参数指定要在比较中使用的接收者的子例程，而不是整个。范围不应用于搜索字符串。例如，[@“AB”compare:@“ABC”选项:0 range:NSMakeRange(0,1)]将“A”与“ABC”进行比较，而不是“A”与“A”，并返回nsordered升序。指定超出接收方界限的范围是错误的，可能会引发异常。*/- (NSComparisonResult)compare:(NSString *)string;- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)rangeOfReceiverToCompare;- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)rangeOfReceiverToCompare locale:(nullable id)locale; // locale arg used to be a dictionary pre-Leopard. We now accept NSLocale. Assumes the current locale if non-nil and non-NSLocale. nil continues to mean canonical compare, which doesn't depend on user's locale choice.- (NSComparisonResult)caseInsensitiveCompare:(NSString *)string;- (NSComparisonResult)localizedCompare:(NSString *)string;- (NSComparisonResult)localizedCaseInsensitiveCompare:(NSString *)string;/* localizedStandardCompare:，在10.6中添加，当文件名或其他字符串出现在列表和表中时，应该使用它，在那里类似查找器的排序是合适的。这个方法的确切行为可以在以后的版本中进行调整，并且在不同的本地化下会有所不同，因此客户机不应该依赖于字符串的精确排序顺序。*/- (NSComparisonResult)localizedStandardCompare:(NSString *)string API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)); 返回的结果NScomparisonResult: 12345typedef NS_ENUM(NSInteger, NSComparisonResult) &#123;NSOrderedAscending = -1L, // 递增NSOrderedSame, // 相等NSOrderedDescending // 递减&#125;; 参数类型 NSStringCompareOptions： NSCaseInsensitiveSearch 不区分大小写比较NSLiteralSearch 区分大小写比较NSBackwardsSearch 从字符串末尾开始搜索NSAnchoredSearch 搜索限制范围的字符串NSNumericSearch 按照字符串里的数字为依据，算出顺序NSDiacriticInsensitiveSearch 忽略 “-“ 符号的比较NSWidthInsensitiveSearch 忽略字符串的长度，比较出结果NSForcedOrderingSearch 忽略不区分大小写比较的选项NSRegularExpressionSearch 只能应用于 rangeOfString:…, stringByReplacingOccurrencesOfString:…和 replaceOccurrencesOfString:…方法 比较原理: 如果没有调用option的方法，比较是从两个字符串的第一个字母开始一一对比，相同则比较下一个，不同则返回结果为升序或者降序，两个比较字符串建议长度一致，不一致也可以比较，比如： @”agc” compare @” ab” //返回降序， @”abc” compare @”gd” //比较第一个字母之后就返回升序 参数range； 是决定前一个比较对象所需比较的范围。 3.2使用isEqualToString比较是否相等-(BOOL)isEqualToString:(NSString *)aString; 4.字符串检索1234567891011121314151617181920212223242526272829303132333435363738//////////搜索基本////////// //1.是否包含前缀(以str开头) - (BOOL)hasPrefix:(NSString *)str; //2.是否包含后缀(以str结尾) - (BOOL)hasSuffix:(NSString *)str; //3.获取公共前缀 - (NSString *)commonPrefixWithString:(NSString *)str options:(NSStringCompareOptions)mask; //4.是否包含字符串 - (BOOL)containsString:(NSString *)str; //5.本地化是否包含字符串(不区分大小写) - (BOOL)localizedCaseInsensitiveContainsString:(NSString *)str; //6.本地化是否包含字符串(标准) - (BOOL)localizedStandardContainsString:(NSString *)str; //7.本地化搜索字符串范围(标准) - (NSRange)localizedStandardRangeOfString:(NSString *)str; //////////搜索字符串////////// //8.搜索(指定字符串) - (NSRange)rangeOfString:(NSString *)searchString; //9.搜索(指定字符串,条件) - (NSRange)rangeOfString:(NSString *)searchString options:(NSStringCompareOptions)mask; //10.搜索(指定字符串,条件,范围) - (NSRange)rangeOfString:(NSString *)searchString options:(NSStringCompareOptions)mask range:(NSRange)searchRange; //11.搜索(指定字符串,条件,范围,本地化) - (NSRange)rangeOfString:(NSString *)searchString options:(NSStringCompareOptions)mask range:(NSRange)searchRange locale:(nullable NSLocale *)locale; //////////搜索字符集合////////// //12.搜索(指定字符集合) - (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)searchSet; //13.搜索(指定字符集合,条件) - (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)searchSet options:(NSStringCompareOptions)mask; //14.搜索(指定字符集合,条件,范围) - (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)searchSet options:(NSStringCompareOptions)mask range:(NSRange)searchRange; //15.用字符串的字符编码指定索引查找位置 - (NSRange)rangeOfComposedCharacterSequenceAtIndex:(NSUInteger)index; //16.用字符串的字符编码指定区域段查找位置 - (NSRange)rangeOfComposedCharacterSequencesForRange:(NSRange)range; 5.字符串拼接123456789// 后面直接拼接字符串- (NSString *)stringByAppendingString:(NSString *)aString; // 后面可以直接拼接字符串，也可拼接字符串参数- (NSString *)stringByAppendingFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1,2); // 添加路径- (NSString *)stringByAppendingPathComponent:(NSString *)str; 注意：stringByAppendingString 与 stringByAppendingFormat的与别 6.字符串可以转化为基本数据12345678910/* 面的便利方法都跳过了初始空格字符(whitespaceSet)，忽略了尾随字符。他们不是识别地区。NSScanner或NSNumberFormatter可以用于更强大和本地感知的数字解析。*/@property (readonly) double doubleValue;@property (readonly) float floatValue;@property (readonly) int intValue;@property (readonly) NSInteger integerValue API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));@property (readonly) long long longLongValue API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));// 跳过初始的空格字符(白色的)，或者是可选的-/+符号，后跟0。当遇到“Y”、“Y”、“T”、“T”或数字1-9时返回YES。它忽略任何尾字符。@property (readonly) BOOL boolValue API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); 注意：这里需要提示一下，如果字符串内全是数字，则会全部转化（如果有小数点，转为float和double类型会全转，其他形式只取整数，），如果全是非数字，或者没有以数字开头，怎转化值为0，比如：@”dgtgwge566” //0 如果开头以数字开头，开始会提取到开头几个数字的，后面的提取不了，如：@”456dkhgeo90” //456 7.字符大小写转化123456789101112131415NSString *string = @&quot;string&quot;; NSLog(@&quot;大写: %@&quot;, string.uppercaseString); NSLog(@&quot;小写: %@&quot;, string.lowercaseString); NSLog(@&quot;首字母大写: %@&quot;, string.capitalizedString); //输出: 大写: STRING //输出: 小写: string //输出: 首字母大写: String //本地化(大写) - (NSString *)uppercaseStringWithLocale:(nullable NSLocale *)locale; //本地化(小写) - (NSString *)lowercaseStringWithLocale:(nullable NSLocale *)locale; //本地化(首字母大写) - (NSString *)capitalizedStringWithLocale:(nullable NSLocale *)locale; 8.字符串分行分段1234567891011121314151617181920212223242526272829//分行 //1.指定范围,分行取字符串 - (void)getLineStart:(nullable NSUInteger *)startPtr end:(nullable NSUInteger *)lineEndPtr contentsEnd:(nullable NSUInteger *)contentsEndPtr forRange:(NSRange)range; //2.获取指定范围该行的范围 - (NSRange)lineRangeForRange:(NSRange)range; //分段//3.指定范围,分段取字符串 - (void)getParagraphStart:(nullable NSUInteger *)startPtr end:(nullable NSUInteger *)parEndPtr contentsEnd:(nullable NSUInteger *)contentsEndPtr forRange:(NSRange)range; //4.获取指定范围该段落的范围 - (NSRange)paragraphRangeForRange:(NSRange)range; //字符串分行,分段/ NSString *string = @"123 456\nABC,DEF\nabc.def"; //获取该行的范围(指定范围) NSRange range1 = [string lineRangeForRange:NSMakeRange(0, 10)]; NSLog(@"%ld 行长度: %ld", range1.location, range1.length); //输出: 0 行长度: 16 //获取该段落范围(指定范围) NSRange range2 = [string paragraphRangeForRange:NSMakeRange(0, 3)]; NSLog(@"%ld 段落长度: %ld", range2.location, range2.length); //输出: 0 段落长度: 8 9.字符串列举条件NSStringEnumerationOptions NSStringEnumerationByLines 按行NSStringEnumerationByParagraphs 按段落NSStringEnumerationByComposedCharacterSequences 按字符顺序NSStringEnumerationByWords 按单词,字NSStringEnumerationBySentences 按句子NSStringEnumerationReverse 反向遍历NSStringEnumerationSubstringNotRequired 不需要子字符串NSStringEnumerationLocalized 本地化 10.字符串编码与转换12345678910111213141516171819202122232425//1.选择编码,是否允许有损编码【重要】 - (nullable NSData *)dataUsingEncoding:(NSStringEncoding)encoding allowLossyConversion:(BOOL)lossy; //2.选择编码 - (nullable NSData *)dataUsingEncoding:(NSStringEncoding)encoding; //3.判断是否可以无损编码 - (BOOL)canBeConvertedToEncoding:(NSStringEncoding)encoding; //4.C字符编码转换 - (nullable __strong const charchar *)cStringUsingEncoding:(NSStringEncoding)encoding; //5.判读C字符转化是否可以成功 - (BOOL)getCString:(charchar *)buffer maxLength:(NSUInteger)maxBufferCount encoding:(NSStringEncoding)encoding; //6.指定缓存区转换 - (BOOL)getBytes:(nullable voidvoid *)buffer maxLength:(NSUInteger)maxBufferCount usedLength:(nullable NSUInteger *)usedBufferCount encoding:(NSStringEncoding)encoding options:(NSStringEncodingConversionOptions)options range:(NSRange)range remainingRange:(nullable NSRangePointer)leftover; //7.对字符串进行编码时所需的最大字节数 - (NSUInteger)maximumLengthOfBytesUsingEncoding:(NSStringEncoding)enc; //8.对字符串进行编码时所需的字节数 - (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc; //9.可用字符串编码 + (const NSStringEncoding *)availableStringEncodings; //10.本地化编码名称 + (NSString *)localizedNameOfStringEncoding:(NSStringEncoding)encoding; //11.默认C字符串编码 + (NSStringEncoding)defaultCStringEncoding; 11.字符串分割NSCharacterSet集合 controlCharacterSet 控制符whitespaceCharacterSet 空格符whitespaceAndNewlineCharacterSet 空格换行符decimalDigitCharacterSet 小数letterCharacterSet 文字lowercaseLetterCharacterSet 小写字母uppercaseLetterCharacterSet 大写字母nonBaseCharacterSet 非基础alphanumericCharacterSet 数字字母decomposableCharacterSet 可分解illegalCharacterSet 非法punctuationCharacterSet 标点capitalizedLetterCharacterSet 大写symbolCharacterSet 符号newlineCharacterSet 换行符 123456789101112//字符串分割NSString *string = @"A_B_c_D_E_F"; //分割(指定字符串) NSArray *resultArr1 = [string componentsSeparatedByString:@"_"]; NSLog(@"%@", resultArr1); //输出: (A, B, c, D, E, F) //分割(指定字符集合) NSArray *resultArr2 = [string componentsSeparatedByCharactersInSet:[NSCharacterSet lowercaseLetterCharacterSet]]; NSLog(@"%@", resultArr2); //输出: ("A_B_" , "_D_E_F") 12.字符串操作（修剪，替换，折叠，填充）12345678910111213141516171819202122232425262728293031323334353637NSString *string = @"3EWRs a;af"; //////////修剪////////// NSString *result1 = [string stringByTrimmingCharactersInSet:[NSCharacterSet lowercaseLetterCharacterSet]]; NSLog(@"%@", result1); //输出: 3EWRs a; //////////填充////////// NSString *result2 = [string stringByPaddingToLength:20 withString:@"填充" startingAtIndex:1]; NSLog(@"%@", result2); //输出: 3EWRs a;af充填充填充填充填充填 //////////折叠////////// NSString *result3 = [string stringByFoldingWithOptions:NSNumericSearch locale:[NSLocale systemLocale]]; NSLog(@"%@", result3); //输出: 3EWRs a;af //////////替换////////// //替换(指定字符串) NSString *result4 = [string stringByReplacingOccurrencesOfString:@" " withString:@"替换"]; NSLog(@"%@", result4); //输出: 3EWRs替换a;af //替换(指定字符串,条件,范围) NSString *result5 = [string stringByReplacingOccurrencesOfString:@"a" withString:@"替换" options:NSRegularExpressionSearch range:NSMakeRange(0, string.length - 2)]; NSLog(@"%@", result5); //输出: 3EWRs 替换;af //替换(指定范围) NSString *result6 = [string stringByReplacingCharactersInRange:NSMakeRange(0, string.length) withString:@"替换"]; NSLog(@"%@", result6); //输出: 替换 13.字符串写入123456//字符串写入 //写入到指定路径,编码的文件中 [string writeToFile:@"/Users/Desktop/LuisX.txt" atomically:YES encoding:NSUTF8StringEncoding error:nil]; //写入到指定URL,编码的文件中 [string writeToURL:[NSURL URLWithString:@"file://LuisX.text"] atomically:YES encoding:NSUTF8StringEncoding error:nil]; 14.NSMutableString的介绍NSMutableString是NSString的字类，可以动态的扩展字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//1.初始化容量为Capacity大小的字符串 (需要手动释放内存) NSMutableString *mutableStr1 = [[NSMutableString alloc] initWithCapacity:20]; //2.初始化容量为Capacity大小的字符串 (不需要手动释放内存) NSMutableString *mutableStr2 = [NSMutableString stringWithCapacity:20]; NSMutableString *str = [NSMutableString stringWithString:@"string"]; //////////插入////////// [str insertString:@"123" atIndex:2]; NSLog(@"%@", str); //输出: st123ring //////////删除////////// [str deleteCharactersInRange:NSMakeRange(2, 2)]; NSLog(@"%@", str); //输出: st3ring //////////拼接////////// [str appendString:@"456"]; NSLog(@"%@", str); //输出: st3ring456 //////////格式化拼接////////// [str appendFormat:@"7 89"]; NSLog(@"%@", str); //输出: st3ring4567 89 //////////设置新字符串////////// [str setString:@"string"]; NSLog(@"%@", str); //输出: string //////////字符串替换////////// //1.指定范围替换 [str1 replaceCharactersInRange:NSMakeRange(2, 2) withString:@"123"]; NSLog(@"%@", str1); //输出: st123ng //2.指定字符串,条件,范围替换 [str1 replaceOccurrencesOfString:@"123" withString:@"--" options:NSRegularExpressionSearch range:NSMakeRange(0, str1.length)]; NSLog(@"%@", str1); //输出: st--ng]]></content>
      <categories>
        <category>iOS 开发</category>
        <category>基础知识</category>
        <category>NSString</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS开发本地推送UILocalNotification]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%E5%BC%80%E5%8F%91%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81UILocalNotification.html</url>
    <content type="text"><![CDATA[一、简介UILocalNotification 是通过设置时间来触发本地推送通知的通知方式,不需要连网就能实现推送功能。本地通知触发后，会显示在通知中心中，并根据配置，显示横幅和播放声音，和App的icon上显示通知的条数。 UILocalNotification 适用于闹钟、提醒、备忘录等功能。缺点是UILocalNotification可以设置的最大提醒条数为64条。超过64条的通知将系统会自动忽略。 二、使用 创建UILocalNotification实例 设置相关的属性，如：时间、时间间隔、是否重复、推送方式、推送铃声、推送标题、推送简介、推送的参数等等。 注册添加本地通知 Appdelegate.m 接收注册通知 触发通知的业务跳转处理 取消通知 三、属性介绍属性介绍 123456789101112131415161718192021222324252627282930313233@property(nullable, nonatomic,copy) NSDate *fireDate;设置通知的提醒时间@property(nullable, nonatomic,copy) NSTimeZone *timeZone;设置时间的时区@property(nonatomic) NSCalendarUnit repeatInterval; 设置重复间隔的单位，（天、周、月、年，0表示不重复） @property(nullable, nonatomic,copy) NSCalendar *repeatCalendar;重复激发通知所使用的日历单位需要参考的日历，如果不设置的话，系统默认的日历将被作为参考日历。// NSString *const NSGregorianCalendar; 公历// NSString * const NSChineseCalendar; 农历@property(nullable, nonatomic,copy) CLRegion *region;设置触发通知的地理区域@property(nonatomic,assign) BOOL regionTriggersOnce;是否穿越通知地理区域时再次触发通知@property(nullable, nonatomic,copy) NSString *alertBody; 通知提示中显示的消息，内容。@property(nonatomic) BOOL hasAction; 控制该通知是否显示或隐藏警报动作。@property(nullable, nonatomic,copy) NSString *alertAction; 设置通知动作按钮的标题。@property(nullable, nonatomic,copy) NSString *alertLaunchImage;设置通知动作按钮的图像。@property(nullable, nonatomic,copy) NSString *alertTitle; 设置通知原因的简短描述。@property(nullable, nonatomic,copy) NSString *soundName;通知提示音，可以自定义@property(nonatomic) NSInteger applicationIconBadgeNumber;应用程序icon上的提醒个数@property(nullable, nonatomic,copy) NSDictionary *userInfo; 设置应用自定义信息@property (nullable, nonatomic, copy) NSString *category ;设置通知的分类标示 NSCalendarUnit repeatInterval 循环枚举 123456789101112131415161718typedef NS_OPTIONS(NSUInteger, NSCalendarUnit) &#123; NSCalendarUnitEra = kCFCalendarUnitEra,//一个年代、一个世纪循环一次。 NSCalendarUnitYear = kCFCalendarUnitYear,//每年循环一次 NSCalendarUnitMonth = kCFCalendarUnitMonth,//每月循环一次 NSCalendarUnitDay = kCFCalendarUnitDay,//每天循环一次 NSCalendarUnitHour = kCFCalendarUnitHour,//每小时循环一次 NSCalendarUnitMinute = kCFCalendarUnitMinute,//每分钟循环一次 NSCalendarUnitSecond = kCFCalendarUnitSecond,//每秒循环一次 NSCalendarUnitWeekday = kCFCalendarUnitWeekday,//平常日、工作日循环，但是周末也会。(*而不是每周循环，具体和NSCalendarUnitDay有什么区别，暂时没有测试出来，如果哪位知道请告知，感谢) NSCalendarUnitWeekdayOrdinal = kCFCalendarUnitWeekdayOrdinal, NSCalendarUnitQuarter NS_ENUM_AVAILABLE(10_6, 4_0) = kCFCalendarUnitQuarter,//一个季度循环一次 NSCalendarUnitWeekOfMonth NS_ENUM_AVAILABLE(10_7, 5_0) = kCFCalendarUnitWeekOfMonth,//每个月的第几周 NSCalendarUnitWeekOfYear NS_ENUM_AVAILABLE(10_7, 5_0) = kCFCalendarUnitWeekOfYear,//每年的第几周 NSCalendarUnitYearForWeekOfYear NS_ENUM_AVAILABLE(10_7, 5_0) = kCFCalendarUnitYearForWeekOfYear, NSCalendarUnitNanosecond NS_ENUM_AVAILABLE(10_7, 5_0) = (1 &lt;&lt; 15), NSCalendarUnitCalendar NS_ENUM_AVAILABLE(10_7, 4_0) = (1 &lt;&lt; 20), NSCalendarUnitTimeZone NS_ENUM_AVAILABLE(10_7, 4_0) = (1 &lt;&lt; 21),&#125; 四、代码实现1.在 Appdelegate 的application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 方法里面添加注册接收方法123if ([UIApplication instancesRespondToSelector:@selector(registerUserNotificationSettings:)])&#123; [[UIApplication sharedApplication] registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound categories:nil]]; &#125; 2.在需要添加通知的页面添加注册通知，或者封装一层调用，可以根据通知需要传入需要的参数，控制通知的注册添加或取消删除123456789101112131415161718192021222324252627282930313233343536373839#pragma mark - 注册本地通知方法// 注册本地通知-(void)registerLocalNotification:(NSString *)timeStr title:(NSString *)title desc:(NSString *)desc soundName:(NSString *)soundName remindType:(NSString *)remindType tagStr:(NSString *)tagStr remindId:(NSString *)remindId&#123; UILocalNotification * notification = [[UILocalNotification alloc] init]; NSDateFormatter * curndf = [[NSDateFormatter alloc] init]; [curndf setDateFormat:@"yyyy-MM-dd"]; NSString * curDate = [curndf stringFromDate:[NSDate date]]; // 时间加上秒 NSString * finalTimeStr = [NSString stringWithFormat:@"%@ %@:00",curDate,timeStr]; NSDateFormatter * finalTimeFormatter = [[NSDateFormatter alloc] init]; [finalTimeFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"]; NSDate * finalDate = [finalTimeFormatter dateFromString:finalTimeStr]; // 设置什么时间点(具体的时间)触发本地通知. notification.fireDate = finalDate; // 设置时区,default手机时区 notification.timeZone = [NSTimeZone defaultTimeZone]; // 设置重复间隔, 按天跑 notification.repeatInterval = kCFCalendarUnitDay; // 弹出的通知标题 notification.alertTitle = title; // 弹出的通知内容 notification.alertBody = desc; // Badge个数 notification.applicationIconBadgeNumber = notification.applicationIconBadgeNumber+1; // 通知被触发时播放声音 notification.soundName = UILocalNotificationDefaultSoundName; // 通知触发时播放的声音 notification.soundName = [NSString stringWithFormat:@"%@.mp3",soundName]; // 通知的参数 NSDictionary * userDict = @&#123;@"nTimeStr":timeStr,@"remindType":remindType,@"tag":tagStr,@"remindId":remindId&#125;; notification.userInfo = userDict; // 添加推送到UIApplication [[UIApplication sharedApplication] scheduleLocalNotification:notification]; &#125; 3.取消通知3.1 取消全部的通知12// 取消全部的通知[[UIApplication sharedApplication] cancelAllLocalNotifications]; 3.2 取消对应 ID 的通知123456789101112131415161718192021222324252627282930// IOS最多允许最近本地通知数量是64个，超过限制的本地通知将被忽略。#pragma mark -- 删除通知-(void)cancelLocalNotificationWithKey:(NSString *)key remindType:(NSString *)remindType&#123; // 获取所有本地通知数组 NSArray *localNotifications = [UIApplication sharedApplication].scheduledLocalNotifications; NSLog(@"\n本地通知总数%@ \n 一共: %ld 个",localNotifications ,[localNotifications count]); // 循环遍历所有的通知 for (UILocalNotification *notification in localNotifications) &#123; // 取出每个通知的通知数据 NSDictionary *userInfo = notification.userInfo; if (userInfo) &#123; // 根据设置通知参数时指定的key来获取通知参数 NSString *info = userInfo[@"nTimeStr"]; NSString *type = userInfo[@"remindType"]; // 如果找到需要取消的通知，则取消 if (info != nil) &#123; if ([info isEqualToString:key] &amp;&amp; [type isEqualToString:remindType]) &#123; [[UIApplication sharedApplication] cancelLocalNotification:notification]; NSLog(@"type:%@,key:%@,本地通知取消成功!!!",type,key); break; &#125; &#125; &#125; &#125;&#125; 4.接收通知4.1 前台接收通知，调用系统application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification方法 ，在这个方法里面做业务处理1234567891011121314151617181920212223242526272829// 程序没有被杀死时,接收到本地通知时调用--点击通知时会执行这个方法,如果程序被杀死时,这个方法不再走,在application: didFinishLaunchingWithOptions:方法中获取- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification&#123; NSLog(@"notification.userInfo = %@",notification.userInfo); // 获取通知详情 NSDictionary *dict = notification.userInfo; if (dict) &#123; // 根据通知的类型参数做出对应的跳转 if ([dict[@"remindType"] isEqualToString:CPTakeMediciTableName]) &#123; CPMedicineRemindDetailViewController *medicine = [[CPMedicineRemindDetailViewController alloc]init]; medicine.remindId = dict[@"remindId"]; medicine.timeStr = dict[@"nTimeStr"]; medicine.type = CPMedicinePushNow; [[self currentViewController].navigationController pushViewController:medicine animated:YES]; &#125;else if([dict[@"remindType"] isEqualToString:CPMeasureTableName])&#123; CPMeasureRemindDetailViewController *measure = [[CPMeasureRemindDetailViewController alloc]init]; measure.tagStr = dict[@"tag"]; measure.timeStr = dict[@"nTimeStr"]; measure.type = CPMeasurePushNow; [[self currentViewController] presentViewController:measure animated:YES completion:nil]; &#125; &#125;&#125; 4.2 应用在后台被杀死了调用pplication:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法，在这个方法里面做业务处理在pplication:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法中添加下面的代码 12345678910111213141516171819202122232425if (launchOptions != nil) &#123; UILocalNotification *localNotification = launchOptions[UIApplicationLaunchOptionsLocalNotificationKey]; if (localNotification != nil) &#123; // 程序完全退出状态下，点击推送通知后的业务处理 // 根据通知的参数做不同的跳转 NSDictionary *dict = localNotification.userInfo; if (dict) &#123; if ([dict[@"remindType"] isEqualToString:CPTakeMediciTableName]) &#123; CPMedicineRemindDetailViewController *medicine = [[CPMedicineRemindDetailViewController alloc]init]; medicine.remindId = dict[@"remindId"]; medicine.timeStr = dict[@"nTimeStr"]; CPNavigationController *nav = [[CPNavigationController alloc]initWithRootViewController:medicine]; [AppDelegate sharedInstance].window.rootViewController = nav; &#125;else if([dict[@"remindType"] isEqualToString:CPMeasureTableName])&#123; CPMeasureRemindDetailViewController *measure = [[CPMeasureRemindDetailViewController alloc]init]; measure.tagStr = dict[@"tag"]; measure.timeStr = dict[@"nTimeStr"]; [AppDelegate sharedInstance].window.rootViewController = measure; &#125; &#125; &#125; &#125; 五、其他设置实现发送基于位置的通知方法（iOS8+）： 1、无需编码，如果设备用户打开了定位，系统会给用户当前的位置来决定是否要给用户发送通知； 2、需要获取用户定位权限CLLocation； 3、精准度一般般。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>本地推送</tag>
        <tag>UILocalNotification</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[001- 初识汇编]]></title>
    <url>%2F2018%2F04%2F20%2F001-%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96.html</url>
    <content type="text"><![CDATA[我们在学习逆向开发之前,我们要了解一个基本的逆向原理.首先我们是逆向iOS系统上面的APP.那么我们知道,一个APP安装在手机上面的可执行文件本质上是二进制文件.因为iPhone手机本质上执行的指令是二进制.是由手机上的CPU执行的.所以逆向开发是建立在分析二进制上面.所以今天我们接下来的课程从非常基础的东西开始讲解. 汇编语言的发展机器语言 由0和1组成的机器指令. 加：0100 0000 减：0100 1000 乘：1111 0111 1110 0000 除：1111 0111 1111 0000 汇编语言(assembly language) 使用助记符代替机器语言如: 加：INC EAX 通过编译器 0100 0000 减：DEC EAX 通过编译器 0100 1000 乘：MUL EAX 通过编译器 1111 0111 1110 0000 除：DIV EAX 通过编译器 1111 0111 1111 0000 ###高级语言（High-level programming language) C\C++\Java\OC\Swift,更加接近人类的自然语言比如C语言: 加：A+B 通过编译器 0100 0000 减：A-B 通过编译器 0100 1000 乘：A*B 通过编译器 1111 0111 1110 0000 除：A/B 通过编译器 1111 0111 1111 0000 我们的代码在终端设备上是这样的过程: 汇编语言与机器语言一一对应，每一条机器指令都有与之对应的汇编指令 汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言 高级语言可以通过编译得到汇编语言 \ 机器语言，但汇编语言\机器语言几乎不可能还原成高级语言 汇编语言的特点 可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能 能够不受编译器的限制，对生成的二进制代码进行完全的控制 目标代码简短，占用内存少，执行速度快 汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性 知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护 不区分大小写，比如mov和MOV是一样的 汇编的用途(哥么我学了能干啥?) 编写驱动程序、操作系统（比如Linux内核的某些关键部分） 对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编） 软件安全 病毒分析与防治 逆向\加壳\脱壳\破解\外挂\免杀\加密解密\漏洞\黑客 理解整个计算机系统的最佳起点和最有效途径 为编写高效代码打下基础 弄清代码的本质 函数的本质究竟是什么? ++a + ++a + ++a 底层如何执行的? 编译器到底帮我们干了什么? DEBUG模式和RELEASE模式有什么关键的地方被我们忽略 …… 最后来句装13的话 越底层越单纯!真正的程序员都需要了解的一门非常重要的语言,汇编! 汇编语言的种类 目前讨论比较多的汇编语言有 8086汇编（8086处理器是16bit的CPU） Win32汇编 Win64汇编 ARM汇编（嵌入式、Mac、iOS） …… 我们iPhone里面用到的是ARM汇编,但是不同的设备也有差异.因CPU的架构不同. 架构 设备 armv6 iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch armv7 iPhone3GS, iPhone4, iPhone4S,iPad, iPad2, iPad3(The New iPad), iPad mini, iPod Touch 3G, iPod Touch4 armv7s iPhone5, iPhone5C, iPad4(iPad with Retina Display) arm64 iPhone5S 以后 iPhoneX , iPad Air, iPad mini2以后 几个必要的常识 要想学好汇编,首先需要了解CPU等硬件结构 APP/程序的执行过程 硬件相关最为重要是CPU/内存 在汇编中,大部分指令都是和CPU与内存相关的 总线 每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互 总线：一根根导线的集合 总线的分类 地址总线 数据总线 控制总线 举个例子 地址总线 它的宽度决定了CPU的寻址能力 8086的地址总线宽度是_20_，所以寻址能力是_1M_（ 2^20 ） 数据总线 它的宽度决定了CPU的单次数据传送量，也就是数据传送速度 8086的数据总线宽度是_16_，所以单次最大传递2个字节的数据 控制总线 它的宽度决定了CPU对其他器件的控制能力、能有多少种控制 做个小练习 一个CPU 的寻址能力为8KB,那么它的地址总线的宽度为____ 8080,8088,80286,80386 的地址总线宽度分别为16根,20根,24根,32根.那么他们的寻址能力分别为多少____KB, ____MB,____MB,____GB? 8080,8088,8086,80286,80386 的数据总线宽度分别为8根,8根,16根,16根,32根.那么它们一次可以传输的数据为:____B,____B,____B,____B,____B, 从内存中读取1024字节的数据,8086至少要读____次,80386至少要读取____次. 解答: 8KB = 1024 * 8 = 2^10 + 2^3 ,所以地址总线的宽度为13 地址总线为16,所以 寻址能力为 2^16 = 2^10 * 2^6 = 64KB 地址总线为20,所以 寻址能力为 2^20 = 2^10 2^10 = 1024 1024 = 1MB; 地址总线为24,所以 寻址能力为 2^24 = 2^20 2^4 = 1MB 16 = 16MB; 地址总线为32,所以 寻址能力为 2^30 = 2^30 2^2 = 1GB 4 = 4GB; 答案 内存 内存地址空间的大小受CPU地址总线宽度的限制。8086的地址总线宽度为20，可以定位2^20个不同的内存单元（内存地址范围0x00000~0xFFFFF），所以8086的内存空间大小为1MB 0x00000~0x9FFFF：主存储器。可读可写 0xA0000~0xBFFFF：向显存中写入数据，这些数据会被显卡输出到显示器。可读可写 0xC0000~0xFFFFF：存储各种硬件\系统信息。只读 ##进制学习进制的障碍 很多人学不好进制，原因是总以十进制为依托去考虑其他进制，需要运算的时候也总是先转换成十进制，这种学习方法是错误的.我们为什么一定要转换十进制呢？仅仅是因为我们对十进制最熟悉，所以才转换.每一种进制都是完美的,想学好进制首先要忘掉十进制，也要忘掉进制间的转换！ ###进制的定义 八进制由8个符号组成:0 1 2 3 4 5 6 7 逢八进一 十进制由10个符号组成:0 1 2 3 4 5 6 7 8 9逢十进一 N进制就是由N个符号组成:逢N进一 #####做个练习 1 + 1 在____情况下等于 3 ? 12345678910111213............. 十进制由10个符号组成: 0 1 3 2 8 A B E S 7 逢十进一 如果这样定义十进制: 1 + 1 = 3!就对了! 这样的目的何在?传统我们定义的十进制和自定义的十进制不一样.那么这10个符号如果我们不告诉别人这个符号表,别人是没办法拿到我们的具体数据的!用于加密! 十进制由十个符号组成,逢十进一,符号是可以自定义的!! ###进制的运算 #####做个练习 八进制运算 2 + 3 = , 2 * 3 = ,4 + 5 = ,4 * 5 = . 277 + 333 = , 276 * 54 = , 237 - 54 = , 234 / 4 = . #####八进制加法表123456789101112 0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 1720 21 22 23 24 25 26 27...1+1 = 2 1+2 = 3 2+2 = 4 1+3 = 4 2+3 = 5 3+3 = 61+4 = 5 2+4 = 6 3+4 = 7 4+4 = 10 1+5 = 6 2+5 = 7 3+5 = 10 4+5 = 11 5+5 = 121+6 = 7 2+6 = 10 3+6 = 11 4+6 = 12 5+6 = 13 6+6 = 141+7 = 10 2+7 = 11 3+7 = 12 4+7 = 13 5+7 = 14 6+7 = 15 7+7 = 16 #####八进制乘法表123456780 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27...1*1 = 1 1*2 = 2 2*2 = 4 1*3 = 3 2*3 = 6 3*3 = 11 1*4 = 4 2*4 = 10 3*4 = 14 4*4 = 201*5 = 5 2*5 = 12 3*5 = 17 4*5 = 24 5*5 = 311*6 = 6 2*6 = 14 3*6 = 22 4*6 = 30 5*6 = 36 6*6 = 441*7 = 7 2*7 = 16 3*7 = 25 4*7 = 34 5*7 = 43 6*7 = 52 7*7 = 61 #####实战四则运算123 277 236 276 234+ 333 - 54 * 54 / 4-------- -------- -------- -------- ###二进制的简写形式12345 二进制: 1 0 1 1 1 0 1 1 1 1 0 0三个二进制一组: 101 110 111 100 八进制: 5 6 7 4四个二进制一组: 1011 1011 1100 十六进制: b b c 二进制：从0 写到 11110000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111这种二进制使用起来太麻烦，改成更简单一点的符号：0 1 2 3 4 5 6 7 8 9 A B C D E F 这就是十六进制了 ###数据的宽度数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。 1234567891011121314#import &lt;UIKit/UIKit.h&gt;#import "AppDelegate.h"int test()&#123; int cTemp = 0x1FFFFFFFF; return cTemp;&#125;int main(int argc, char * argv[]) &#123; printf("%x\n",test()); @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; ###计算机中常见的数据宽度 位(Bit): 1个位就是1个二进制位.0或者1 字节(Byte): 1个字节由8个Bit组成(8位).内存中的最小单元Byte. 字(Word): 1个字由2个字节组成(16位),这2个字节分别称为高字节和低字节. 双字(Doubleword): 1个双字由两个字组成(32位) 那么计算机存储数据它会分为有符号数和无符号数.那么关于这个看图就理解了! 12345无符号数,直接换算!有符号数:正数: 0 1 2 3 4 5 6 7 负数: F E D B C A 9 8 -1 -2 -3 -4 -5 -6 -7 -8 ###自定义进制符号 #####练习 现在有10进制数 10个符号分别是：2，9，1，7，6，5，4， 8，3 , A 逢10进1 那么： 123 + 234 = ____ 123456789101112十进制: 0 1 2 3 4 5 6 7 8 9自定义: 2 9 1 7 6 5 4 8 3 A 92 99 91 97 96 95 94 98 93 9A 12 19 11 17 16 15 14 18 13 1A 72 79 71 77 76 75 74 78 73 7A 62 69 61 67 66 65 64 68 63 6A 52 59 51 57 56 55 54 58 53 5A 42 49 41 47 46 45 44 48 43 4A 82 89 81 87 86 85 84 88 83 8A 32 39 31 37 36 35 34 38 33 3A 922 那么刚才通过10进制运算可以转化10进制然后查表!但是如果是其他进制.我们就不能转换,要直接学会查表 现在有9进制数 9个符号分别是：2，9，1，7，6，5，4， 8，3 逢9进1 那么： 123 + 234 = ____ 123456789101112十进制: 0 1 2 3 4 5 6 7 8 自定义: 2 9 1 7 6 5 4 8 3 92 99 91 97 96 95 94 98 93 12 19 11 17 16 15 14 18 13 72 79 71 77 76 75 74 78 73 62 69 61 67 66 65 64 68 63 52 59 51 57 56 55 54 58 53 42 49 41 47 46 45 44 48 43 82 89 81 87 86 85 84 88 83 32 39 31 37 36 35 34 38 33 922 寄存器内部部件之间由总线连接 对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制 不同的CPU，寄存器的个数、结构是不相同的 通用寄存器 ARM64拥有有31个64位的通用寄存器 x0 到 x30,这些寄存器通常用来存放一般性的数据，称为通用寄存器（有时也有特定用途） 那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位. 比如 w0 就是 x0的低32位! 通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算 假设内存中有块红色内存空间的值是3，现在想把它的值加1，并将结果存储到蓝色内存空间 CPU首先会将红色内存空间的值放到X0寄存器中：mov X0,红色内存空间 然后让X0寄存器与1相加：add X0,1 最后将值赋值给内存空间：mov 蓝色内存空间,X0 ###pc寄存器(program counter) 为指令指针寄存器，它指示了CPU当前要读取指令的地址 在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息 CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义 比如 1110 0000 0000 0011 0000 1000 1010 1010 可以当做数据 0xE003008AA 也可以当做指令 mov x0, x8 CPU根据什么将内存中的信息看做指令？ CPU将pc指向的内存单元的内容看做指令 如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过 bl指令 CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令 ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如 mov x0,#10、mov x1,#20 但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能 ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令 bl指令 – 练习现在有两段代码!假设程序先执行A,请写出指令执行顺序.最终寄存器x0的值是多少? 123456789101112_A: mov x0,#0xa0 mov x1,#0x00 add x1, x0, #0x14 mov x0,x1 bl _B mov x0,#0x0 ret_B: add x0, x0, #0x10 ret]]></content>
      <categories>
        <category>汇编</category>
        <category>安全攻防</category>
      </categories>
      <tags>
        <tag>安全攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习 纹理下(五)]]></title>
    <url>%2F2018%2F02%2F15%2FOpenGL%20%E7%BA%B9%E7%90%86%E4%B8%8B%EF%BC%88%E4%BA%94%EF%BC%89.html</url>
    <content type="text"><![CDATA[floorBatch⼏几何坐标计算 12345678910111213141516//Z表示深度，隧道的深度floorBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; floorBatch.MultiTexCoord2f(0, 0.0f, 0.0f); floorBatch.Vertex3f(-10.0f, -10.0f, z); floorBatch.MultiTexCoord2f(0, 1.0f, 0.0f); floorBatch.Vertex3f(10.0f, -10.0f, z); floorBatch.MultiTexCoord2f(0, 0.0f, 1.0f); floorBatch.Vertex3f(-10.0f, -10.0f, z - 10.0f); floorBatch.MultiTexCoord2f(0, 1.0f, 1.0f); floorBatch.Vertex3f(10.0f, -10.0f, z - 10.0f); &#125; floorBatch.End(); //几何坐标参考下图 ceilingBatch⼏几何坐标计算 12345678910111213ceilingBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; ceilingBatch.MultiTexCoord2f(0, 0.0f, 1.0f); ceilingBatch.Vertex3f(-10.0f, 10.0f, z - 10.0f); ceilingBatch.MultiTexCoord2f(0, 1.0f, 1.0f); ceilingBatch.Vertex3f(10.0f, 10.0f, z - 10.0f); ceilingBatch.MultiTexCoord2f(0, 0.0f, 0.0f); ceilingBatch.Vertex3f(-10.0f, 10.0f, z); ceilingBatch.MultiTexCoord2f(0, 1.0f, 0.0f); ceilingBatch.Vertex3f(10.0f, 10.0f, z); &#125; ceilingBatch.End(); leftWallBatch⼏几何坐标计算 12345678910111213leftWallBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; leftWallBatch.MultiTexCoord2f(0, 0.0f, 0.0f); leftWallBatch.Vertex3f(-10.0f, -10.0f, z); leftWallBatch.MultiTexCoord2f(0, 0.0f, 1.0f); leftWallBatch.Vertex3f(-10.0f, 10.0f, z); leftWallBatch.MultiTexCoord2f(0, 1.0f, 0.0f); leftWallBatch.Vertex3f(-10.0f, -10.0f, z - 10.0f); leftWallBatch.MultiTexCoord2f(0, 1.0f, 1.0f); leftWallBatch.Vertex3f(-10.0f, 10.0f, z - 10.0f);&#125; leftWallBatch.End(); rightWallBatch⼏几何坐标计算 12345678910111213ghtWallBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; rightWallBatch.MultiTexCoord2f(0, 0.0f, 0.0f); rightWallBatch.Vertex3f(10.0f, -10.0f, z); rightWallBatch.MultiTexCoord2f(0, 0.0f, 1.0f); rightWallBatch.Vertex3f(10.0f, 10.0f, z); rightWallBatch.MultiTexCoord2f(0, 1.0f, 0.0f); rightWallBatch.Vertex3f(10.0f, -10.0f, z - 10.0f); rightWallBatch.MultiTexCoord2f(0, 1.0f, 1.0f); rightWallBatch.Vertex3f(10.0f, 10.0f, z - 10.0f); &#125; rightWallBatch.End(); 五、 压缩纹理理通⽤用压缩纹理理格式 5.1 判断压缩 与 选择压缩⽅方式12345GLint comFlag;//判断纹理理是否被成功压缩 glGetTexLevelParameteriv(GL_TEXTURE_2D,0,GL_TEXTURE_COMPRESSED,&amp;comFlag);//根据选择的压缩纹理理格式，选择最快、最优、⾃自⾏行行选择的算法⽅方式选择压缩格式。 glHint(GL_TEXTURE_COMPRESSION_HINT,GL_FASTEST); glHint(GL_TEXTURE_COMPRESSION_HINT,GL_NICEST); glHint(GL_TEXTURE_COMPRESSION_HINT,GL_DONT_CARE); 5.2 加载压缩纹理理1234567891011121314151617181920void glCompressedTexImage1D(GLenum target,GLint level,GLenum internalFormat,GLsizei width,GLint border,GLsizei imageSize,void *data); void glCompressedTexImage2D(GLenum target,GLint level,GLenum internalFormat,GLsizei width,GLint heigth,GLint border,GLsizei imageSize,void *data); void glCompressedTexImage3D(GLenum target,GLint level,GLenum internalFormat,GLsizei width,GLsizei heigth,GLsizei depth,GLint border,GLsizei imageSize,void *data);target:`GL_TEXTURE_1D`、`GL_TEXTURE_2D`、`GL_TEXTURE_3D`。Level:指定所加载的mip贴图层次。⼀一般我们都把这个参数设置为0。 internalformat:每个纹理理单元中存储多少颜⾊色成分。 width、height、depth参数:指加载纹理理的宽度、⾼高度、深度。==注意!==这些值必须是2的整数次⽅方。(这是因为O旧版本上的遗留留下的⼀一个要求。当然现在已经可以⽀支持不不是2的整数次⽅方。但是开发者们还是习惯使⽤用以2的整数次⽅方去参数。)border参数:允许为纹理理贴图指定⼀一个边界宽度。 format、type、data参数:与我们在讲glDrawPixels 函数对于的参数相同 glGetTexLevelParameter函数提取的压缩纹理理格式 GL_EXT_texture_compression_s3tc压缩格式]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习 纹理上(五)]]></title>
    <url>%2F2018%2F02%2F11%2F15244707402194.html</url>
    <content type="text"><![CDATA[一.原始图像数据1.图像存储空间 = 图像 width 图像 height 每个像素的字节数例如:有一张 RGB 的图像(每个颜色通道8位),图像的宽度199个像素,每行需要多少存储空间? 199 * 3 = 597字节 二 认识函数2.1 函数123456789//改变像素存储⽅方式void glPixelStorei(GLenum pname,GLint param);//恢复像素存储⽅方式void glPixelStoref(GLenum pname,GLfloat param);//举例例://参数1:GL_UNPACK_ALIGNMENT 指定OpenGL 如何从数据缓存区中解包图像 数据//参数2:表示参数GL_UNPACK_ALIGNMENT 设置的值//GL_UNPACK_ALIGNMENT 指内存中每个像素⾏行行起点的排列列请求，允许设置为1 (byte排列列)、2(排列列为偶数byte的⾏行行)、4(字word排列列)、8(⾏行行从双字节 边界开始)glPixelStorei(GL_UNPACK_ALIGNMENT,1); 2.2 . 认识函数 从颜⾊色缓存区内容作为像素图直接读取1234567//参数1:x,矩形左下⻆角的窗⼝口坐标//参数2:y,矩形左下⻆角的窗⼝口坐标//参数3:width,矩形的宽，以像素为单位 //参数4:height,矩形的⾼高，以像素为单位//参数5:format,OpenGL 的像素格式，参考 表6-1 //参数6:type,解释参数pixels指向的数据，告诉OpenGL 使⽤用缓存区中的什什么 数据类型来存储颜⾊色分量量，像素数据的数据类型，参考 表6-2 //参数7:pixels,指向图形数据的指针void glReadPixels(GLint x,GLint y,GLSizei width,GLSizei height, GLenum format, GLenum type,const void * pixels); 2.3 . 认识函数 载⼊入纹理理12345678910111213141516* target:`GL_TEXTURE_1D`、`GL_TEXTURE_2D`、`GL_TEXTURE_3D`。* Level:指定所加载的mip贴图层次。⼀一般我们都把这个参数设置为0。* internalformat:每个纹理理单元中存储多少颜⾊色成分。* width、height、depth参数:指加载纹理理的宽度、⾼高度、深度。==注意!==这些值必须是 2的整数次⽅方。(这是因为OpenGL 旧版本上的遗留留下的⼀一个要求。当然现在已经可以⽀支持不不是 2的整数次⽅方。但是开发者们还是习惯使⽤用以2的整数次⽅方去设置这些参数。)* border参数:允许为纹理理贴图指定⼀一个边界宽度。* format、type、data参数:与我们在讲glDrawPixels 函数对于的参数相同void glTexImage1D(GLenum target,GLint level,GLint internalformat,GLsizei width,GLint border,GLenum format,GLenum type,void *data);void glTexImage2D(GLenum target,GLint level,GLint internalformat,GLsizei width,GLsizei height,GLint border,GLenum format,GLenum type,void * data);void glTexImage3D(GLenum target,GLint level,GLint internalformat,GLSizei width,GLsizei height,GLsizei depth,GLint border,GLenum format,GLenum type,void *data); 2.4 认识函数 使⽤用颜⾊色缓存区加载数据,形成新的纹理理使⽤用12345void glCopyTexImage1D(GLenum target,GLint level,GLenum internalformt,GLint x,GLint y,GLsizei width,GLint border); void glCopyTexImage2D(GLenum target,GLint level,GLenum internalformt,GLint x,GLint y,GLsizei width,GLsizei height,GLint border); x,y 在颜⾊色缓存区中指定了了开始读取纹理理数据的位置; 缓存区⾥里里的数据，是源缓存区通过glReadBuffer设置的。注意:不不存在glCopyTextImage3D ，因为我们⽆无法从2D 颜⾊色缓存区中获取体积 数据。 2.5 更新纹理12345678void glTexSubImage1D(GLenum target,GLint level,GLint xOffset,GLsizei width,GLenum format,GLenum type,const GLvoid *data);void glTexSubImage2D(GLenum target,GLint level,GLint xOffset,GLint yOffset,GLsizei width,GLsizei height,GLenum format,GLenum type,const GLvoid *data);void glTexSubImage3D(GLenum target,GLint level,GLint xOffset,GLint yOffset,GLint zOffset,GLsizei width,GLsizei height,GLsizei depth,Glenum type,const GLvoid * data); 2.6 插⼊入替换纹理12345678void glCopyTexSubImage1D(GLenum target,GLint level,GLint xoffset,GLint x,GLint y,GLsizeiwidth); void glCopyTexSubImage2D(GLenum target,GLint level,GLint xoffset,GLint yOffset,GLint x,GL y,GLsizei width,GLsizei height);void glCopyTexSubImage3D(GLenum target,GLint level,GLint xoffset,GLint yOffset,GLint zOffset,GLint x,GLint y,GLsizei width,GLsizei height); 三 纹理对象123456789//使⽤用函数分配纹理理对象//指定纹理理对象的数量量 和 指针(指针指向⼀一个⽆无符号整形数组，由纹理理对象标识符填充)。 void glGenTextures(GLsizei n,GLuint * textTures);//绑定纹理理状态 //参数target:GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D //参数texture:需要绑定的纹理理对象void glBindTexture(GLenum target,GLunit texture);//删除绑定纹理理对象//纹理理对象 以及 纹理理对象指针(指针指向⼀一个⽆无符号整形数组，由纹理理对象标识符填充)。 void glDeleteTextures(GLsizei n,GLuint *textures);//测试纹理理对象是否有效 //如果texture是⼀一个已经分配空间的纹理理对象，那么这个函数会返回GL_TRUE,否则会返回GL_FALSE。 GLboolean glIsTexture(GLuint texture); 3.1 设置纹理参数1234567//参数1:target,指定这些参数将要应⽤用在那个纹理理模式上，⽐比如GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D //参数2:pname,指定需要设置那个纹理理参数//参数3:param,设定特定的纹理理参数的值glTexParameterf(GLenum target,GLenum pname,GLFloat param);glTexParameteri(GLenum target,GLenum pname,GLint param);glTexParameterfv(GLenum target,GLenum pname,GLFloat *param);glTexParameteriv(GLenum target,GLenum pname,GLint *param); 3.2 设置过滤⽅方式 邻近过滤(GL_NEAREST) 线性过滤(GL_LINEAR) 2种纹理理过滤⽅方式⽐比较 12345678910glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST) 纹理理缩⼩小时,使⽤用邻近过滤glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST) 纹理理放⼤大时,使⽤用线性过滤glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_HEAREST);glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_HEAREST);glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); 3.3 设置环绕⽅方式 123456参数1:GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D 参数2:GL_TEXTURE_WRAP_S、GL_TEXTURE_T、GL_TEXTURE_R,针对s,t,r坐标 参数3:GL_REPEAT、GL_CLAMP、GL_CLAMP_TO_EDGE、GL_CLAMP_TO_BORDERGL_REPEAT:OpenGL 在纹理理坐标超过1.0的⽅方向上对纹理理进⾏行行重复; GL_CLAMP:所需的纹理理单元取⾃自纹理理边界或TEXTURE_BORDER_COLOR. GL_CLAMP_TO_EDGE环绕模式强制对范围之外的纹理理坐标沿着合法的纹理理单元的最后⼀一⾏行行或者最后⼀一列列来进⾏行行采样。 GL_CLAMP_TO_BORDER:在纹理理坐标在0.0到1.0范围之外的只使⽤用边界纹理理单元。边界纹理理单元是作为围绕基本图像的额外的⾏行行和列列，并与基本纹理理图像⼀一起加载的。glTextParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAR_S,GL_CLAMP_TO_EDGE);glTextParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAR_T,GL_CLAMP_TO_EDGE); OpenGL 像素格式 四 设置Mip 贴图1234//设置mip贴图基层glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_BASE_LEVEL,0); //设置mip贴图最⼤大层glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAX_LEVEL,0); Demo 下载点击获取Demo]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习 基本变化 (四)]]></title>
    <url>%2F2018%2F02%2F09%2F15244691153165.html</url>
    <content type="text"><![CDATA[一、抗锯齿混合的两大功能:颜⾊色组合、抗锯⻮齿 混合处理-抗锯齿 123456//开启混合处理理 glEnable(GL_BLEND);//指定混合因⼦子 GLBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);//指定混合⽅方程式 glBlendEquation(GL_FUNC_ADD);glEnable(GL_POINT_SMOOTH); //对点进⾏行行抗锯⻮齿处理理glEnable(GL_LINE_SMOOTH);//对线进⾏行行抗锯⻮齿处理理 glEnable(GL_POLYGON_SMOOTH);//对多边形进⾏行行抗锯⻮齿处理理 二、多重采样1234//1.可以调⽤用 glutInitDisplayMode 添加采样缓存区 glutInitDisplayMode(GLUT_MULTISAMPLE);//2.可以使⽤用glEnable| glDisable组合使⽤用GLUT_MULTISAMPLE 打开| 关闭 多重采样。glEnable(GLUT_MULTISAMPLE);glDisable(GLUT_MULTISAMPLE); 三、多重采样、抗锯⻮齿混合综合使⽤用1234567glDisable(GLUT_MULTISAMPLE);glEnable(GL_POINT_SMOOTH);//Draw some smooth pointglDisable(GL_POINT_SMOOTH);glDisable(GL_LINE_SMOOTH);glEnable(GLUT_MULTISAMPLE);//Draw some smooth polygon 四、多重采样 拓拓展多重采样缓存区在默认情况下使⽤用⽚片段RGB值，并不不包含颜 ⾊色的alpha成分，我们可以通过调⽤用glEnable来修改这个 ⾏行行为: GL_SAMPLE_ALPHA_TO_COVERAGE 使⽤用alpha值 GL_SAMPLE_ALPHA_TO_ON 使⽤用alpha值并设为1，并 使⽤用它。 GL_SAMPLE_COVERAGE 使⽤用glSampleCoverage 所设置的值。 当启⽤用 GL_SAMPLE_COVERAGE 时，可以使⽤用 glSampleCoverage函数允许指定⼀一个特定的值，它是与⽚片 段覆盖值进⾏行行按位与操作的结果。 五、向量 如何定义三维、四维向量量或三维向量量数组、四维向量量数组?M3DVector3f :表示⼀一个三维的向量量(x,y,z)M3DVector4f :表示⼀一个四维的向量量(x,y,z,w)(R,G,B,A) 六、点乘 七、使用矩阵堆栈123456789101112131415//类型GLMatrixStack::GLMatrixStack(int iStackDepth = 64);//在堆栈顶部载⼊入⼀一个单元矩阵void GLMatrixStack::LoadIdentity(void);//在堆栈顶部载⼊入任何矩阵 //参数:4*4矩阵void GLMatrixStack::LoadMatrix(const M3DMatrix44f m);//矩阵乘以矩阵堆栈顶部矩阵，相乘结果存储到堆栈的顶部void GLMatrixStack::MultMatrix(const M3DMatrix44f);//获取矩阵堆栈顶部的值 GetMatrix 函数 //为了了适应GLShaderMananger的使⽤用，或者获取顶部矩阵的副本const M3DMatrix44f &amp; GLMatrixStack::GetMatrix(void);void GLMatrixStack::GetMatrix(M3DMatrix44f mMatrix); 八、压栈、出栈1234567//将当前矩阵压⼊入堆栈void GLMatrixStack::PushMatrix(void);//将M3DMatrix44f 矩阵对象压⼊入当前矩阵堆栈void PushMatrix(const M3DMatrix44f mMatrix);//将GLFame 对象压⼊入矩阵对象void PushMatrix(GLFame &amp;frame);//出栈(出栈指的是移除顶部的矩阵对象) void GLMatrixStack::PopMatrix(void); 九、仿射变换 GLMastrixStack 内建了旋转\平移\缩放12345//Rotate 函数angle参数是传递的度数，⽽而不不是弧度void MatrixStack::Rotate(GLfloat angle,GLfloat x,GLfloaty,GLfloat z);void MatrixStack::Translate(GLfloat x,GLfloat y,GLfloat z);void MatrixStack::Scale(GLfloat x,GLfloat y,GLfloat z); 十、使用照相机 和 角色帧 进行移动12345class GLFrame &#123;protected:M3DVector3f vOrigin; // Where am I? M3DVector3f vForward; // Where am I going? M3DVector3f vUp; // Which way is up?&#125; 十一、GLFrame12345678//将堆栈的顶部压⼊入任何矩阵void GLMatrixStack::LoadMatrix(GLFrame &amp;frame);//矩阵乘以矩阵堆栈顶部的矩阵。相乘结果存储在堆栈的顶部 void GLMatrixStack::MultMatrix(GLFrame &amp;frame);//将当前的矩阵压栈void GLMatrixStack::PushMatrix(GLFrame &amp;frame); 十二、照相机管理 12//GLFrame函数，这个函数⽤用来检索条件适合的照相矩阵void GetCameraMatrix(M3DMatrix44f m,bool bRotationOnly = flase); Demo 下载点击获取Demo]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习 深度测试(三)]]></title>
    <url>%2F2018%2F02%2F08%2F15244657893765.html</url>
    <content type="text"><![CDATA[一、渲染过程是中可能产生的问题 解决办法：1：油画法2：正面、背面剔除。3：深度测试。 1.1、油画法 油画法：比较消耗性能，重复绘制了重叠部分，对于多个图形叠加在一起的，难以分辨哪个是最上层的，导致渲染混乱 1.2、正面背面剔除可以调用下面两个方法开启或关闭表面剔除 12glEnable(GL_CULL_FACE); //开启glDisable(GL_CULL_FACE); // 关闭 该函数的原型如下void glFrontFace(GLenum mode); mode 参数的可选的值有 GL_CW 和 GL_CCW （默认值是GL_CCW） GL_CW 表示顶点的排列顺序是顺时针的面 是正面。GL_CCW 表示顶点的排列顺序是逆时针的面是正面 （默认值） void glCullFace() GL_FRONT // 正面剔除GL_BACK // 背面剔除GL_FRONT_ANF_BACK 正面和反面都要剔除 二、什么叫深度？所谓的深度，就在坐标系中，像素Z坐标距离观察者的距离观察者，可以在任何位置，OpenGL会有专门有一块缓存区来存放Z值，深度缓冲区！每个像素上的Z值。 三、深度缓冲去区的作用一般情况下，我们绘制图形时，后面绘制的会覆盖前面的图形。一般绘制的顺序先后面再前面。产生一个性能问题，就是遮盖部分，先绘制的会被覆盖，这没有任何意义的绘制。深度测试就是用来解决这个问题的它是如何处理的？有了深度缓冲区之后，绘制的时候会检查Z,靠近观察者的覆盖。而不是靠绘制顺序来决定。 四、如何使用深度缓冲区测试？为什么要测试？一旦开启之后就会先测试深度值再绘制 glEnable (GLDEPTHTEST); 默认情况下Z值小的情况下会被覆盖如果是观察者，在Z轴的正方向，Z值大的靠近观察者如果是观察者，在Z轴的负方向，Z值小的靠近观察者 五、多边形模型 使用glPolygonMode(Glenum face,Glenum mode) 函数来指定填充方式Face参数:GL_FRONT、GL_BACK、GL_FRONT_AND_BACKMode参数:GL_FILL(默认实心填充) 、GL_LINE、GL_POINT 六、多边形偏移深度测试实现深度的过程中，可能产生的2种问题:1、z-fighting(z冲突)2、图形重叠(无法体现深度) 七、如何解决深度值相同，造成的冲突问题第一种方法：在第二次绘制时，稍微偏移一点点解决这个问题。注意：必须非常小心确保Z值的间隙 第二种方法：采样glPolygonOffset 函数。使得可以调节片段的深度值。使得深度之偏移而不产生悬浮 glPolygonOffset 函数void glPolygonOffset(Glfloat factor,Glfloat units); 应用到片段上总偏移计算方程式:Depth Offset = (DZ factor) + (r units);DZ:深度值(Z值)r:使得深度缓冲区产生变化的最小值负值，将使得z值距离我们更近，而正值，将使得z值距离我们更远，对于上节课的案例，我们设置factor和units设置为-1，0 八、裁剪在OpenGL 提高渲染的一种方式，只刷新屏幕上发生变化的部分。OpenGL 允许我们将要进行渲染的窗口只去指定一个裁剪框。 1234567//1 开启裁剪测试glEnable(GL_SCISSOR_TEST);//2.关闭裁剪测试glDisable(GL_SCISSOR_TEST);//3.指定裁剪窗口//x,y:指定裁剪框左下角位置;width,height:指定裁剪尺寸void glScissor(Glint x,Glint y,GLSize width,GLSize height); 九、混合我们把OpenGL 渲染时会把颜色值存在颜色缓存区中，每个片段的深度值也是放在深度缓冲区。当深度缓冲区被关闭时，新的颜色将简单的覆盖原来颜色缓存区存在的颜色值，当深度缓冲区再次打开时，新的颜色片段只是当它们比原来的值更接近邻近的裁剪平面才会替换原来的颜色片段。glEnable(GL_BlEND); 9.1 组合颜色目标颜色:已经存储在颜色缓存区的颜色值源颜色:作为当前渲染命令结果进入颜色缓存区的颜色值当混合功能被启动时，源颜色和目标颜色的组合方式是混合方程式控制的。在默认情况下，混合方程式如下所示: 123456Cf = (Cs * S) + (Cd * D)Cf :最终计算参数的颜色Cs : 源颜色Cd :目标颜色S:源混合因子D:目标混合因子 9.2 设置混合因子1234设置混合因子，需要用到glBlendFun函数glBlendFunc(GLenum S,GLenum D);S:源混合因子D:目标混合因子 9.3 混合因子枚举列表 表中R、G、B、A 分别代表红、绿、蓝、alpha。表中下标S、D，分别代表源、目标表中C 代表常量颜色(默认黑色) 9.4总结最终颜色是以原先的红色(目标颜色)与 后来的蓝色(源颜色)进行组合。源颜色的alpha值越高，添加的蓝色颜色成分越高，目标颜色所保留的成分就会越少。混合函数经常用于实现在其他一些不透明的物体前面绘制一个透明物体的效果 十、改变组合方程式默认混合方程式:Cf = (CsS)+(CdD)实际上远不止这一种混合方程式，我们可以从5个不同的方程式中进行选择 10.1 改变混合方程式的函数 glBlendEquation()选择混合方程式的函数:glbBlendEquation(GLenum mode); 10.2 glBlendFuncSeparate 函数1234567除了能使用glBlendFunc 来设置混合因子，还可以有更灵活的选择。strRGB: 源颜色的混合因子dstRGB: 目标颜色的混合因子strAlpha: 源颜色的Alpha因子dstAlpah: 目标颜色的Alpha因子void glBlendFuncSeparate(GLenum strRGB,GLenum dstRGB,GLenum strAlpha,GLenumdstAlpha); 10.3 glBlendFuncSeparate 注意 glBlendFunc 指定 源和目标 RGBA值的混合函数;但是glBlendFuncSeparate函数则允许为RGB 和 Alpha 成分单独指定混合函数。在混合因子表中，GL_CONSTANT_COLOR,GL_ONE_MINUS_CONSTANT_COLOR,GL_CONSTANT_ALPHA,GL_ONE_MINUS_CONSTANT值允许混合方程式中引入一个常量混合颜色。 10.4 常量混合颜色常量混合颜色，默认初始化为黑色(0.0f,0.0f,0.0f,0.0f)，但是还是可以修改这个常量混合颜色。void glBlendColor(GLclampf red ,GLclampf green ,GLclampf blue ,GLclampf alpha ); Demo 下载点击获取Demo]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习 基础渲染(二)]]></title>
    <url>%2F2018%2F02%2F07%2F15244572175577.html</url>
    <content type="text"><![CDATA[在OpenGL 3.0之前，OpenGL 包含一个固定功能的管线，它可以在不使用着色器的情况下处理几何与像素数据。在3.1版本开始，固定管线从核心模式去掉。因此现在需要使用着色器来完成工作。使 OpenGL 来说，我们会使 GLSL,(OpenGL Shading Langruage，它是在OpenGL 2.0版本发布的)。 语法与“C、C++”类似。 一、基础图形管线OpenGL 中图元只不过是顶点的集合以预定义的方式结合在一起。管线分为:2个部分，上半部分是客户机端，下半部分是服务器端。 客户端是存储在CPU存储 中的，并且在应用程序中执行 ，或者在主系统内存的驱动程序中执行。驱动程序会将渲染命令和数组组合起来，发送给服务执执 !(在一台典型的个人计算机上，服务器就是实际上就是图形加速卡上的硬件和内存)服务器和 客户机在功能上也是异步的。 它们是各自独力的软件块或硬件块。我们是希望它们2个端都尽量在 不停的工作。客户端不断的把数据块和命令块组合在一起输送到缓冲区，然后缓冲区就会发送到服务器执 。 如果服务器停止工作等待客户机，或者客户机停止作来等待服务器做好接受更多的命令和准备，我们把这种情况成为管线停滞 二、着色器渲染过程，必备的两个着色器“顶点着色器”和“片元着色器”。上图的Vertex Shader(顶点着色器) 和 Fragment Shader(片元着色器)着色器是使用GLSL编写的程序，看起来与C语言非常类似。 着色器必须从源代码中编译和链接在一起。最终准备就绪的着色器程序顶点着色器 –&gt;处理从客户机输入的数据、应用变换、进行其他的类型的数学运算来计算关照效果、位移、颜 值等等。(**为了渲染共有3个顶点的三角形，顶点着色器将执 3次，也就是为 了每个顶点执一次)在目前的硬件上有多个执行单元同时运行 ，就意味着所有的3个顶点可以同时进行处理 ! 图上(primitive Assembly 说明的是:3个顶点已经组合在一起， 三角形已经逐个片段的进行光栅化。每个片段通过执片元元着器，进行 填充。 元着器会输出我们将屏幕上看到的最终颜色值。 三、3种向OpenGL着色器传递渲染数据的方法 属性 Uniform 纹理3.1 属性 属性：就是对一个顶点都要作改变的数据元素。实际上，顶点位置本身就是一个属性。属性可以是浮点类型、整型、布尔类型。 属性总是以四维向 的形式进行内部存储的，即使我们不会使用所有的4个分量。一个顶点位置可能存储(x,y,z)，将占有4个分量中的3个。实际上如果是在平面情况下:只要在xy平面上就能绘制，那么Z分量就会自动设置为0;属性还可以是:纹理坐标、颜色值、关照计算表面法线在顶点程序(shader渲染)可以代表你想要的任何意义。因为都是你设定的。属性会从本地客户机内存中复制存储在图形硬件中的一个缓冲区上。这些属性只提供给顶点着 使 ，对于 元着 有太 意义。声明:这些属性对每个顶点都要做改变，但并不意味着它们的值不能重复。通常情况下，它们都是 不一样样的，但有可能整个数组都是同一值的情况。 3.2 Uniform属性是 种对整个批次属性都取统一值的单一值，它是不变的。 通过设置uniform变量就紧接着发送一个图元批次命令。Uniform变量实际上可以无限次限制地使用，设置一个应用于整个表面的单个颜色值，还可以设置一个时间值。在每次渲染某种类型的顶点动画时修改它。注意:这 的uniform 变量每个批次改变一次，而不是每个顶点改变一次。uniform变量最常见的应该是在顶点渲染中设置变换矩阵与属性相同点:可以是浮点值、整数、布尔值与属性不同点:顶点着色器和片元着色器都可以用 uniform变量 。uniform 变量还可以是标量类型、 矢量类型、uniform矩阵。 3.3 纹理传递给着器的第三种数据类型:纹理数据 在顶点着色器、 片段着色器中都可以对纹理数据进行采样和筛选。典型的应用场景: 片段着色器对一个纹理值进行采样，然后在一个三角形表面应用渲染纹理数据。纹理数据， 不仅仅表现在图形，很多图形文件格式都是以无符号字节(每个颜色通道8位)形式对颜分量进行存储的。 3.4 输出输出数据：简单的从一个阶段传递到下一个阶段。客户端的代码接触不到这些内部变量。我们的OpenGL开发暂时接触不到！ 四、创建坐标系4.1 正投影 这就是一个正投影的 例子，在所在3个轴(X,Y,Z)中，它们的范围都是从-100到+100。这个视景体将包括所有的 几何图形。如果你指定 了视景体外的几何图形，就会被裁减掉!(它将沿着视景体的边界进行剪切)在正投影中，所有在这个空间范围内的所有东西都将被呈现在屏幕上。 存在照相机或视点坐标系的概念。 4.2透视投影setPerspective(float ffov,float fAspect,float fNear,float fFar) 透视投影会进行透视除法对距离观察者很远的对象进行缩短和收缩。在投影到屏幕之后，视景体背面与视景体正面的宽度测量标准不同。上图所示:平截头体(frustum)的 何体，它的观察方向是从金字塔的尖端到宽阔端。观察者的视点与金字塔的尖端拉开一定距离。 123456789GLFrustum类通过setPerspective 法为我们构建一个平截头体。参数:fFov:垂直方向上的视场角度fAspect:窗口的宽度与高度的纵横 fNear:近裁剪面距离fFar:远裁剪面距离纵横 = 宽(w)/ (h)CLFrustum::SetPerspective(float fFov,float fAspect,float fNear,float fFar); 五、使用存储着色器5.1、使用背景5.2存储着色器的使用 单位着色器 平面着色器 上色着色器 默认光源着色器 点光源着色器 纹理替换矩阵 纹理调整着色器 纹理光源着色器 5.3 GLShaderManager 的初始化12345678// 定义着色器GLShaderMananger shaderManager;// 初始化着色器shaderManager.IntalizeStockShaders()//使用shaderManager userStockManager(参数列表) 5.4 GLShaderManager 属性 存储着色器为每一个变量都使用一致的内部变量命名规则和相同的属性槽，以上就是存储着色器的属性列表。 5.5 GLShanderManager 的 uniform值一般情况，要对几何图形进行渲染，我们需要给对象递交属性矩阵， 先要绑定我们想要使用的着色器程序上，并提供程序的uniform值。但是GLShanderManager 类可以暂时为我们完成工作。useStockShader 函数会选择一个存储着色器并提供这个着色器的uniform值。 单位着色器 12345//单位着色器:只是简单地使用默认笛卡尔坐标系(坐标范围(-1.0，1.0))。所有的片段都应用同一种颜色 ，几何图形为心和未渲染的。//需要设置存储着色器一个属性: GLT_ATTRIBUTE_VERTEX(顶点分量)//参数2:vColor[4],你需要的颜色GLShaderManager::UserStockShader(GLT_ATTRIBUTE_VERTEX,GLfloat vColor[4]); 平面着色器 123456//参数1:平面着色器 //参数2:允许变化的4*4矩阵//参数3:颜色//它将统一着色器进行了拓展。允许为几何图形变换指定一个 4 * 4 变换矩阵。经常被称为“模型视图投影矩阵”GLShaderManager::UserStockShader(GLT_SHADER_FLAT,GLfloat mvp[16],GLfloat vColor[4]); 上色着色器 1234//在几何图形中应用的变换矩阵。//需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量 ) 和GLT_ATTRIBUTE_COLOR(颜色分量 ) 2个属性。颜色值将被平滑地插入顶点之间(平滑着色 )GLShaderManager::UserStockShader(GLT_SHADER_SHADED,GLfloat mvp[16]); 默认光源着色器 1234567//参数1:默认光源着色器 //参数2:模型视图矩阵//参数3:投影矩阵//参数4:颜 值//这种着色器，是对象产 阴影和关照的效果。需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和GLT_ATTRIBUTE_NORMAL(表面法线)GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT,GLfloat mvMatrix[16],GLfloatpMatrix[16],GLfloat vColor[4]); 点光源着色器 12345678//参数1:点光源着色器//参数2:模型视图矩阵//参数3:投影矩阵//参数4:视点坐标光源位置//参数5:颜色值//点光源着色器和默认光源着色器很相似，区别在于:光源位置是特定的。同样需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和GLT_ATTRIBUTE_NORMAL(表面法线)GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT_DIEF,GLfloatmvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vColor[4]); 纹理替换矩阵着色器 1234//着色器通过给定的模型视图投影矩阵，使用绑定到 nTextureUnit (纹 单元) 指定纹理单元的纹理对几何图形进行变化。 段颜 :是直接从纹理样本中直接获取的。//需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和 GLT_ATTRIBUTE_NORMAL(表面法线)GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_REPLACE,GLfloat mvMatrix[16],GLintnTextureUnit); 纹理调整着色器 123//将一个基本色乘以一个取自纹理单元 nTextureUnit 的纹 。需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和 GLT_ATTRIBUTE_TEXTURE0(纹理坐标)GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_MODULATE,GLfloatmvMatrix[16],GLfloat vColor[4],GLint nTextureUnit); 纹理光源着色器 123456789//参数1:纹理光源着色器 //参数2:投影矩阵//参数3:视觉空间中的光源位置//参数4: 何图形的基本色//参数5:将要使用的纹理单元//将一个纹理通过漫反射照明计算机进行调整(相乘)。光线在视觉空间中的位置是给定的。//需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和 GLT_ATTRIBUTE_TEXTURE0(纹理坐标)、GLT_ATTRIBUTE_NORMAL(表面法线)GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIEF,GLfloatmvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vBaseColor[4],GLint nTextureUnit); 六、OpenGL图元 点 线 线带 线环 三角形 三角形金字塔 三角形带 三角形扇 1234567891011//修改点的大小glPointSize(4.0f);//设置点的大小范围，点和点之间的距离GLfloat sizes[2] = &#123;2.0f,4.0f&#125;;GLfloat stepSize = 1.0f;//获取点的大小范围和步长glGetFloatv(GL_POINT_SIZE_RANGE,sizes);glGetFloatv(GL_POINT_GRAULRITY,&amp;stepSize);//3.通过使用程序点大小模式设置点大小glEnable(GL_PROGAM_POINT_SIZE);//GLSL程序gl_PointSize = 5.0f; 七、GLBatch容器(帮助类) 八 OpenGL 渲染过程 Demo 下载点击获取Demo]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习 在Mac上搭建OpenGL环境(一)]]></title>
    <url>%2F2018%2F02%2F05%2F15244567239248.html</url>
    <content type="text"><![CDATA[一、准备资源 CLTools glew libGLTools.a 百度云盘资源地址：链接: https://pan.baidu.com/s/1ebesf8 密码: g99g 二、现在开始配置 openGL 环境 1、打开Xcode -&gt; macOS -&gt; Cocoa Application 2、选中Build Phases, 选择 Link Binary With Libraries ,点击 + 搜索添加 OpenGl.framework 和 GLUT.framework 两个系统库. 3、把下载好的 include 和 libGLTools.a 拖入到项目里面，选中 Copy item if needed 和 Create groups 4、然后点击 Build Settings, 选则All ，找到 Header Search Paths, 把你拖到项目里的 include 文件夹路径 拖到里面。把libGLTools.a 文件拖到Framework 里面 5、接着把 AppDelegate.h, AppDelegate.m,ViewController.h,ViewControllers.m 文件删除掉OpenGL006.jpeg 6、添加新的文件，选择 C++ File ,Name 设置为main，并且不要勾选下面的 also create a header file,点击Next ,生成main.cpp文件 7、然后把main.m 文件删除掉。 8、把下面的代码复制到 main.cpp 里面，然后把项目跑起来 Run BOpenGL010.jpeg 三、注意事项与报错处理 如果报下面的错误ld: library not found for -lGLToolsclang: error: linker command failed with exit code 1 (use -v to see invocation) 选择General 下面 的林科大Frameworks and Libraries选中 libGLTools.a 点击下面的 一 删除掉，然后点击 + , 选择 Add Other,然后找到你项目里面的 libGLTools.a，选中并点击 open，重新 Run Build 就好了。 注意 ：新建的main.cpp 文件里面 必须要有 main 函数，不然直接build 会报错 Demo 下载点击获取Demo]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 CADisplayLink 定时器的了解与使用]]></title>
    <url>%2F2017%2F09%2F19%2FiOS%E5%BC%80%E5%8F%91CADisplayLink-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[一、简介1、所在框架CADisplayLink和其它CoreAnimation类一样，都是在QuartzCore.framework里。 1.1什么是CADisplayLink? CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 CADisplayLink 对象，把它添加到一个runloop中，并给它提供一个 target 和selector 在屏幕刷新的时候调用。 一但 CADisplayLink 以特定的模式注册到runloop之后，每当屏幕需要刷新的时候，runloop就会调用CADisplayLink绑定的target上的selector，这时target可以读到 CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。 在添加进runloop的时候我们应该选用高一些的优先级，来保证动画的平滑。可以设想一下，我们在动画的过程中，runloop被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行CADisplayLink的调用，从而造成动画过程的卡顿，使动画不流畅。 duration属性提供了每帧之间的时间，也就是屏幕每次刷新之间的的时间。我们可以使用这个时间来计算出下一帧要显示的UI的数值。但是 duration只是个大概的时间，如果CPU忙于其它计算，就没法保证以相同的频率执行屏幕的绘制操作，这样会跳过几次调用回调方法的机会。frameInterval属性是可读可写的NSInteger型值，标识间隔多少帧调用一次selector 方法，默认值是1，即每帧都调用一次。如果每帧都调用一次的话，对于iOS设备来说那刷新频率就是60HZ也就是每秒60次，如果将 frameInterval 设为2 那么就会两帧调用一次，也就是变成了每秒刷新30次。 我们通过pause属性开控制CADisplayLink的运行。当我们想结束一个CADisplayLink的时候，应该调用-(void)invalidate从runloop中删除并删除之前绑定的 target跟selector另外CADisplayLink 不能被继承。 2、功能CADisplayLink最主要的特征是能提供一个周期性的调用我们赋给它的selector的机制，从这点上看它很像定时器NSTimer。 3、使用方式12345678910111213141516- (void)startDisplayLink &#123; self.displayLink = [`CADisplayLink` displayLinkWithTarget:self selector:@selector(handleDisplayLink:)]; [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; &#125; - (void)handleDisplayLink:(`CADisplayLink` *)displayLink &#123; //do something &#125; - (void)stopDisplayLink &#123; [self.displayLink invalidate]; self.displayLink = nil; &#125; 当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于NSTimer被启动了；执行invalidate操作时，CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。 CADisplayLink 与 NSTimer 有什么不同 iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。 二、特性下面结合NSTimer来介绍CADisplayLink，与NSTimer不同的地方有： 1、原理不同CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。NSTimer以指定的模式注册到runloop后，每当设定的周期时间到达后，runloop会向指定的target发送一次指定的selector消息。 2、周期设置方式不同iOS设备的屏幕刷新频率(FPS)是60Hz，因此CADisplayLink的selector默认调用周期是每秒60次，这个周期可以通过frameInterval属性设置，CADisplayLink的selector每秒调用次数=60/frameInterval。比如当frameInterval设为2，每秒调用就变成30次。因此，CADisplayLink周期的设置方式略显不便。NSTimer的selector调用周期可以在初始化时直接设定，相对就灵活的多。 3、精确度不同iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在忙于别的调用，触发时间就会推迟到下一个runloop周期。更有甚者，在OS X v10.9以后为了尽量避免在NSTimer触发时间到了而去中断当前处理的任务，NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间范围。 4、使用场合从原理上不难看出，CADisplayLink使用场合相对专一，适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。 三、重要属性下面不完整的列出了CADisplayLink的几个重要属性： 1、frameInterval可读可写的NSInteger型值，标识间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。官方文档中强调，当该值被设定小于1时，结果是不可预知的。 2、duration只读的CFTimeInterval值，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：时间=duration×frameInterval。现存的iOS设备屏幕的FPS都是60Hz，这一点可以从CADisplayLink的duration属性看出来。duration的值都是0.166666…，即1/60。尽管如此，我们并没法确定苹果不会改变FPS，如果以后某一天将FPS提升到了120Hz了怎么办呢？这时，你设置了frameInterval属性值为2期望每秒刷新30次，却发现每秒刷新了60次，结果可想而知，出于安全考虑，还是先根据duration判断屏幕的FPS再去使用CADisplayLink。 3、timestamp只读的CFTimeInterval值，表示屏幕显示的上一帧的时间戳，这个属性通常被target用来计算下一帧中应该显示的内容。 虽然名为时间戳，但这和常见的unix时间戳差异很大，事实上这是CoreAnimation使用的时间格式。每个CALayer都有一个本地时间（CALayer本地时间的具体作用会在后续文章中说明），可以获取当前CALayer的本地时间并打印： 12CFTimeInterval localLayerTime = [myLayer convertTime:CACurrentMediaTime() fromLayer:nil]; NSLog(@&quot;localLayerTime:%f&quot;,localLayerTime); 四、注意iOS并不能保证能以每秒60次的频率调用回调方法，这取决于： 1、CPU的空闲程度如果CPU忙于其它计算，就没法保证以60HZ执行屏幕的绘制动作，导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。 2、执行回调方法所用的时间如果执行回调时间大于重绘每帧的间隔时间，就会导致跳过若干次回调调用机会，这取决于执行时间长短。 3.通常来讲iOS设备的刷新频率事60HZ也就是每秒60次。那么每一次刷新的时间就是1/60秒 大概16.7毫秒。当我们的frameInterval值为1的时候我们需要保证的是 CADisplayLink调用的｀target｀的函数计算时间不应该大于 16.7否则就会出现严重的丢帧现象。 五、参考文档1、官方文档2、官方使用CADisplayLink播放视频的例子]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FMDB 数据库简单基本操作]]></title>
    <url>%2F2017%2F06%2F27%2FFMDB-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728291.创建表: create table if not exists 表名 (字段名1, 字段名2…); 例如：创建 t_student 表 id（id自增长）create table if not exists t_student (id integer primary key autoincrement, name text not null, age integer)2.增加数据: insert into 表名 (字段名1, 字段名2, …) values(字段1的值, 字段2的值, …); 例如：在 t_student 表插入name，age字段insert into t_student (name,age) values (@”Jack”,@17);3.1根据条件删除数据： delete from 表名 where 条件; 例如：删除 t_student 表中 name 字段为 Jack 的数据delete from t_student where name = @”Jack”;3.2删除表中所有的数据： delete from 表名； 例如：delete from t_student;4.根据条件更改某个数据 update 表名 set 字段1 = ‘值1’, 字段2 = ‘值2’ where 字段1 = ‘字段1的当前值’ 例如：update t_student set name = ‘lily’, age = ‘16’ where name = ‘Jack’5.1根据条件查找 select from 表名 where 字段1 = ‘字段1的值’ 例如：select from t_student where age = ‘16’5.2查找所有数据 select from 表名 例如：select from t_student5.3排序查找： select from 表名 order by 字段 例如：select from t_student order by age asc （升序，默认）select * from t_student order by age desc （降序） 3.6.删除表： drop table 表名 例如：drop table t_student]]></content>
      <categories>
        <category>FMDB</category>
      </categories>
      <tags>
        <tag>FMDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发权限设置]]></title>
    <url>%2F2017%2F05%2F05%2FiOS%E5%BC%80%E5%8F%91%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE.html</url>
    <content type="text"><![CDATA[iOS 8.0之后调用系统的API需要配置相关的配置信息才能正常使用 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 相册 --&gt;&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问相册&lt;/string&gt;&lt;!-- 相机 --&gt;&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问相机&lt;/string&gt;&lt;!-- 麦克风 --&gt;&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问麦克风&lt;/string&gt;&lt;!-- 位置 --&gt;&lt;key&gt;NSLocationUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问位置&lt;/string&gt;&lt;!-- 在使用期间访问位置 --&gt;&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能在使用期间访问位置&lt;/string&gt;&lt;!-- 始终访问位置 --&gt;&lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能始终访问位置&lt;/string&gt;&lt;!-- 日历 --&gt;&lt;key&gt;NSCalendarsUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问日历&lt;/string&gt;&lt;!-- 提醒事项 --&gt;&lt;key&gt;NSRemindersUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问提醒事项&lt;/string&gt;&lt;!-- 运动与健身 --&gt;&lt;key&gt;NSMotionUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问运动与健身&lt;/string&gt;&lt;!-- 健康更新 --&gt;&lt;key&gt;NSHealthUpdateUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问健康更新 &lt;/string&gt;&lt;!-- 健康分享 --&gt;&lt;key&gt;NSHealthShareUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问健康分享&lt;/string&gt;&lt;!-- 蓝牙 --&gt;&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问蓝牙&lt;/string&gt;&lt;!-- 媒体资料库 --&gt;&lt;key&gt;NSAppleMusicUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问媒体资料库&lt;/string&gt;]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 UITableViewCell的重用机制]]></title>
    <url>%2F2017%2F04%2F16%2FiOS%E5%BC%80%E5%8F%91UITableViewCell%E7%9A%84%E9%87%8D%E7%94%A8%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[首先,我们要明白我们为什么需要使用这种机制,其次,这种机制的原理是什么.我们先举个例子来说明.一个UITableView中有许多需要显示的cell,但是我们不可能每个都会浏览到,那么如果我们把这些数据全部都加载进去,是不是造成了内存的负担呢. 我们所能显示的区域通常只有一个屏幕的大小,那么那些屏幕之外的信息是不需要一次性全都加载完的,只有当我们滑动屏幕需要浏览的时候,我们才需要它加载进来.因此,就有了我们要介绍的这部分内容,UITabelViewCell的重用机制. 重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell,我们只创建屏幕可显示的最大的cell个数+1,然后去循环重复使用这些cell,既节省空间,又达到我们需要显示的效果.这种机制下系统默认有一个可变数组NSMutableArray visiableCells,用来保存当前显示的cell.一个可变字典NSMutableDictnery reusableTableCells,用来保存可重复利用的cell.(之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell). 1234567891011121314// 设置单元格 indexPath :单元格当前所在位置 -- 哪个分区哪一行等- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath //UITableViewDataSource&#123; static NSString *identifier = @&quot;cell&quot; ; //相当于从集合中找寻完全出屏幕的单元格. // identifier : 因为一个表视图中可能存在多种样式的单元格,咱们把相同样式的单元格放到同一个集合里面,为这个集合加标示符,当我们需要用到某种样式的单元格的时候,根据不同的标示符,从不同的集合中找寻单元格. UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier] ; // 如果从集合中未找到单元格,也就是集合中还没有单元格,也就是还没有单元格出屏幕,那么我们就需要创建单元格 if (!cell) &#123; // 创建cell的时候需要标示符(Identifier)是因为,当该cell出屏幕的时候需要根据标示符放到对应的集合中. cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@&quot;cell&quot;] ; return cell ;&#125; 1234567系统第一次执行- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath这个方法的时候, reusableTableCells为空,[tableView dequeueReusableCellWithIdentifier:identifier]的返回值为nil,我们需要通过[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier]方式来创建. 当我们的数据过多,整个屏幕的cell显示不完全时,这个方法的执行情况是 : (1) 先执行[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier]创建整个屏幕能显示的cell数+1的cell(当我们拖动UITableView的时候,第一个cell没有移出屏幕,最下面的cell就已经存在),并指定相同或者不同的标示符identifier.把创建出的屏幕能显示的cell全部都加入到visiableCells数组中(最后一个创建的先不加入数组)，reusableTableCells为空. (2)当我们拖动屏幕时,顶端的cell移出屏幕并加入到reusableTableCells字典中,键为identifier ,并把之前已经创建的但是没有加入到visiableCells的cell加入到visiableCells数组中. (3)当我们接着拖动的时候,因为reusableTableCells中已经有值，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用，执行[tableView dequeueReusableCellWithIdentifier: identifier]，返回一个标示符为identifier的cell。该cell移出reusableTableCells之后加入到visiableCells；顶端的cell移出visiableCells并加入到reusableTableCells.如果visiableCells数组中没有找到identifier类型的cell,则再次重新alloc一个. 在iOS6之后系统加入了一种单元格注册的方法.[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier: identifier]; 这个方法的作用是,当我们从重用队列中取cell的时候,如果没有,系统会帮我们创建我们给定类型的cell,如果有,则直接重用. 这种方式cell的样式为系统默认样式. 在设置cell的方法中只需要: 123456- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 重用队列中取单元格 由于上面已经注册过单元格,系统会帮我们做判断,不用再次手动判断单元格是否存在 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier: identifier forIndexPath:indexPath] ; return cell ;&#125;]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 APP的生命周期和UIViewController的生命周期]]></title>
    <url>%2F2017%2F03%2F12%2FiOS%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
    <content type="text"><![CDATA[一. iOS程序的启动执行顺序1.具体执行流程123456789101112131415161718192021222324252627282930程序入口进入main函数，设置AppDelegate称为函数的代理程序完成加载[AppDelegate application:didFinishLaunchingWithOptions:]创建window窗口程序被激活[AppDelegate applicationDidBecomeActive:]当点击command+H时(针对模拟器,手机是当点击home键)程序取消激活状态[AppDelegate applicationWillResignActive:];程序进入后台[AppDelegate applicationDidEnterBackground:];点击进入工程程序进入前台[AppDelegate applicationWillEnterForeground:]程序被激活[AppDelegate applicationDidBecomeActive:]; 2.分析 对于applicationWillResignActive(非活动)与applicationDidEnterBackground(后台)这两个的区别。applicationWillResignActive(非活动):比如当有电话进来或短信进来或锁屏等情况下，这时应用程序挂起进入非活动状态，也就是手机界面还是显示着你当前的应用程序的窗口，只不过被别的任务强制占用了，也可能是即将进入后台状态(因为要先进入非活动状态然后进入后台状态) applicationDidEnterBackground(后台):指当前窗口不是你的App,大多数程序进入这个后台会在这个状态上停留一会，时间到之后会进入挂起状态(Suspended)。如果你程序特殊处理后可以长期处于后台状态也可以运行。Suspended (挂起): 程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。 ###二. UIViewController 的 生命周期 当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序 1、 alloc 创建对象，分配空间 2、init (initWithNibName) 初始化对象，初始化数据 3、loadView 从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图 4、viewDidLoad 载入完成，可以进行自定义数据以及动态创建其他控件 5、viewWillAppear 视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了 6、viewDidAppear 视图已在屏幕上渲染完成当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反 1、viewWillDisappear 视图将被从屏幕上移除之前执行 2、viewDidDisappear 视图已经被从屏幕上移除，用户看不到这个视图了 3、dealloc 视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放 关于viewDidUnload ：在发生内存警告的时候如果本视图不是当前屏幕上正在显示的视图的话， viewDidUnload将会被执行，本视图的所有子视图将被销毁，以释放内存,此时开发者需要手动对viewLoad、viewDidLoad中创建的对象释放内存。 因为当这个视图再次显示在屏幕上的时候，viewLoad、viewDidLoad 再次被调用，以便再次构造视图。 当我们创建一个UIViewController类的对象时，通常系统会生成几个默认的方法，这些方法大多与视图的调用有关，但是在视图调用时，这些方法的调用顺序如何，需要整理下。通常上述方法包括如下几种，这些方法都是UIViewController类的方法： 1234567891011- (void)viewDidLoad；- (void)viewDidUnload； - (void)viewWillAppear:(BOOL)animated； - (void)viewDidAppear:(BOOL)animated； - (void)viewWillDisappear:(BOOL)animated； - (void)viewDidDisappear:(BOOL)animated； 下面介绍下APP在运行时的调用顺序。 1）- (void)viewDidLoad； 一个APP在载入时会先通过调用loadView方法或者载入IB中创建的初始界面的方法，将视图载入到内存中。然后会调用viewDidLoad方法来进行进一步的设置。通常，我们对于各种初始数据的载入，初始设定等很多内容，都会在这个方法中实现，所以这个方法是一个很常用，很重要的方法。 但是要注意，这个方法只会在APP刚开始加载的时候调用一次，以后都不会再调用它了，所以只能用来做初始设置。 2) - (void)viewDidUnload; 在内存足够的情况下，软件的视图通常会一直保存在内存中，但是如果内存不够，一些没有正在显示的viewcontroller就会收到内存不够的警告，然后就会释放自己拥有的视图，以达到释放内存的目的。但是系统只会释放内存，并不会释放对象的所有权，所以通常我们需要在这里将不需要在内存中保留的对象释放所有权，也就是将其指针置为nil。 这个方法通常并不会在视图变换的时候被调用，而只会在系统退出或者收到内存警告的时候才会被调用。但是由于我们需要保证在收到内存警告的时候能够对其作出反应，所以这个方法通常我们都需要去实现。 另外，即使在设备上按了Home键之后，系统也不一定会调用这个方法，因为IOS4之后，系统允许将APP在后台挂起，并将其继续滞留在内存中，因此，viewcontroller并不会调用这个方法来清除内存。 3）- (void)viewWillAppear:(BOOL)animated; 系统在载入所有数据后，将会在屏幕上显示视图，这时会先调用这个方法。通常我们会利用这个方法，对即将显示的视图做进一步的设置。例如，我们可以利用这个方法来设置设备不同方向时该如何显示。 另外一方面，当APP有多个视图时，在视图间切换时，并不会再次载入viewDidLoad方法，所以如果在调入视图时，需要对数据做更新，就只能在这个方法内实现了。所以这个方法也非常常用。 4) - (void)viewDidAppear:(BOOL)animated； 有时候，由于一些特殊的原因，我们不能在viewWillApper方法里，对视图进行更新。那么可以重写这个方法，在这里对正在显示的视图进行进一步的设置。 5) - (void)viewWillDisappear:(BOOL)animated； 在视图变换时，当前视图在即将被移除、或者被覆盖时，会调用这个方法进行一些善后的处理和设置。 由于在IOS4之后，系统允许将APP在后台挂起，所以在按了Home键之后，系统并不会调用这个方法，因为就这个APP本身而言，APP显示的view，仍是挂起时候的view，所以并不会调用这个方法。 6) - (void)viewDidDisappear:(BOOL)animated； 我们可以重写这个方法，对已经消失，或者被覆盖，或者已经隐藏了的视图做一些其他操作。 上述方法的流程图可以简单用如下表示： 12345运行APP —&gt; 载入视图 —&gt; 调用viewDidLoad方法 —&gt; 调用viewWillAppear方法 —&gt; 调用viewDidAppear方法 —&gt; 正常运行 —&gt;…………..—&gt;释放对象所有权 &lt;— 调用viewDidUnload &lt;— 收到内存警告 &lt;— 调用viewDidDisappear &lt;— 调用viewWillDisappear &lt;— APP需要调用另一个view]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
</search>
