<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>CocoaPods 创建公有库,配置podspec文件</title>
      <link href="/2018/06/19/CocoaPods-%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E5%BA%93-%E9%85%8D%E7%BD%AEpodspec%E6%96%87%E4%BB%B6/"/>
      <url>/2018/06/19/CocoaPods-%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E5%BA%93-%E9%85%8D%E7%BD%AEpodspec%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><blockquote><ul><li>如何创建podspec文件</li><li>如何编写podspec文件</li><li>如何实现目录分层</li><li>如何校验podspec文件</li><li>更新维护</li></ul></blockquote><h3 id="1-如何创建podspec文件"><a href="#1-如何创建podspec文件" class="headerlink" title="1.如何创建podspec文件"></a>1.如何创建podspec文件</h3><p>创建podspec文件只需要一行命令，在你自己的三方库的根目录下输入下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec create XXXKit</span><br></pre></td></tr></table></figure><p>然后在项目目录下将会生成一个podspec文件</p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-19-15256023744797.jpg-style02" alt=""></p><h3 id="2-如何编写podspec文件"><a href="#2-如何编写podspec文件" class="headerlink" title="2.如何编写podspec文件"></a>2.如何编写podspec文件</h3><p>我们先来打开ZJKitTool.podspec文件看看里面的内容。基本都是针对ZJKitTool的描述和介绍</p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-19-15256024482307.jpg-style02" alt=""></p><p>一些常用的信息介绍：</p><blockquote><p>name：框架名<br>version：当前版本（注意，是当前版本，假如你后续更新了新版本，需要修改此处）<br>summary：简要描述，在pod search ZCPKit的时候会显示该信息。<br>description：详细描述<br>homepage：页面链接<br>license：开源协议<br>author：作者<br>source：源码git地址<br>platform：支持最低ios版本<br>source_files：源文件（可以包含.h和.m）<br>public_header_files：头文件(.h文件)<br>resources：资源文件（配置的文件都会被放到mainBundle中）<br>resource_bundles：资源文件（配置的文件会放到你自己指定的bundle中）<br>frameworks：依赖的系统框架<br>vendored_frameworks：依赖的非系统框架<br>libraries：依赖的系统库<br>vendored_libraries：依赖的非系统的静态库<br>dependency：依赖的三方库</p></blockquote><p>上面列举的信息大部分来自pod默认生成的podspec文件中的给的，其中需要重点注意标识黑体的这几个信息。</p><p>你在三方库中看到的那些文件都是通过这些配置来确定的。当<code>pod install</code>引入三方库时，只会引入你在podspec中配置的那些文件。</p><p>下面我会举例说明该如何写podsepc中的每项配置。</p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-19-15256028392850.jpg-style02" alt=""></p><p>如图所示的目录结构，每个配置项的写法如下：</p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-19-15256029266168.jpg-style02" alt=""></p><blockquote><p>source_files：配置三方库的源文件（.h或.m文件）</p></blockquote><blockquote><p>写法：<br>source_files = ‘ZJKitTool/ZJHelperKit.h’ // 直接指定文件名<br>或：<br>source_files = ‘ZJKitTool/<em>.{h,m}’ // ZJKitTool文件夹下的所有匹配文件<br>source_files = ‘ZJKitTool/**/</em>.{h,m}’ // ZJKitTool所有路径下的所有匹配文件<br>public_header_files：配置公有的头文件（.h文件）</p></blockquote><blockquote><p>vendored_frameworks：配置需要引用的非系统框架（*<em>/</em>的写法后面不再赘述）</p></blockquote><blockquote><p>写法：<br>vendored_frameworks = ‘Frameworks/MyFramework.framework’<br>frameworks：配置依赖的系统框架</p></blockquote><blockquote><p>写法：<br>frameworks = ‘AVFoundation’, ‘CoreGraphics’, ‘Security’, ‘SystemConfiguration’<br>vendored_libraries：配置需要引用的非系统静态库（要注意，这里的.a静态库名字必须要带lib前缀，如果引用的静态库名字没lib前缀会导致编译报错，只需要重命名加上即可）</p></blockquote><blockquote><p>写法：<br>vendored_libraries = ‘Frameworks/libZCPKit.a’<br>libraries：配置依赖的系统库（要注意，这里的写法需要忽略lib前缀）</p></blockquote><blockquote><p>写法：<br>libraries = ‘c++’, ‘sqlite3’, ‘stdc++.6.0.9’, ‘z’<br>resources：配置资源文件（.bundle，.png，.txt等资源文件，这些资源文件会被放到mainBundle中，要注意避免发生命名重复的问题）</p></blockquote><blockquote><p>写法：<br>resources = ‘Resources/MyRes.bundle’<br>resource_bundles：配置指定bundle的资源文件（可以解决resources导致的命名冲突问题）</p></blockquote><blockquote><p>写法：<br>resource_bundles = {<br>    ‘ZJKitToolBundle’ =&gt; [‘Resources/MyRes.bundle’],<br>}<br>dependency：依赖的三方库，pod库或者可以是自身的subspec</p></blockquote><p>写法：<br>dependency ‘AFNetworking’, ‘~&gt;3.1.0’ // pod三方库<br>dependency ‘Util’ // 自身的subspec<br>或<br>dependency ‘AFNetworking’<br>附上官网链接，可以去看一看：<a href="http://guides.cocoapods.org/making/specs-and-specs-repo.html" target="_blank" rel="noopener">specs-and-specs-repo</a><br>关于资源文件更详细的写法，可以看这篇文章：<a href="http://blog.xianqu.org/2015/08/pod-resources/" target="_blank" rel="noopener">给 Pod 添加资源文件</a></p><h3 id="3-如何实现目录分层"><a href="#3-如何实现目录分层" class="headerlink" title="3.如何实现目录分层"></a>3.如何实现目录分层</h3><p><strong>使用subspec来实现目录分层。</strong><br>目录分层的好处：</p><blockquote><p>目录分层，结构清晰；<br>使用pod引入一个三方库时，可以只引入一个subspec而不用将整个三方库引入。</p></blockquote><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-19-15256029509992.jpg-style02" alt=""></p><p>如果想有多层的目录结构还可以继续嵌套下去。</p><p>有几个需要注意的地方：</p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-19-15256034665366.jpg-style02" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.层级不能出现循环依赖。</span><br><span class="line"></span><br><span class="line">* 比如类 UIAlertView+ZJHelperKitUIKit.h 中引用#import &quot;NSArray+ZJHelperKit.h&quot;，</span><br><span class="line">同时 NSArray+ZJHelperKit.h中引用 #import &quot;UIAlertView+ZJHelperKitUIKit.h&quot;。</span><br><span class="line">这样当写podspec时就需要在Object层级中写dependency &apos;ZCCategory/UIKit&apos;，在UIKit层级中写dependency &apos;ZCCategory/Object&apos;。如此便存在UIKit与Object层级之间的循环依赖。出现循环依赖时，三方库是无法成功提交到repo上的，会报依赖错误。解决办法是，层级间要尽量解耦。</span><br><span class="line"></span><br><span class="line">2.分层的层级不要太多，层级不要太深。</span><br><span class="line"></span><br><span class="line">为了避免出现上述的循环依赖错误。</span><br><span class="line"></span><br><span class="line">3.source_files使用的是真实的物理路径，而dependency依赖其他层级时使用的是层级路径，不是真实的物理路径</span><br><span class="line"></span><br><span class="line">例如：NSArray+ZJHelperKit.h 文件的真实路径是：ZJKitTool/ZJCategory/Object，而Object层级是属于ZJCategory层级下的一个子subspec，所以当写UIKit层级依赖Object层级时要写：dependency &apos;ZJCategory/Object&apos;而不是dependency &apos;ZJKitTool/ZJCategory/Object&apos;</span><br></pre></td></tr></table></figure><h3 id="4-如何校验podspec文件"><a href="#4-如何校验podspec文件" class="headerlink" title="4.如何校验podspec文件"></a>4.如何校验podspec文件</h3><p>在podspec写好之后我们需要验证一下编写的内容是否有误。可以在命令行的三方库当前路径下使用下面的命令：</p><figure class="highlight plain"><figcaption><span>lib lint （从本地验证你的pod能否通过验证）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint （从本地和远程验证你的pod能否通过验证）</span><br><span class="line"></span><br><span class="line">pod lib lint --verbose （加--verbose可以显示详细的检测过程，出错时会显示详细的错误信息）</span><br><span class="line">pod lib lint --allow-warnings (允许警告，用来解决由于代码中存在警告导致不能通过校验的问题)</span><br><span class="line">pod lib lint --help （查看所有可选参数，可选参数可以加多个）</span><br></pre></td></tr></table></figure><p>我们目前只是在本地写的三方库，所以只需要使用pod lib lint验证即可（这个过程会较为费时，需要稍微等待）。</p><p><strong>需要注意的：</strong><br>在检测的时候会很经常会出现各种乱七八糟的错误，在文件多的情况下不太容易一次通过，并且即使你的代码在Xcode中编译通过了，但是也还是会出现很多错误。所以你需要尽量去注意下面的几个问题：</p><blockquote><p>1.当代码中存在警告时要记得使用–allow-warnings参数。</p></blockquote><blockquote><p>2.如果引入的文件或分好的层级需要依赖系统库或三方库，要记得使用上面介绍的libararies，frameworks等属性。</p></blockquote><blockquote><p>3.如果你的三方库是在一个xcode项目中编写调试，那么尽量不要用pch。</p></blockquote><blockquote><p>因为很多类之间的小依赖会被pch给遮掩过去，这会导致在校验时出现大量错误。<br>4.如果想要分层，那么尽量解耦使模块能够单独存在。</p></blockquote><blockquote><p>原因是当分层较多层级较深时，很可能产生循环依赖的问题。</p></blockquote><h3 id="更新维护"><a href="#更新维护" class="headerlink" title="更新维护"></a>更新维护</h3><p>当你的代码更新维护后，就需要重写发布，流程是：</p><p>更新ZJKitTool.podspec中的版本号<br>打上标签推送远程<br>pod trunk push ZJKitTool.podspec 推送到pods仓库</p><p>如果有引用到库framwork或C语言库的话必须使用<br> –use-libraries </p><p> –allow-warnings 允许警告</p><p> 检测本地与远程是否通过</p><p> pod spec lint –allow-warnings</p><p>pod spec lint ZJKitTool.podspec –use-libraries –allow-warnings</p><p>检测本地与是否通过<br>pod lib lint –allow-warnings</p><p>pod lib lint ZJKitTool.podspec –use-libraries –allow-warnings</p><p>上传到 cocoapods<br>pod trunk push ZJKitTool.podspec  –use-libraries –allow-warnings           </p><p>必须保证github上有上传框架代码和示例代码，同时保证统一和上传tag版本<br><strong>–use-libraries</strong>  (有引用框架时，需加入 <strong>–use-libraries</strong>)</p><p>最后回到项目的根目录 pod update 更新最新版本</p>]]></content>
      
      <categories>
          
          <category> CocoaPods </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocoaPods </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 UIBezierPath学习</title>
      <link href="/2018/06/16/iOS%E5%BC%80%E5%8F%91-UIBezierPath%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/06/16/iOS%E5%BC%80%E5%8F%91-UIBezierPath%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h3 id="一、属性"><a href="#一、属性" class="headerlink" title="一、属性"></a>一、属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将UIBezierPath类转换成CGPath，类似于UIColor的CGColor</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGPathRef</span> <span class="built_in">CGPath</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// empty：只读类型，路径上是否有有效的元素</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>,<span class="keyword">getter</span>=isEmpty) <span class="built_in">BOOL</span> empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bounds：和view的bounds是不一样的，它获取path的X坐标、Y坐标、宽度，但是高度为0</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">CGRect</span> bounds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// currentPoint：当前path的位置，可以理解为path的终点</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">CGPoint</span> currentPoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lineWidth：path线的宽度</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> lineWidth;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lineCapStylepath端点样式，有3种样式</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGLineCap</span> lineCapStyle;</span><br><span class="line"><span class="comment">/* Line cap styles. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_ENUM</span>(int32_t, <span class="built_in">CGLineCap</span>) &#123;</span><br><span class="line">    kCGLineCapButt,     <span class="comment">// 无端点</span></span><br><span class="line">    kCGLineCapRound,    <span class="comment">// 圆形端点</span></span><br><span class="line">    kCGLineCapSquare    <span class="comment">// 方形端点（样式上和kCGLineCapButt是一样的，但是比kCGLineCapButt长一点）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拐角样式</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGLineJoin</span> lineJoinStyle;</span><br><span class="line"><span class="comment">/* Line join styles. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_ENUM</span>(int32_t, <span class="built_in">CGLineJoin</span>) &#123;</span><br><span class="line">    kCGLineJoinMiter,       <span class="comment">// 尖角</span></span><br><span class="line">    kCGLineJoinRound,       <span class="comment">// 圆角</span></span><br><span class="line">    kCGLineJoinBevel        <span class="comment">// 缺角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// miterLimit:最大斜接长度（只有在使用kCGLineJoinMiter是才有效）， 边角的角度越小，斜接长度就会越大</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> miterLimit; <span class="comment">// Used when lineJoinStyle is kCGLineJoinMiter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// flatness:弯曲路径的渲染精度，默认为0.6，越小精度越高，相应的更加消耗性能。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> flatness;</span><br><span class="line"></span><br><span class="line"><span class="comment">//usesEvenOddFillRule：单双数圈规则是否用于绘制路径，默认是NO。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> usesEvenOddFillRule; <span class="comment">// Default is NO. When YES, the even-odd fill rule is used for drawing, clipping, and hit testing.</span></span><br></pre></td></tr></table></figure><h3 id="二、UIBezierPath创建方法"><a href="#二、UIBezierPath创建方法" class="headerlink" title="二、UIBezierPath创建方法"></a>二、UIBezierPath创建方法</h3><h4 id="1、实例化UIBezierPath对象-instancetype-bezierPath"><a href="#1、实例化UIBezierPath对象-instancetype-bezierPath" class="headerlink" title="1、实例化UIBezierPath对象 + (instancetype)bezierPath;"></a>1、实例化UIBezierPath对象 <code>+ (instancetype)bezierPath;</code></h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、-在Rect里面画一个矩形"><a href="#2、-在Rect里面画一个矩形" class="headerlink" title="2、 在Rect里面画一个矩形"></a>2、 在Rect里面画一个矩形</h4><p><code>+ (instancetype)bezierPathWithRect:(CGRect)rect;</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path1 = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span>)];</span><br><span class="line">    [[<span class="built_in">UIColor</span> orangeColor] set];</span><br><span class="line">    path1.lineWidth = <span class="number">3</span>;</span><br><span class="line">    [path1 stroke];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-16-15290492725497.jpg-style02" alt=""></p><h4 id="3-在rect里的画一个内切曲线"><a href="#3-在rect里的画一个内切曲线" class="headerlink" title="3.在rect里的画一个内切曲线:"></a>3.在rect里的画一个内切曲线:</h4><p><code>+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path2 = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">180</span>, <span class="number">100</span>)];</span><br><span class="line">    [[<span class="built_in">UIColor</span> orangeColor] set];</span><br><span class="line">    path2.lineWidth = <span class="number">3</span>;</span><br><span class="line">    [path2 stroke];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-16-15290493826030.jpg-style02" alt=""></p><h4 id="3-根据一个Rect-画一个圆角矩形曲线-Radius-圆角半径-当Rect为正方形时且Radius等于边长一半时画的是一个圆"><a href="#3-根据一个Rect-画一个圆角矩形曲线-Radius-圆角半径-当Rect为正方形时且Radius等于边长一半时画的是一个圆" class="headerlink" title="3.根据一个Rect 画一个圆角矩形曲线 (Radius:圆角半径)   当Rect为正方形时且Radius等于边长一半时画的是一个圆"></a>3.根据一个Rect 画一个圆角矩形曲线 (Radius:圆角半径)   当Rect为正方形时且Radius等于边长一半时画的是一个圆</h4><p><code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius;</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    rect = <span class="built_in">CGRectMake</span>(<span class="number">130</span>,<span class="number">100</span>, <span class="number">150</span>,<span class="number">90</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path3 = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:rect cornerRadius:<span class="number">8</span>];</span><br><span class="line">    [[<span class="built_in">UIColor</span> blueColor] set];</span><br><span class="line">    [path3 fill];</span><br><span class="line">    path3.lineWidth = <span class="number">3</span>;</span><br><span class="line">    [[<span class="built_in">UIColor</span> redColor] set];</span><br><span class="line">    [path3 stroke];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-16-15290496271092.jpg-style02" alt=""></p><h4 id="4-根据Rect针对四角中的某个或多个角设置圆角"><a href="#4-根据Rect针对四角中的某个或多个角设置圆角" class="headerlink" title="4.根据Rect针对四角中的某个或多个角设置圆角"></a>4.根据Rect针对四角中的某个或多个角设置圆角</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  参数：</span></span><br><span class="line"><span class="comment"> *  rect-&gt;矩形的Frame</span></span><br><span class="line"><span class="comment"> *　corners-&gt;指定的圆角</span></span><br><span class="line"><span class="comment"> *　cornerRadii-&gt;圆角的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)bezierPathWithRoundedRect:(<span class="built_in">CGRect</span>)rect byRoundingCorners:(<span class="built_in">UIRectCorner</span>)corners cornerRadii:(<span class="built_in">CGSize</span>)cornerRadii;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"></span><br><span class="line">    rect = <span class="built_in">CGRectMake</span>(<span class="number">130</span>,<span class="number">100</span>, <span class="number">150</span>,<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path4 = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:rect byRoundingCorners: <span class="built_in">UIRectCornerTopLeft</span>|<span class="built_in">UIRectCornerBottomRight</span> cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">10</span>,<span class="number">50</span>)];</span><br><span class="line">    [[<span class="built_in">UIColor</span> purpleColor] set];</span><br><span class="line">    [path4 fill];</span><br><span class="line">    [[<span class="built_in">UIColor</span> yellowColor] set];</span><br><span class="line">    [path4 stroke];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-16-15290500921401.jpg-style02" alt=""></p><h4 id="5-以某个中心点画弧线"><a href="#5-以某个中心点画弧线" class="headerlink" title="5.以某个中心点画弧线"></a>5.以某个中心点画弧线</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  参数：</span></span><br><span class="line"><span class="comment"> *  center-&gt;圆点</span></span><br><span class="line"><span class="comment"> *　radius-&gt;半径</span></span><br><span class="line"><span class="comment"> *　startAngle-&gt;起始位置</span></span><br><span class="line"><span class="comment"> *　endAngle-&gt;结束位置</span></span><br><span class="line"><span class="comment"> *　clockwise-&gt;是否顺时针方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)bezierPathWithArcCenter:(<span class="built_in">CGPoint</span>)center radius:(<span class="built_in">CGFloat</span>)radius startAngle:(<span class="built_in">CGFloat</span>)startAngle endAngle:(<span class="built_in">CGFloat</span>)endAngle clockwise:(<span class="built_in">BOOL</span>)clockwise;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path5 = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="built_in">CGPointMake</span>(<span class="number">180</span>, <span class="number">180</span>) radius:<span class="number">100</span> startAngle:<span class="number">0</span> endAngle:<span class="number">90</span> clockwise:<span class="literal">YES</span>];</span><br><span class="line">    [[<span class="built_in">UIColor</span> purpleColor] set];</span><br><span class="line">    [path5 fill];</span><br><span class="line">    path5.lineWidth = <span class="number">3</span>;</span><br><span class="line">    [[<span class="built_in">UIColor</span> orangeColor] set];</span><br><span class="line">    [path5 stroke];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-16-15290800782036.jpg-style02" alt=""></p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-16-15290503333241.jpg-style02" alt=""></p><h4 id="6-根据CGPath创建并返回一个新的UIBezierPath对象"><a href="#6-根据CGPath创建并返回一个新的UIBezierPath对象" class="headerlink" title="6.根据CGPath创建并返回一个新的UIBezierPath对象"></a>6.根据CGPath创建并返回一个新的UIBezierPath对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)bezierPathWithCGPath:(<span class="built_in">CGPathRef</span>)<span class="built_in">CGPath</span></span><br></pre></td></tr></table></figure><h4 id="7-建并返回一个新的BezierPath-这个-BezierPath-的方向是原-BezierPath-的反方向"><a href="#7-建并返回一个新的BezierPath-这个-BezierPath-的方向是原-BezierPath-的反方向" class="headerlink" title="7.建并返回一个新的BezierPath, 这个 BezierPath 的方向是原 BezierPath 的反方向"></a>7.建并返回一个新的BezierPath, 这个 BezierPath 的方向是原 BezierPath 的反方向</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 通过该方法反转一条路径, 并不会修改该路径的样子. 它仅仅是修改了绘制的方向</span></span><br><span class="line"><span class="comment">  * @return: 返回一个新的 UIBezierPath 对象, 形状和原来路径的形状一样,</span></span><br><span class="line"><span class="comment">  *          但是绘制的方向相反.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="built_in">UIBezierPath</span> *) bezierPathByReversingPath;</span><br></pre></td></tr></table></figure><h3 id="三、构造路径"><a href="#三、构造路径" class="headerlink" title="三、构造路径"></a>三、构造路径</h3><h4 id="1-将-UIBezierPath-对象的-currentPoint-移动到指定的点"><a href="#1-将-UIBezierPath-对象的-currentPoint-移动到指定的点" class="headerlink" title="1.将 UIBezierPath 对象的 currentPoint 移动到指定的点"></a>1.将 UIBezierPath 对象的 currentPoint 移动到指定的点</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 如果当前有正在绘制的子路径, 该方法则会隐式的结束当前路径, </span></span><br><span class="line"><span class="comment">  * 并将 currentPoint 设置为指定点. 当上一条子路径被终止, 该方法</span></span><br><span class="line"><span class="comment">  * 实际上并不会去闭合上一条子路径. 所以上一条自路径的起始点 和</span></span><br><span class="line"><span class="comment">  * 结束点并没有被链接.</span></span><br><span class="line"><span class="comment">  * 对于大多数构造路径相关的方法而言, 在你绘制直线或曲线之前, 需要先调用这个方法.</span></span><br><span class="line"><span class="comment">  * @param point:   当前坐标系统中的某一点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)moveToPoint:(<span class="built_in">CGPoint</span>)point;</span><br></pre></td></tr></table></figure><h4 id="2-在当前子路径中追加一条直线"><a href="#2-在当前子路径中追加一条直线" class="headerlink" title="2.在当前子路径中追加一条直线"></a>2.在当前子路径中追加一条直线</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该方法将会从 currentPoint 到 指定点 链接一条直线. </span></span><br><span class="line"><span class="comment">  * Note: 在追加完这条直线后, 该方法将会更新 currentPoint 为 指定点</span></span><br><span class="line"><span class="comment">  *       调用该方法之前, 你必须先设置 currentPoint. 如果当前绘制路径</span></span><br><span class="line"><span class="comment">  *       为空, 并且未设置 currentPoint, 那么调用该方法将不会产生任何</span></span><br><span class="line"><span class="comment">  *       效果.</span></span><br><span class="line"><span class="comment">  * @param point:   绘制直线的终点坐标, 当前坐标系统中的某一点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)addLineToPoint:(<span class="built_in">CGPoint</span>)point;</span><br></pre></td></tr></table></figure><h4 id="3-在当前子路径中追加一条圆弧"><a href="#3-在当前子路径中追加一条圆弧" class="headerlink" title="3.在当前子路径中追加一条圆弧"></a>3.在当前子路径中追加一条圆弧</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该方法将会从 currentPoint 添加一条指定的圆弧.</span></span><br><span class="line"><span class="comment">  * 该方法的介绍和构造方法中的一样. 请前往上文查看</span></span><br><span class="line"><span class="comment">  * @param center: 圆心</span></span><br><span class="line"><span class="comment">  * @param radius: 半径</span></span><br><span class="line"><span class="comment">  * @param startAngle: 起始角度</span></span><br><span class="line"><span class="comment">  * @param endAngle: 结束角度</span></span><br><span class="line"><span class="comment">  * @param clockwise: 是否顺时针绘制</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)addArcWithCenter:(<span class="built_in">CGPoint</span>)center </span><br><span class="line">                  radius:(<span class="built_in">CGFloat</span>)radius </span><br><span class="line">              startAngle:(<span class="built_in">CGFloat</span>)startAngle </span><br><span class="line">                endAngle:(<span class="built_in">CGFloat</span>)endAngle </span><br><span class="line">               clockwise:(<span class="built_in">BOOL</span>)clockwise <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_0);</span><br></pre></td></tr></table></figure><h4 id="4-在当前-子路经中追加一条-三次贝塞尔曲线"><a href="#4-在当前-子路经中追加一条-三次贝塞尔曲线" class="headerlink" title="4.在当前 子路经中追加一条 三次贝塞尔曲线"></a>4.在当前 子路经中追加一条 三次贝塞尔曲线</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该方法将会从 currentPoint 到 指定的 endPoint 追加一条三次贝塞尔曲线.</span></span><br><span class="line"><span class="comment">  * 三次贝塞尔曲线的弯曲由两个控制点来控制. 如下图所示</span></span><br><span class="line"><span class="comment">  * Note: 调用该方法前, 你必须先设置 currentPoint, 如果路径为空, </span></span><br><span class="line"><span class="comment">  *       并且尚未设置 currentPoint, 调用该方法则不会产生任何效果. </span></span><br><span class="line"><span class="comment">  *       当添加完贝塞尔曲线后, 该方法将会自动更新 currentPoint 为</span></span><br><span class="line"><span class="comment">  *       指定的结束点</span></span><br><span class="line"><span class="comment">  * @param endPoint: 终点</span></span><br><span class="line"><span class="comment">  * @param controlPoint1: 控制点1</span></span><br><span class="line"><span class="comment">  * @param controlPoint2: 控制点2</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)addCurveToPoint:(<span class="built_in">CGPoint</span>)endPoint </span><br><span class="line">          controlPoint1:(<span class="built_in">CGPoint</span>)controlPoint1 </span><br><span class="line">          controlPoint2:(<span class="built_in">CGPoint</span>)controlPoint2;</span><br></pre></td></tr></table></figure><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-16-15290805456435.jpg-style02" alt="图片摘自苹果官网"></p><h4 id="5-当前-子路经中追加一条-二次贝塞尔曲线"><a href="#5-当前-子路经中追加一条-二次贝塞尔曲线" class="headerlink" title="5.当前 子路经中追加一条 二次贝塞尔曲线"></a>5.当前 子路经中追加一条 二次贝塞尔曲线</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该方法将会从 currentPoint 到 指定的 endPoint 追加一条二次贝塞尔曲线.</span></span><br><span class="line"><span class="comment">  * currentPoint、endPoint、controlPoint 三者的关系最终定义了二次贝塞尔曲线的形状.</span></span><br><span class="line"><span class="comment">  * 二次贝塞尔曲线的弯曲由一个控制点来控制. 如下图所示</span></span><br><span class="line"><span class="comment">  * Note: 调用该方法前, 你必须先设置 currentPoint, 如果路径为空, </span></span><br><span class="line"><span class="comment">  *       并且尚未设置 currentPoint, 调用该方法则不会产生任何效果. </span></span><br><span class="line"><span class="comment">  *       当添加完贝塞尔曲线后, 该方法将会自动更新 currentPoint 为</span></span><br><span class="line"><span class="comment">  *       指定的结束点</span></span><br><span class="line"><span class="comment">  * @param endPoint: 终点</span></span><br><span class="line"><span class="comment">  * @param controlPoint: 控制点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)addQuadCurveToPoint:(<span class="built_in">CGPoint</span>)endPoint </span><br><span class="line">               controlPoint:(<span class="built_in">CGPoint</span>)controlPoint;</span><br></pre></td></tr></table></figure><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-06-16-15290806246756.jpg-style02" alt="图片摘自苹果官网"></p><h4 id="6-关闭当前子路经"><a href="#6-关闭当前子路经" class="headerlink" title="6.关闭当前子路经"></a>6.关闭当前子路经</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该方法将会从 currentPoint 到子路经的起点 绘制一条直线, </span></span><br><span class="line"><span class="comment">  * 以此来关闭当前的自路径. 紧接着该方法将会更新 currentPoint</span></span><br><span class="line"><span class="comment">  * 为 刚添加的这条直线的终点, 也就是当前子路经的起点.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)closePath;</span><br></pre></td></tr></table></figure><h4 id="7-删除-UIBezierPath-对象中的所有点-效果也就等同于删除了所有子路经"><a href="#7-删除-UIBezierPath-对象中的所有点-效果也就等同于删除了所有子路经" class="headerlink" title="7.删除 UIBezierPath 对象中的所有点, 效果也就等同于删除了所有子路经"></a>7.删除 UIBezierPath 对象中的所有点, 效果也就等同于删除了所有子路经</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeAllPoints;</span><br><span class="line">将指定 <span class="built_in">UIBezierPath</span> 中的内容添加到当前 <span class="built_in">UIBezierPath</span> 对象中</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该方法将会在当前 UIBezierPath 对象的路径中追加</span></span><br><span class="line"><span class="comment">  * 指定的 UIBezierPath 对象中的内容. </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)appendPath:(<span class="built_in">UIBezierPath</span> *)bezierPath;</span><br></pre></td></tr></table></figure><h4 id="8-UIBezierPath-中的-CGPath-对象"><a href="#8-UIBezierPath-中的-CGPath-对象" class="headerlink" title="8.UIBezierPath 中的 CGPath 对象"></a>8.UIBezierPath 中的 CGPath 对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取这个属性, 你将会获得一个不可变的 CGPathRef 对象,</span></span><br><span class="line"><span class="comment">  * 他可以传入 CoreGraphics 提供的函数中</span></span><br><span class="line"><span class="comment">  * 你可以是用 CoreGraphics 框架提供的方法创建一个路径, </span></span><br><span class="line"><span class="comment">  * 并给这个属性赋值, 当时设置了一个新的路径后, </span></span><br><span class="line"><span class="comment">  * 这个将会对你给出的路径对象进行 Copy 操作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGPathRef</span> <span class="built_in">CGPath</span>;</span><br></pre></td></tr></table></figure><h4 id="9-绘图路径中的当前点"><a href="#9-绘图路径中的当前点" class="headerlink" title="9.绘图路径中的当前点"></a>9.绘图路径中的当前点</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该属性的值, 将会是下一条绘制的直线或曲线的起始点.</span></span><br><span class="line"><span class="comment">  * 如果当前路径为空, 那么该属性的值将会是 CGPointZero</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGPoint</span> currentPoint;</span><br></pre></td></tr></table></figure><p>五、绘制路径</p><h4 id="1-填充路径"><a href="#1-填充路径" class="headerlink" title="1.填充路径"></a>1.填充路径</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该方法当前的填充颜色 和 绘图属性对路径的封闭区域进行填充.</span></span><br><span class="line"><span class="comment">  * 如果当前路径是一条开放路径, 该方法将会隐式的将路径进行关闭后进行填充</span></span><br><span class="line"><span class="comment">  * 该方法在进行填充操作之前, 会自动保存当前绘图的状态, 所以我们不需要</span></span><br><span class="line"><span class="comment">  * 自己手动的去保存绘图状态了. </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)fill;</span><br></pre></td></tr></table></figure><h4 id="2-使用混合模式进行填充"><a href="#2-使用混合模式进行填充" class="headerlink" title="2.使用混合模式进行填充"></a>2.使用混合模式进行填充</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该方法当前的填充颜色 和 绘图属性 (外加指定的混合模式 和 透明度) </span></span><br><span class="line"><span class="comment">  * 对路径的封闭区域进行填充. 如果当前路径是一条开放路径, 该方法将</span></span><br><span class="line"><span class="comment">  * 会隐式的将路径进行关闭后进行填充</span></span><br><span class="line"><span class="comment">  * 该方法在进行填充操作之前, 会自动保存当前绘图的状态, 所以我们不需要</span></span><br><span class="line"><span class="comment">  * 自己手动的去保存绘图状态了. </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param blendMode: 混合模式决定了如何和已经存在的被渲染过的内容进行合成</span></span><br><span class="line"><span class="comment">  * @param alpha: 填充路径时的透明度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)fillWithBlendMode:(<span class="built_in">CGBlendMode</span>)blendMode </span><br><span class="line">                    alpha:(<span class="built_in">CGFloat</span>)alpha;</span><br><span class="line"> ```                   </span><br><span class="line">                    </span><br><span class="line"><span class="meta">#### 3.绘制路径</span></span><br><span class="line"></span><br><span class="line">``` Objc</span><br><span class="line">- (<span class="keyword">void</span>)stroke;</span><br></pre></td></tr></table></figure><h4 id="4-使用混合模式进行填充"><a href="#4-使用混合模式进行填充" class="headerlink" title="4.使用混合模式进行填充"></a>4.使用混合模式进行填充</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @param blendMode: 混合模式决定了如何和已经存在的被渲染过的内容进行合成</span></span><br><span class="line"><span class="comment">  * @param alpha: 填充路径时的透明度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)strokeWithBlendMode:(<span class="built_in">CGBlendMode</span>)blendMode</span><br><span class="line">                      alpha:(<span class="built_in">CGFloat</span>)alpha;</span><br></pre></td></tr></table></figure><h4 id="5-剪切路径"><a href="#5-剪切路径" class="headerlink" title="5.剪切路径"></a>5.剪切路径</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  该方法将会修改当前绘图上下文的可视区域.</span></span><br><span class="line"><span class="comment">  *  当调用这个方法之后, 会导致接下来所有的渲染</span></span><br><span class="line"><span class="comment">  *  操作, 只会在剪切下来的区域内进行, 区域外的</span></span><br><span class="line"><span class="comment">  *  内容将不会被渲染.</span></span><br><span class="line"><span class="comment">  *  如果你希望执行接下来的绘图时, 删除剪切区域,</span></span><br><span class="line"><span class="comment">  *  那么你必须在调用该方法前, 先使用 CGContextSaveGState 方法</span></span><br><span class="line"><span class="comment">  *  保存当前的绘图状态, 当你不再需要这个剪切区域</span></span><br><span class="line"><span class="comment">  *  的时候, 你只需要使用 CGContextRestoreGState 方法</span></span><br><span class="line"><span class="comment">  *  来恢复之前保存的绘图状态就可以了.</span></span><br><span class="line"><span class="comment">  * @param blendMode: 混合模式决定了如何和</span></span><br><span class="line"><span class="comment">  *                   已经存在的被渲染过的内容进行合成</span></span><br><span class="line"><span class="comment">  * @param alpha: 填充路径时的透明度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)addClip;</span><br></pre></td></tr></table></figure><h3 id="六、Hit-Detection"><a href="#六、Hit-Detection" class="headerlink" title="六、Hit Detection"></a>六、Hit Detection</h3><h4 id="1-是否包含某个点"><a href="#1-是否包含某个点" class="headerlink" title="1.是否包含某个点"></a>1.是否包含某个点</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  该方法返回一个布尔值, 当曲线的覆盖区域包含</span></span><br><span class="line"><span class="comment">  * 指定的点(内部点)， 则返回 YES, 否则返回 NO. </span></span><br><span class="line"><span class="comment">  * Note: 如果当前的路径是一个开放的路径, 那么</span></span><br><span class="line"><span class="comment">  *       就算指定点在路径覆盖范围内, 该方法仍然会</span></span><br><span class="line"><span class="comment">  *       返回 NO, 所以如果你想判断一个点是否在一个</span></span><br><span class="line"><span class="comment">  *       开放路径的范围内时, 你需要先Copy一份路径,</span></span><br><span class="line"><span class="comment">  *       并调用 -(void)closePath; 将路径封闭, 然后</span></span><br><span class="line"><span class="comment">  *       再调用此方法来判断指定点是否是内部点.</span></span><br><span class="line"><span class="comment">  * @param point: 指定点.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>) containsPoint:(<span class="built_in">CGPoint</span>)point;</span><br></pre></td></tr></table></figure><h4 id="2-路径是否为空"><a href="#2-路径是否为空" class="headerlink" title="2.路径是否为空"></a>2.路径是否为空</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 检测当前路径是否绘制过直线或曲线.</span></span><br><span class="line"><span class="comment">  * Note: 记住, 就算你仅仅调用了 moveToPoint 方法</span></span><br><span class="line"><span class="comment">  *       那么当前路径也被看做不为空.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isEmpty) <span class="built_in">BOOL</span> empty;</span><br></pre></td></tr></table></figure><h4 id="3-路径覆盖的矩形区域"><a href="#3-路径覆盖的矩形区域" class="headerlink" title="3.路径覆盖的矩形区域"></a>3.路径覆盖的矩形区域</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该属性描述的是一个能够完全包含路径中所有点</span></span><br><span class="line"><span class="comment">  *  的一个最小的矩形区域. 该区域包含二次贝塞尔</span></span><br><span class="line"><span class="comment">  *  曲线和三次贝塞尔曲线的控制点.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGRect</span> bounds;</span><br></pre></td></tr></table></figure><h4 id="4-Apply-Transform"><a href="#4-Apply-Transform" class="headerlink" title="4.Apply Transform"></a>4.Apply Transform</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该方法将会直接对路径中的所有点进行指定的放射</span></span><br><span class="line"><span class="comment">  * 变换操作. </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">- (<span class="keyword">void</span>)applyTransform:(<span class="built_in">CGAffineTransform</span>)transform;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UIBezierPath </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发NSString详解</title>
      <link href="/2018/06/13/iOS%E5%BC%80%E5%8F%91NSString%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/06/13/iOS%E5%BC%80%E5%8F%91NSString%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>NSString 是Foundation框架下的一个处理字符串的类，也是我们平常开发过程中使用的比较多的类。</p><h3 id="二、详解"><a href="#二、详解" class="headerlink" title="二、详解"></a>二、详解</h3><h4 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h4><p><code>@property (readonly) NSUInteger length;</code></p><p>length 文本长度，只读。</p><h4 id="2-字符串的获取"><a href="#2-字符串的获取" class="headerlink" title="2.字符串的获取"></a>2.字符串的获取</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 为了避免像表情符号这样的字符序列被破坏，你可以这么做:</span></span><br><span class="line"><span class="comment">    [str substringFromIndex:[str rangeOfComposedCharacterSequenceAtIndex:index].location]</span></span><br><span class="line"><span class="comment">    [str substringToIndex:NSMaxRange([str rangeOfComposedCharacterSequenceAtIndex:index])]</span></span><br><span class="line"><span class="comment">    [str substringWithRange:[str rangeOfComposedCharacterSequencesForRange:range]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//截取指定位置之后的字符串</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)substringFromIndex:(<span class="built_in">NSUInteger</span>)from;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从0下标开始截取到指定位置的字符串  </span></span><br><span class="line">- (<span class="built_in">NSString</span> *)substringToIndex:(<span class="built_in">NSUInteger</span>)to;</span><br><span class="line"></span><br><span class="line"><span class="comment">//截取指定范围的字符串  </span></span><br><span class="line">- (<span class="built_in">NSString</span> *)substringWithRange:(<span class="built_in">NSRange</span>)range;            </span><br><span class="line"></span><br><span class="line"><span class="comment">//截取字符串指定范围的字符 </span></span><br><span class="line">- (<span class="keyword">void</span>)getCharacters:(<span class="keyword">unichar</span> *)buffer range:(<span class="built_in">NSRange</span>)range;</span><br></pre></td></tr></table></figure><h4 id="3-字符串的比较"><a href="#3-字符串的比较" class="headerlink" title="3.字符串的比较"></a>3.字符串的比较</h4><h5 id="3-1用NSComparisonResult作为比较返回结果的方法："><a href="#3-1用NSComparisonResult作为比较返回结果的方法：" class="headerlink" title="3.1用NSComparisonResult作为比较返回结果的方法："></a>3.1用<code>NSComparisonResult</code>作为比较返回结果的方法：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在compare:方法中，range参数指定要在比较中使用的接收者的子例程，而不是整个。范围不应用于搜索字符串。</span></span><br><span class="line"><span class="comment">例如，[@“AB”compare:@“ABC”选项:0 range:NSMakeRange(0,1)]将“A”与“ABC”进行比较，</span></span><br><span class="line"><span class="comment">而不是“A”与“A”，并返回nsordered升序。指定超出接收方界限的范围是错误的，可能会引发异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSString</span> *)string;</span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSString</span> *)string options:(<span class="built_in">NSStringCompareOptions</span>)mask;</span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSString</span> *)string options:(<span class="built_in">NSStringCompareOptions</span>)mask range:(<span class="built_in">NSRange</span>)rangeOfReceiverToCompare;</span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSString</span> *)string options:(<span class="built_in">NSStringCompareOptions</span>)mask range:(<span class="built_in">NSRange</span>)rangeOfReceiverToCompare locale:(<span class="keyword">nullable</span> <span class="keyword">id</span>)locale; <span class="comment">// locale arg used to be a dictionary pre-Leopard. We now accept NSLocale. Assumes the current locale if non-nil and non-NSLocale. nil continues to mean canonical compare, which doesn't depend on user's locale choice.</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)caseInsensitiveCompare:(<span class="built_in">NSString</span> *)string;</span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)localizedCompare:(<span class="built_in">NSString</span> *)string;</span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)localizedCaseInsensitiveCompare:(<span class="built_in">NSString</span> *)string;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* localizedStandardCompare:，在10.6中添加，当文件名或其他字符串出现在列表和表中时，应该使用它，在那里类似查找器的排序是合适的。</span></span><br><span class="line"><span class="comment">这个方法的确切行为可以在以后的版本中进行调整，并且在不同的本地化下会有所不同，因此客户机不应该依赖于字符串的精确排序顺序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)localizedStandardCompare:(<span class="built_in">NSString</span> *)string API_AVAILABLE(macos(<span class="number">10.6</span>), ios(<span class="number">4.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br></pre></td></tr></table></figure><p>返回的结果NScomparisonResult:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSComparisonResult</span>) &#123;</span><br><span class="line"><span class="built_in">NSOrderedAscending</span> = <span class="number">-1</span>L,   <span class="comment">// 递增</span></span><br><span class="line"><span class="built_in">NSOrderedSame</span>,              <span class="comment">// 相等</span></span><br><span class="line"><span class="built_in">NSOrderedDescending</span>         <span class="comment">// 递减</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参数类型 NSStringCompareOptions：</p><blockquote><p>NSCaseInsensitiveSearch      不区分大小写比较<br>NSLiteralSearch    区分大小写比较<br>NSBackwardsSearch    从字符串末尾开始搜索<br>NSAnchoredSearch    搜索限制范围的字符串<br>NSNumericSearch    按照字符串里的数字为依据，算出顺序<br>NSDiacriticInsensitiveSearch    忽略 “-“ 符号的比较<br>NSWidthInsensitiveSearch    忽略字符串的长度，比较出结果<br>NSForcedOrderingSearch    忽略不区分大小写比较的选项<br>NSRegularExpressionSearch    只能应用于 rangeOfString:…, stringByReplacingOccurrencesOfString:…和 replaceOccurrencesOfString:…方法</p></blockquote><p>比较原理:</p><p>如果没有调用option的方法，比较是从两个字符串的第一个字母开始一一对比，相同则比较下一个，不同则返回结果为升序或者降序，两个比较字符串建议长度一致，不一致也可以比较，比如：</p><p>@”agc” compare @” ab” //返回降序， </p><p>@”abc” compare @”gd” //比较第一个字母之后就返回升序</p><p>参数range；</p><p>是决定前一个比较对象所需比较的范围。</p><h5 id="3-2使用isEqualToString比较是否相等"><a href="#3-2使用isEqualToString比较是否相等" class="headerlink" title="3.2使用isEqualToString比较是否相等"></a>3.2使用<code>isEqualToString</code>比较是否相等</h5><p><code>-(BOOL)isEqualToString:(NSString *)aString;</code></p><h4 id="4-字符串检索"><a href="#4-字符串检索" class="headerlink" title="4.字符串检索"></a>4.字符串检索</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////搜索基本//////////  </span></span><br><span class="line"><span class="comment">//1.是否包含前缀(以str开头)  </span></span><br><span class="line">- (<span class="built_in">BOOL</span>)hasPrefix:(<span class="built_in">NSString</span> *)str;  </span><br><span class="line"><span class="comment">//2.是否包含后缀(以str结尾)  </span></span><br><span class="line">- (<span class="built_in">BOOL</span>)hasSuffix:(<span class="built_in">NSString</span> *)str;  </span><br><span class="line"><span class="comment">//3.获取公共前缀  </span></span><br><span class="line">- (<span class="built_in">NSString</span> *)commonPrefixWithString:(<span class="built_in">NSString</span> *)str options:(<span class="built_in">NSStringCompareOptions</span>)mask;  </span><br><span class="line"><span class="comment">//4.是否包含字符串  </span></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsString:(<span class="built_in">NSString</span> *)str;  </span><br><span class="line"><span class="comment">//5.本地化是否包含字符串(不区分大小写)  </span></span><br><span class="line">- (<span class="built_in">BOOL</span>)localizedCaseInsensitiveContainsString:(<span class="built_in">NSString</span> *)str;  </span><br><span class="line"><span class="comment">//6.本地化是否包含字符串(标准)  </span></span><br><span class="line">- (<span class="built_in">BOOL</span>)localizedStandardContainsString:(<span class="built_in">NSString</span> *)str;  </span><br><span class="line"><span class="comment">//7.本地化搜索字符串范围(标准)  </span></span><br><span class="line">- (<span class="built_in">NSRange</span>)localizedStandardRangeOfString:(<span class="built_in">NSString</span> *)str;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">//////////搜索字符串//////////  </span></span><br><span class="line"><span class="comment">//8.搜索(指定字符串)  </span></span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfString:(<span class="built_in">NSString</span> *)searchString;  </span><br><span class="line"><span class="comment">//9.搜索(指定字符串,条件)  </span></span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfString:(<span class="built_in">NSString</span> *)searchString options:(<span class="built_in">NSStringCompareOptions</span>)mask;  </span><br><span class="line"><span class="comment">//10.搜索(指定字符串,条件,范围)  </span></span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfString:(<span class="built_in">NSString</span> *)searchString options:(<span class="built_in">NSStringCompareOptions</span>)mask range:(<span class="built_in">NSRange</span>)searchRange;  </span><br><span class="line"><span class="comment">//11.搜索(指定字符串,条件,范围,本地化)  </span></span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfString:(<span class="built_in">NSString</span> *)searchString options:(<span class="built_in">NSStringCompareOptions</span>)mask range:(<span class="built_in">NSRange</span>)searchRange locale:(<span class="keyword">nullable</span> <span class="built_in">NSLocale</span> *)locale;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">//////////搜索字符集合//////////  </span></span><br><span class="line"><span class="comment">//12.搜索(指定字符集合)  </span></span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfCharacterFromSet:(<span class="built_in">NSCharacterSet</span> *)searchSet;  </span><br><span class="line"><span class="comment">//13.搜索(指定字符集合,条件)  </span></span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfCharacterFromSet:(<span class="built_in">NSCharacterSet</span> *)searchSet options:(<span class="built_in">NSStringCompareOptions</span>)mask;  </span><br><span class="line"><span class="comment">//14.搜索(指定字符集合,条件,范围)  </span></span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfCharacterFromSet:(<span class="built_in">NSCharacterSet</span> *)searchSet options:(<span class="built_in">NSStringCompareOptions</span>)mask range:(<span class="built_in">NSRange</span>)searchRange;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//15.用字符串的字符编码指定索引查找位置  </span></span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfComposedCharacterSequenceAtIndex:(<span class="built_in">NSUInteger</span>)index;  </span><br><span class="line"><span class="comment">//16.用字符串的字符编码指定区域段查找位置  </span></span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfComposedCharacterSequencesForRange:(<span class="built_in">NSRange</span>)range;</span><br></pre></td></tr></table></figure><h4 id="5-字符串拼接"><a href="#5-字符串拼接" class="headerlink" title="5.字符串拼接"></a>5.字符串拼接</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 后面直接拼接字符串</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByAppendingString:(<span class="built_in">NSString</span> *)aString;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面可以直接拼接字符串，也可拼接字符串参数</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByAppendingFormat:(<span class="built_in">NSString</span> *)format, ... <span class="built_in">NS_FORMAT_FUNCTION</span>(<span class="number">1</span>,<span class="number">2</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加路径</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByAppendingPathComponent:(<span class="built_in">NSString</span> *)str;</span><br></pre></td></tr></table></figure><blockquote><p>注意：stringByAppendingString 与 stringByAppendingFormat的与别</p></blockquote><h4 id="6-字符串可以转化为基本数据"><a href="#6-字符串可以转化为基本数据" class="headerlink" title="6.字符串可以转化为基本数据"></a>6.字符串可以转化为基本数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 面的便利方法都跳过了初始空格字符(whitespaceSet)，忽略了尾随字符。他们不是识别地区。NSScanner或NSNumberFormatter可以用于更强大和本地感知的数字解析。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">double</span> doubleValue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">float</span> floatValue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">int</span> intValue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> integerValue API_AVAILABLE(macos(<span class="number">10.5</span>), ios(<span class="number">2.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">long</span> <span class="keyword">long</span> longLongValue API_AVAILABLE(macos(<span class="number">10.5</span>), ios(<span class="number">2.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过初始的空格字符(白色的)，或者是可选的-/+符号，后跟0。当遇到“Y”、“Y”、“T”、“T”或数字1-9时返回YES。它忽略任何尾字符。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">BOOL</span> boolValue API_AVAILABLE(macos(<span class="number">10.5</span>), ios(<span class="number">2.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里需要提示一下，如果字符串内全是数字，则会全部转化（如果有小数点，转为float和double类型会全转，其他形式只取整数，），如果全是非数字，或者没有以数字开头，怎转化值为0，比如：@”dgtgwge566” //0   如果开头以数字开头，开始会提取到开头几个数字的，后面的提取不了，如：@”456dkhgeo90” //456</p></blockquote><h4 id="7-字符大小写转化"><a href="#7-字符大小写转化" class="headerlink" title="7.字符大小写转化"></a>7.字符大小写转化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSString *string = @&quot;string&quot;;  </span><br><span class="line">  </span><br><span class="line">NSLog(@&quot;大写:         %@&quot;, string.uppercaseString);  </span><br><span class="line">NSLog(@&quot;小写:         %@&quot;, string.lowercaseString);  </span><br><span class="line">NSLog(@&quot;首字母大写:    %@&quot;, string.capitalizedString);  </span><br><span class="line">//输出:   大写:         STRING  </span><br><span class="line">//输出:   小写:         string  </span><br><span class="line">//输出:   首字母大写:    String  </span><br><span class="line">  </span><br><span class="line">//本地化(大写)  </span><br><span class="line">- (NSString *)uppercaseStringWithLocale:(nullable NSLocale *)locale;   </span><br><span class="line">//本地化(小写)  </span><br><span class="line">- (NSString *)lowercaseStringWithLocale:(nullable NSLocale *)locale;  </span><br><span class="line">//本地化(首字母大写)  </span><br><span class="line">- (NSString *)capitalizedStringWithLocale:(nullable NSLocale *)locale;</span><br></pre></td></tr></table></figure><h4 id="8-字符串分行分段"><a href="#8-字符串分行分段" class="headerlink" title="8.字符串分行分段"></a>8.字符串分行分段</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分行 </span></span><br><span class="line"><span class="comment">//1.指定范围,分行取字符串  </span></span><br><span class="line">- (<span class="keyword">void</span>)getLineStart:(<span class="keyword">nullable</span> <span class="built_in">NSUInteger</span> *)startPtr </span><br><span class="line">                 end:(<span class="keyword">nullable</span> <span class="built_in">NSUInteger</span> *)lineEndPtr </span><br><span class="line">         contentsEnd:(<span class="keyword">nullable</span> <span class="built_in">NSUInteger</span> *)contentsEndPtr </span><br><span class="line">            forRange:(<span class="built_in">NSRange</span>)range;  </span><br><span class="line"><span class="comment">//2.获取指定范围该行的范围  </span></span><br><span class="line">- (<span class="built_in">NSRange</span>)lineRangeForRange:(<span class="built_in">NSRange</span>)range;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//分段</span></span><br><span class="line"><span class="comment">//3.指定范围,分段取字符串  </span></span><br><span class="line">- (<span class="keyword">void</span>)getParagraphStart:(<span class="keyword">nullable</span> <span class="built_in">NSUInteger</span> *)startPtr </span><br><span class="line">                      end:(<span class="keyword">nullable</span> <span class="built_in">NSUInteger</span> *)parEndPtr </span><br><span class="line">              contentsEnd:(<span class="keyword">nullable</span> <span class="built_in">NSUInteger</span> *)contentsEndPtr </span><br><span class="line">                 forRange:(<span class="built_in">NSRange</span>)range;  </span><br><span class="line"><span class="comment">//4.获取指定范围该段落的范围  </span></span><br><span class="line">- (<span class="built_in">NSRange</span>)paragraphRangeForRange:(<span class="built_in">NSRange</span>)range;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//字符串分行,分段/ </span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"123 456\nABC,DEF\nabc.def"</span>;  </span><br><span class="line"><span class="comment">//获取该行的范围(指定范围)  </span></span><br><span class="line"><span class="built_in">NSRange</span> range1 = [string lineRangeForRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">10</span>)];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld 行长度:     %ld"</span>, range1.location, range1.length);  </span><br><span class="line"><span class="comment">//输出:       0 行长度:     16  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取该段落范围(指定范围)  </span></span><br><span class="line"><span class="built_in">NSRange</span> range2 = [string paragraphRangeForRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">3</span>)];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld 段落长度:   %ld"</span>, range2.location, range2.length);  </span><br><span class="line"><span class="comment">//输出:       0 段落长度:   8</span></span><br></pre></td></tr></table></figure><h4 id="9-字符串列举条件"><a href="#9-字符串列举条件" class="headerlink" title="9.字符串列举条件"></a>9.字符串列举条件</h4><p>NSStringEnumerationOptions</p><blockquote><p>NSStringEnumerationByLines    按行<br>NSStringEnumerationByParagraphs    按段落<br>NSStringEnumerationByComposedCharacterSequences    按字符顺序<br>NSStringEnumerationByWords    按单词,字<br>NSStringEnumerationBySentences    按句子<br>NSStringEnumerationReverse    反向遍历<br>NSStringEnumerationSubstringNotRequired    不需要子字符串<br>NSStringEnumerationLocalized    本地化</p></blockquote><h4 id="10-字符串编码与转换"><a href="#10-字符串编码与转换" class="headerlink" title="10.字符串编码与转换"></a>10.字符串编码与转换</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.选择编码,是否允许有损编码【重要】  </span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)dataUsingEncoding:(<span class="built_in">NSStringEncoding</span>)encoding allowLossyConversion:(<span class="built_in">BOOL</span>)lossy;  </span><br><span class="line"><span class="comment">//2.选择编码  </span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)dataUsingEncoding:(<span class="built_in">NSStringEncoding</span>)encoding;  </span><br><span class="line"><span class="comment">//3.判断是否可以无损编码  </span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canBeConvertedToEncoding:(<span class="built_in">NSStringEncoding</span>)encoding;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//4.C字符编码转换  </span></span><br><span class="line">- (<span class="keyword">nullable</span> __<span class="keyword">strong</span> <span class="keyword">const</span> charchar *)cStringUsingEncoding:(<span class="built_in">NSStringEncoding</span>)encoding;  </span><br><span class="line"><span class="comment">//5.判读C字符转化是否可以成功  </span></span><br><span class="line">- (<span class="built_in">BOOL</span>)getCString:(charchar *)buffer maxLength:(<span class="built_in">NSUInteger</span>)maxBufferCount encoding:(<span class="built_in">NSStringEncoding</span>)encoding;  </span><br><span class="line"><span class="comment">//6.指定缓存区转换  </span></span><br><span class="line">- (<span class="built_in">BOOL</span>)getBytes:(<span class="keyword">nullable</span> voidvoid *)buffer maxLength:(<span class="built_in">NSUInteger</span>)maxBufferCount usedLength:(<span class="keyword">nullable</span> <span class="built_in">NSUInteger</span> *)usedBufferCount encoding:(<span class="built_in">NSStringEncoding</span>)encoding options:(<span class="built_in">NSStringEncodingConversionOptions</span>)options range:(<span class="built_in">NSRange</span>)range remainingRange:(<span class="keyword">nullable</span> <span class="built_in">NSRangePointer</span>)leftover;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//7.对字符串进行编码时所需的最大字节数  </span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)maximumLengthOfBytesUsingEncoding:(<span class="built_in">NSStringEncoding</span>)enc;  </span><br><span class="line"><span class="comment">//8.对字符串进行编码时所需的字节数  </span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)lengthOfBytesUsingEncoding:(<span class="built_in">NSStringEncoding</span>)enc;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//9.可用字符串编码  </span></span><br><span class="line">+ (<span class="keyword">const</span> <span class="built_in">NSStringEncoding</span> *)availableStringEncodings;   </span><br><span class="line"><span class="comment">//10.本地化编码名称  </span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)localizedNameOfStringEncoding:(<span class="built_in">NSStringEncoding</span>)encoding;  </span><br><span class="line"><span class="comment">//11.默认C字符串编码  </span></span><br><span class="line">+ (<span class="built_in">NSStringEncoding</span>)defaultCStringEncoding;</span><br></pre></td></tr></table></figure><h4 id="11-字符串分割"><a href="#11-字符串分割" class="headerlink" title="11.字符串分割"></a>11.字符串分割</h4><p>NSCharacterSet集合</p><blockquote><p>controlCharacterSet    控制符<br>whitespaceCharacterSet    空格符<br>whitespaceAndNewlineCharacterSet    空格换行符<br>decimalDigitCharacterSet    小数<br>letterCharacterSet    文字<br>lowercaseLetterCharacterSet    小写字母<br>uppercaseLetterCharacterSet    大写字母<br>nonBaseCharacterSet    非基础<br>alphanumericCharacterSet    数字字母<br>decomposableCharacterSet    可分解<br>illegalCharacterSet    非法<br>punctuationCharacterSet    标点<br>capitalizedLetterCharacterSet    大写<br>symbolCharacterSet    符号<br>newlineCharacterSet    换行符</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串分割</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"A_B_c_D_E_F"</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//分割(指定字符串)  </span></span><br><span class="line"><span class="built_in">NSArray</span> *resultArr1 = [string componentsSeparatedByString:<span class="string">@"_"</span>];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, resultArr1);  </span><br><span class="line"><span class="comment">//输出:   (A, B, c, D, E, F)  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//分割(指定字符集合)  </span></span><br><span class="line"><span class="built_in">NSArray</span> *resultArr2 = [string componentsSeparatedByCharactersInSet:[<span class="built_in">NSCharacterSet</span> lowercaseLetterCharacterSet]];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, resultArr2);      </span><br><span class="line"><span class="comment">//输出:   ("A_B_" , "_D_E_F")</span></span><br></pre></td></tr></table></figure><h4 id="12-字符串操作（修剪，替换，折叠，填充）"><a href="#12-字符串操作（修剪，替换，折叠，填充）" class="headerlink" title="12.字符串操作（修剪，替换，折叠，填充）"></a>12.字符串操作（修剪，替换，折叠，填充）</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"3EWRs a;af"</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//////////修剪//////////  </span></span><br><span class="line"><span class="built_in">NSString</span> *result1 = [string stringByTrimmingCharactersInSet:[<span class="built_in">NSCharacterSet</span> lowercaseLetterCharacterSet]];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, result1);  </span><br><span class="line"><span class="comment">//输出:   3EWRs a;  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//////////填充//////////  </span></span><br><span class="line"><span class="built_in">NSString</span> *result2 = [string stringByPaddingToLength:<span class="number">20</span> withString:<span class="string">@"填充"</span> startingAtIndex:<span class="number">1</span>];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, result2);  </span><br><span class="line"><span class="comment">//输出:   3EWRs a;af充填充填充填充填充填  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//////////折叠//////////  </span></span><br><span class="line"><span class="built_in">NSString</span> *result3 = [string stringByFoldingWithOptions:<span class="built_in">NSNumericSearch</span> locale:[<span class="built_in">NSLocale</span> systemLocale]];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, result3);  </span><br><span class="line"><span class="comment">//输出:   3EWRs a;af  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//////////替换//////////  </span></span><br><span class="line"><span class="comment">//替换(指定字符串)  </span></span><br><span class="line"><span class="built_in">NSString</span> *result4 = [string stringByReplacingOccurrencesOfString:<span class="string">@" "</span> withString:<span class="string">@"替换"</span>];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, result4);  </span><br><span class="line"><span class="comment">//输出:   3EWRs替换a;af  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//替换(指定字符串,条件,范围)  </span></span><br><span class="line"><span class="built_in">NSString</span> *result5 = [string stringByReplacingOccurrencesOfString:<span class="string">@"a"</span> withString:<span class="string">@"替换"</span> options:<span class="built_in">NSRegularExpressionSearch</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, string.length - <span class="number">2</span>)];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, result5);  </span><br><span class="line"><span class="comment">//输出:   3EWRs 替换;af  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//替换(指定范围)  </span></span><br><span class="line"><span class="built_in">NSString</span> *result6 = [string stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, string.length) withString:<span class="string">@"替换"</span>];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, result6);  </span><br><span class="line"><span class="comment">//输出:   替换</span></span><br></pre></td></tr></table></figure><h4 id="13-字符串写入"><a href="#13-字符串写入" class="headerlink" title="13.字符串写入"></a>13.字符串写入</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串写入 </span></span><br><span class="line"><span class="comment">//写入到指定路径,编码的文件中  </span></span><br><span class="line">[string writeToFile:<span class="string">@"/Users/Desktop/LuisX.txt"</span> atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//写入到指定URL,编码的文件中  </span></span><br><span class="line">[string writeToURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"file://LuisX.text"</span>] atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h4 id="14-NSMutableString的介绍"><a href="#14-NSMutableString的介绍" class="headerlink" title="14.NSMutableString的介绍"></a>14.NSMutableString的介绍</h4><p>NSMutableString是NSString的字类，可以动态的扩展字符串。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.初始化容量为Capacity大小的字符串  (需要手动释放内存)  </span></span><br><span class="line"><span class="built_in">NSMutableString</span> *mutableStr1 = [[<span class="built_in">NSMutableString</span> alloc] initWithCapacity:<span class="number">20</span>];  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//2.初始化容量为Capacity大小的字符串  (不需要手动释放内存)  </span></span><br><span class="line"><span class="built_in">NSMutableString</span> *mutableStr2 = [<span class="built_in">NSMutableString</span> stringWithCapacity:<span class="number">20</span>];  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"string"</span>];  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//////////插入//////////  </span></span><br><span class="line">[str insertString:<span class="string">@"123"</span> atIndex:<span class="number">2</span>];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);  </span><br><span class="line"><span class="comment">//输出:   st123ring  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//////////删除//////////  </span></span><br><span class="line">[str deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">2</span>, <span class="number">2</span>)];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);  </span><br><span class="line"><span class="comment">//输出:   st3ring  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//////////拼接//////////  </span></span><br><span class="line">[str appendString:<span class="string">@"456"</span>];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);  </span><br><span class="line"><span class="comment">//输出:   st3ring456  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//////////格式化拼接//////////  </span></span><br><span class="line">[str appendFormat:<span class="string">@"7 89"</span>];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);  </span><br><span class="line"><span class="comment">//输出:   st3ring4567 89  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//////////设置新字符串//////////  </span></span><br><span class="line">[str setString:<span class="string">@"string"</span>];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);  </span><br><span class="line"><span class="comment">//输出:   string  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//////////字符串替换//////////  </span></span><br><span class="line"><span class="comment">//1.指定范围替换  </span></span><br><span class="line">[str1 replaceCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">2</span>, <span class="number">2</span>) withString:<span class="string">@"123"</span>];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str1);  </span><br><span class="line"><span class="comment">//输出:   st123ng  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//2.指定字符串,条件,范围替换  </span></span><br><span class="line">[str1 replaceOccurrencesOfString:<span class="string">@"123"</span> withString:<span class="string">@"--"</span> options:<span class="built_in">NSRegularExpressionSearch</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, str1.length)];  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str1);  </span><br><span class="line"><span class="comment">//输出:   st--ng</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
          <category> 基础知识 </category>
          
          <category> NSString </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS开发本地推送UILocalNotification</title>
      <link href="/2018/06/11/iOS%E5%BC%80%E5%8F%91%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81UILocalNotification/"/>
      <url>/2018/06/11/iOS%E5%BC%80%E5%8F%91%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81UILocalNotification/</url>
      <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p><code>UILocalNotification</code> 是通过设置时间来触发本地推送通知的通知方式,不需要连网就能实现推送功能。本地通知触发后，会显示在通知中心中，并根据配置，显示横幅和播放声音，和App的icon上显示通知的条数。 </p><p><code>UILocalNotification</code> 适用于闹钟、提醒、备忘录等功能。缺点是<code>UILocalNotification</code>可以设置的最大提醒条数为64条。超过64条的通知将系统会自动忽略。</p><h3 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h3><ol><li>创建UILocalNotification实例</li><li>设置相关的属性，如：时间、时间间隔、是否重复、推送方式、推送铃声、推送标题、推送简介、推送的参数等等。</li><li>注册添加本地通知</li><li>Appdelegate.m 接收注册通知</li><li>触发通知的业务跳转处理</li><li>取消通知</li></ol><h3 id="三、属性介绍"><a href="#三、属性介绍" class="headerlink" title="三、属性介绍"></a>三、属性介绍</h3><p>属性介绍</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSDate</span> *fireDate;设置通知的提醒时间</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSTimeZone</span> *timeZone;设置时间的时区</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">NSCalendarUnit</span> repeatInterval;   设置重复间隔的单位，（天、周、月、年，<span class="number">0</span>表示不重复）  </span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSCalendar</span> *repeatCalendar;重复激发通知所使用的日历单位需要参考的日历，如果不设置的话，系统默认的日历将被作为参考日历。</span><br><span class="line"></span><br><span class="line"><span class="comment">//    NSString *const NSGregorianCalendar; 公历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    NSString * const NSChineseCalendar;   农历</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">CLRegion</span> *region;设置触发通知的地理区域</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">BOOL</span> regionTriggersOnce;是否穿越通知地理区域时再次触发通知</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *alertBody; 通知提示中显示的消息，内容。</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> hasAction;  控制该通知是否显示或隐藏警报动作。</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *alertAction; 设置通知动作按钮的标题。</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *alertLaunchImage;设置通知动作按钮的图像。</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *alertTitle; 设置通知原因的简短描述。</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *soundName;通知提示音，可以自定义</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> applicationIconBadgeNumber;应用程序icon上的提醒个数</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *userInfo; 设置应用自定义信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *category ;设置通知的分类标示</span><br></pre></td></tr></table></figure><p>  <strong><code>NSCalendarUnit repeatInterval</code> 循环枚举</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSCalendarUnit</span>) &#123;</span><br><span class="line">        <span class="built_in">NSCalendarUnitEra</span>                = kCFCalendarUnitEra,<span class="comment">//一个年代、一个世纪循环一次。</span></span><br><span class="line">        <span class="built_in">NSCalendarUnitYear</span>               = kCFCalendarUnitYear,<span class="comment">//每年循环一次</span></span><br><span class="line">        <span class="built_in">NSCalendarUnitMonth</span>              = kCFCalendarUnitMonth,<span class="comment">//每月循环一次</span></span><br><span class="line">        <span class="built_in">NSCalendarUnitDay</span>                = kCFCalendarUnitDay,<span class="comment">//每天循环一次</span></span><br><span class="line">        <span class="built_in">NSCalendarUnitHour</span>               = kCFCalendarUnitHour,<span class="comment">//每小时循环一次</span></span><br><span class="line">        <span class="built_in">NSCalendarUnitMinute</span>             = kCFCalendarUnitMinute,<span class="comment">//每分钟循环一次</span></span><br><span class="line">        <span class="built_in">NSCalendarUnitSecond</span>             = kCFCalendarUnitSecond,<span class="comment">//每秒循环一次</span></span><br><span class="line">        <span class="built_in">NSCalendarUnitWeekday</span>            = kCFCalendarUnitWeekday,<span class="comment">//平常日、工作日循环，但是周末也会。(*而不是每周循环，具体和NSCalendarUnitDay有什么区别，暂时没有测试出来，如果哪位知道请告知，感谢)</span></span><br><span class="line">        <span class="built_in">NSCalendarUnitWeekdayOrdinal</span>     = kCFCalendarUnitWeekdayOrdinal,</span><br><span class="line">        <span class="built_in">NSCalendarUnitQuarter</span>            <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0) = kCFCalendarUnitQuarter,<span class="comment">//一个季度循环一次</span></span><br><span class="line">        <span class="built_in">NSCalendarUnitWeekOfMonth</span>        <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">5</span>_0) = kCFCalendarUnitWeekOfMonth,<span class="comment">//每个月的第几周</span></span><br><span class="line">        <span class="built_in">NSCalendarUnitWeekOfYear</span>         <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">5</span>_0) = kCFCalendarUnitWeekOfYear,<span class="comment">//每年的第几周</span></span><br><span class="line">        <span class="built_in">NSCalendarUnitYearForWeekOfYear</span>  <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">5</span>_0) = kCFCalendarUnitYearForWeekOfYear,</span><br><span class="line">        <span class="built_in">NSCalendarUnitNanosecond</span>         <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">5</span>_0) = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>),</span><br><span class="line">        <span class="built_in">NSCalendarUnitCalendar</span>           <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">4</span>_0) = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>),</span><br><span class="line">        <span class="built_in">NSCalendarUnitTimeZone</span>           <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">4</span>_0) = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h3><h4 id="1-在-Appdelegate-的application-UIApplication-application-didFinishLaunchingWithOptions-NSDictionary-launchOptions-方法里面添加注册接收方法"><a href="#1-在-Appdelegate-的application-UIApplication-application-didFinishLaunchingWithOptions-NSDictionary-launchOptions-方法里面添加注册接收方法" class="headerlink" title="1.在 Appdelegate 的application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions  方法里面添加注册接收方法"></a>1.在 Appdelegate 的<code>application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>  方法里面添加注册接收方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="built_in">UIApplication</span> instancesRespondToSelector:<span class="keyword">@selector</span>(registerUserNotificationSettings:)])&#123;</span><br><span class="line">       [[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:[<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:<span class="built_in">UIUserNotificationTypeAlert</span>|<span class="built_in">UIUserNotificationTypeBadge</span>|<span class="built_in">UIUserNotificationTypeSound</span> categories:<span class="literal">nil</span>]];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2-在需要添加通知的页面添加注册通知，或者封装一层调用，可以根据通知需要传入需要的参数，控制通知的注册添加或取消删除"><a href="#2-在需要添加通知的页面添加注册通知，或者封装一层调用，可以根据通知需要传入需要的参数，控制通知的注册添加或取消删除" class="headerlink" title="2.在需要添加通知的页面添加注册通知，或者封装一层调用，可以根据通知需要传入需要的参数，控制通知的注册添加或取消删除"></a>2.在需要添加通知的页面添加注册通知，或者封装一层调用，可以根据通知需要传入需要的参数，控制通知的注册添加或取消删除</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 注册本地通知方法</span></span><br><span class="line"><span class="comment">// 注册本地通知</span></span><br><span class="line">-(<span class="keyword">void</span>)registerLocalNotification:(<span class="built_in">NSString</span> *)timeStr title:(<span class="built_in">NSString</span> *)title desc:(<span class="built_in">NSString</span> *)desc soundName:(<span class="built_in">NSString</span> *)soundName remindType:(<span class="built_in">NSString</span> *)remindType tagStr:(<span class="built_in">NSString</span> *)tagStr remindId:(<span class="built_in">NSString</span> *)remindId&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UILocalNotification</span> * notification = [[<span class="built_in">UILocalNotification</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDateFormatter</span> * curndf = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    [curndf setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> * curDate = [curndf stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    <span class="comment">// 时间加上秒</span></span><br><span class="line">    <span class="built_in">NSString</span> * finalTimeStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@:00"</span>,curDate,timeStr];</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> * finalTimeFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    [finalTimeFormatter setDateFormat:<span class="string">@"yyyy-MM-dd HH:mm:ss"</span>];</span><br><span class="line">    <span class="built_in">NSDate</span> * finalDate = [finalTimeFormatter dateFromString:finalTimeStr];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置什么时间点(具体的时间)触发本地通知.</span></span><br><span class="line">    notification.fireDate = finalDate;</span><br><span class="line">    <span class="comment">// 设置时区,default手机时区</span></span><br><span class="line">    notification.timeZone = [<span class="built_in">NSTimeZone</span> defaultTimeZone];</span><br><span class="line">    <span class="comment">// 设置重复间隔, 按天跑</span></span><br><span class="line">    notification.repeatInterval = kCFCalendarUnitDay;</span><br><span class="line">    <span class="comment">// 弹出的通知标题</span></span><br><span class="line">    notification.alertTitle = title;</span><br><span class="line">    <span class="comment">// 弹出的通知内容</span></span><br><span class="line">    notification.alertBody = desc;</span><br><span class="line">    <span class="comment">// Badge个数</span></span><br><span class="line">    notification.applicationIconBadgeNumber = notification.applicationIconBadgeNumber+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 通知被触发时播放声音</span></span><br><span class="line">    notification.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</span><br><span class="line">    <span class="comment">// 通知触发时播放的声音</span></span><br><span class="line">    notification.soundName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.mp3"</span>,soundName];</span><br><span class="line">    <span class="comment">// 通知的参数</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> * userDict = @&#123;<span class="string">@"nTimeStr"</span>:timeStr,<span class="string">@"remindType"</span>:remindType,<span class="string">@"tag"</span>:tagStr,<span class="string">@"remindId"</span>:remindId&#125;;</span><br><span class="line">    notification.userInfo = userDict;</span><br><span class="line">    <span class="comment">// 添加推送到UIApplication</span></span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] scheduleLocalNotification:notification];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-取消通知"><a href="#3-取消通知" class="headerlink" title="3.取消通知"></a>3.取消通知</h4><h5 id="3-1-取消全部的通知"><a href="#3-1-取消全部的通知" class="headerlink" title="3.1 取消全部的通知"></a>3.1 取消全部的通知</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消全部的通知</span></span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] cancelAllLocalNotifications];</span><br></pre></td></tr></table></figure><h5 id="3-2-取消对应-ID-的通知"><a href="#3-2-取消对应-ID-的通知" class="headerlink" title="3.2 取消对应 ID 的通知"></a>3.2 取消对应 ID 的通知</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IOS最多允许最近本地通知数量是64个，超过限制的本地通知将被忽略。</span></span><br><span class="line"><span class="meta">#pragma mark -- 删除通知</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)cancelLocalNotificationWithKey:(<span class="built_in">NSString</span> *)key remindType:(<span class="built_in">NSString</span> *)remindType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取所有本地通知数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *localNotifications = [<span class="built_in">UIApplication</span> sharedApplication].scheduledLocalNotifications;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n本地通知总数%@ \n 一共: %ld 个"</span>,localNotifications ,[localNotifications count]);</span><br><span class="line">    <span class="comment">// 循环遍历所有的通知</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UILocalNotification</span> *notification <span class="keyword">in</span> localNotifications) &#123;</span><br><span class="line">    <span class="comment">// 取出每个通知的通知数据</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = notification.userInfo;</span><br><span class="line">        <span class="keyword">if</span> (userInfo) &#123;</span><br><span class="line">            <span class="comment">// 根据设置通知参数时指定的key来获取通知参数</span></span><br><span class="line">            <span class="built_in">NSString</span> *info = userInfo[<span class="string">@"nTimeStr"</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSString</span> *type = userInfo[<span class="string">@"remindType"</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果找到需要取消的通知，则取消</span></span><br><span class="line">            <span class="keyword">if</span> (info != <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([info isEqualToString:key] &amp;&amp; [type isEqualToString:remindType]) &#123;</span><br><span class="line">                    [[<span class="built_in">UIApplication</span> sharedApplication] cancelLocalNotification:notification];</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"type:%@,key:%@,本地通知取消成功!!!"</span>,type,key);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-接收通知"><a href="#4-接收通知" class="headerlink" title="4.接收通知"></a>4.接收通知</h4><h5 id="4-1-前台接收通知，调用系统application-UIApplication-application-didReceiveLocalNotification-UILocalNotification-notification方法-，在这个方法里面做业务处理"><a href="#4-1-前台接收通知，调用系统application-UIApplication-application-didReceiveLocalNotification-UILocalNotification-notification方法-，在这个方法里面做业务处理" class="headerlink" title="4.1 前台接收通知，调用系统application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification方法 ，在这个方法里面做业务处理"></a>4.1 前台接收通知，调用系统<code>application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification</code>方法 ，在这个方法里面做业务处理</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序没有被杀死时,接收到本地通知时调用--点击通知时会执行这个方法,如果程序被杀死时,这个方法不再走,在application: didFinishLaunchingWithOptions:方法中获取</span></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"notification.userInfo = %@"</span>,notification.userInfo);</span><br><span class="line">    <span class="comment">// 获取通知详情</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *dict = notification.userInfo;</span><br><span class="line">    <span class="keyword">if</span> (dict) &#123;</span><br><span class="line">        <span class="comment">// 根据通知的类型参数做出对应的跳转</span></span><br><span class="line">        <span class="keyword">if</span> ([dict[<span class="string">@"remindType"</span>] isEqualToString:CPTakeMediciTableName]) &#123;</span><br><span class="line">            </span><br><span class="line">            CPMedicineRemindDetailViewController *medicine = [[CPMedicineRemindDetailViewController alloc]init];</span><br><span class="line">            medicine.remindId = dict[<span class="string">@"remindId"</span>];</span><br><span class="line">            medicine.timeStr = dict[<span class="string">@"nTimeStr"</span>];</span><br><span class="line">            medicine.type = CPMedicinePushNow;</span><br><span class="line">            [[<span class="keyword">self</span> currentViewController].navigationController pushViewController:medicine animated:<span class="literal">YES</span>];</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>([dict[<span class="string">@"remindType"</span>] isEqualToString:CPMeasureTableName])&#123;</span><br><span class="line"></span><br><span class="line">            CPMeasureRemindDetailViewController *measure = [[CPMeasureRemindDetailViewController alloc]init];</span><br><span class="line">            measure.tagStr = dict[<span class="string">@"tag"</span>];</span><br><span class="line">            measure.timeStr = dict[<span class="string">@"nTimeStr"</span>];</span><br><span class="line">            measure.type = CPMeasurePushNow;</span><br><span class="line">            [[<span class="keyword">self</span> currentViewController] presentViewController:measure animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-应用在后台被杀死了调用pplication-UIApplication-application-didFinishLaunchingWithOptions-NSDictionary-launchOptions方法，在这个方法里面做业务处理"><a href="#4-2-应用在后台被杀死了调用pplication-UIApplication-application-didFinishLaunchingWithOptions-NSDictionary-launchOptions方法，在这个方法里面做业务处理" class="headerlink" title="4.2 应用在后台被杀死了调用pplication:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法，在这个方法里面做业务处理"></a>4.2 应用在后台被杀死了调用<code>pplication:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>方法，在这个方法里面做业务处理</h5><p>在<code>pplication:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>方法中添加下面的代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (launchOptions != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UILocalNotification</span> *localNotification = launchOptions[<span class="built_in">UIApplicationLaunchOptionsLocalNotificationKey</span>];</span><br><span class="line">        <span class="keyword">if</span> (localNotification != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">// 程序完全退出状态下，点击推送通知后的业务处理</span></span><br><span class="line">            <span class="comment">// 根据通知的参数做不同的跳转</span></span><br><span class="line">            <span class="built_in">NSDictionary</span> *dict = localNotification.userInfo;</span><br><span class="line">            <span class="keyword">if</span> (dict) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> ([dict[<span class="string">@"remindType"</span>] isEqualToString:CPTakeMediciTableName]) &#123;</span><br><span class="line">                    CPMedicineRemindDetailViewController *medicine = [[CPMedicineRemindDetailViewController alloc]init];</span><br><span class="line">                    medicine.remindId = dict[<span class="string">@"remindId"</span>];</span><br><span class="line">                    medicine.timeStr = dict[<span class="string">@"nTimeStr"</span>];</span><br><span class="line">                    CPNavigationController *nav = [[CPNavigationController alloc]initWithRootViewController:medicine];</span><br><span class="line">                    [AppDelegate sharedInstance].window.rootViewController = nav;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>([dict[<span class="string">@"remindType"</span>] isEqualToString:CPMeasureTableName])&#123;</span><br><span class="line">                    </span><br><span class="line">                    CPMeasureRemindDetailViewController *measure = [[CPMeasureRemindDetailViewController alloc]init];</span><br><span class="line">                    measure.tagStr = dict[<span class="string">@"tag"</span>];</span><br><span class="line">                    measure.timeStr = dict[<span class="string">@"nTimeStr"</span>];</span><br><span class="line">                    [AppDelegate sharedInstance].window.rootViewController = measure;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="五、其他设置"><a href="#五、其他设置" class="headerlink" title="五、其他设置"></a>五、其他设置</h3><p>实现发送基于位置的通知方法（iOS8+）：</p><blockquote><p>1、无需编码，如果设备用户打开了定位，系统会给用户当前的位置来决定是否要给用户发送通知；</p></blockquote><blockquote><p>2、需要获取用户定位权限CLLocation；</p></blockquote><blockquote><p>3、精准度一般般。</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本地推送 </tag>
            
            <tag> UILocalNotification </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>001- 初识汇编</title>
      <link href="/2018/04/20/001-%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/"/>
      <url>/2018/04/20/001-%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/</url>
      <content type="html"><![CDATA[<p>我们在学习逆向开发之前,我们要了解一个基本的逆向原理.首先我们是逆向iOS系统上面的APP.那么我们知道,一个APP安装在手机上面的可执行文件本质上是二进制文件.因为iPhone手机本质上执行的指令是二进制.是由手机上的CPU执行的.所以逆向开发是建立在分析二进制上面.所以今天我们接下来的课程从非常基础的东西开始讲解.</p><h2 id="汇编语言的发展"><a href="#汇编语言的发展" class="headerlink" title="汇编语言的发展"></a>汇编语言的发展</h2><h3 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h3><blockquote><p>由0和1组成的机器指令.</p></blockquote><ul><li>加：0100 0000</li><li>减：0100 1000</li><li>乘：1111 0111 1110 0000 </li><li>除：1111 0111 1111 0000 </li></ul><h3 id="汇编语言-assembly-language"><a href="#汇编语言-assembly-language" class="headerlink" title="汇编语言(assembly language)"></a>汇编语言(assembly language)</h3><blockquote><p>使用助记符代替机器语言<br>如:</p></blockquote><ul><li>加：INC EAX        通过编译器 0100 0000</li><li>减：DEC EAX        通过编译器 0100 1000</li><li>乘：MUL EAX         通过编译器 1111 0111 1110 0000</li><li>除：DIV EAX        通过编译器 1111 0111 1111 0000</li></ul><p>###高级语言（High-level programming language)</p><blockquote><p>C\C++\Java\OC\Swift,更加接近人类的自然语言<br>比如C语言:</p></blockquote><ul><li>加：A+B        通过编译器            0100 0000</li><li>减：A-B        通过编译器            0100 1000</li><li>乘：A*B     通过编译器            1111 0111 1110 0000</li><li>除：A/B        通过编译器            1111 0111 1111 0000</li></ul><p>我们的代码在终端设备上是这样的过程:<br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247619245714.jpg-style02" alt=""></p><ul><li><strong>汇编语言</strong>与<strong>机器语言</strong>一一对应，每一条机器指令都有与之对应的汇编指令</li><li><strong>汇编语言</strong>可以通过编译得到<strong>机器语言</strong>，<strong>机器语言</strong>可以通过反汇编得到<strong>汇编语言</strong></li><li><strong>高级语言</strong>可以通过编译得到<strong>汇编语言</strong> \ <strong>机器语言</strong>，但汇编语言\机器语言几乎不可能还原成<strong>高级语言</strong></li></ul><h3 id="汇编语言的特点"><a href="#汇编语言的特点" class="headerlink" title="汇编语言的特点"></a>汇编语言的特点</h3><ul><li><p>可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能</p></li><li><p>能够不受编译器的限制，对生成的二进制代码进行完全的控制</p></li><li><p>目标代码简短，占用内存少，执行速度快</p></li><li><p>汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性</p></li><li><p>知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护</p></li><li><p>不区分大小写，比如mov和MOV是一样的</p></li></ul><h3 id="汇编的用途-哥么我学了能干啥"><a href="#汇编的用途-哥么我学了能干啥" class="headerlink" title="汇编的用途(哥么我学了能干啥?)"></a>汇编的用途(哥么我学了能干啥?)</h3><ul><li>编写驱动程序、操作系统（比如Linux内核的某些关键部分）</li><li>对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编）</li><li>软件安全<ul><li>病毒分析与防治</li><li>逆向\加壳\脱壳\破解\外挂\免杀\加密解密\漏洞\黑客</li></ul></li><li>理解整个计算机系统的最佳起点和最有效途径</li><li>为编写高效代码打下基础</li><li>弄清代码的本质<ul><li>函数的本质究竟是什么?</li><li>++a + ++a + ++a 底层如何执行的?</li><li>编译器到底帮我们干了什么?</li><li>DEBUG模式和RELEASE模式有什么关键的地方被我们忽略</li><li>……</li></ul></li></ul><p>最后来句装13的话</p><blockquote><p>越底层越单纯!真正的程序员都需要了解的一门非常重要的语言,汇编!</p></blockquote><h3 id="汇编语言的种类"><a href="#汇编语言的种类" class="headerlink" title="汇编语言的种类"></a>汇编语言的种类</h3><ul><li><p>目前讨论比较多的汇编语言有</p><ul><li>8086汇编（8086处理器是16bit的CPU）</li><li>Win32汇编</li><li>Win64汇编</li><li>ARM汇编（嵌入式、Mac、iOS）</li><li>……</li></ul></li><li><p>我们iPhone里面用到的是ARM汇编,但是不同的设备也有差异.因CPU的架构不同.</p></li></ul><table><thead><tr><th>架构</th><th>设备 </th></tr></thead><tbody><tr><td>armv6</td><td>iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch</td></tr><tr><td>armv7</td><td>iPhone3GS, iPhone4, iPhone4S,iPad, iPad2, iPad3(The New iPad), iPad mini, iPod Touch 3G, iPod Touch4</td></tr><tr><td>armv7s</td><td>iPhone5, iPhone5C, iPad4(iPad with Retina Display)</td></tr><tr><td>arm64</td><td>iPhone5S 以后 iPhoneX , iPad Air, iPad mini2以后</td></tr></tbody></table><h3 id="几个必要的常识"><a href="#几个必要的常识" class="headerlink" title="几个必要的常识"></a>几个必要的常识</h3><ul><li>要想学好汇编,首先需要了解CPU等硬件结构</li><li>APP/程序的执行过程<br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247619726174.jpg-style02" alt=""></li><li>硬件相关最为重要是CPU/内存</li><li>在汇编中,大部分指令都是和CPU与内存相关的</li></ul><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247620013282.jpg-style02" alt=""><br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247620275065.jpg-style02" alt=""></p><ul><li>每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互</li><li>总线：一根根导线的集合</li><li><p>总线的分类</p><ul><li>地址总线</li><li>数据总线</li><li>控制总线</li></ul><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247620691639.jpg-style02" alt=""></p></li></ul><p><strong>举个例子</strong></p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247621338263.png-style02" alt=""></p><ul><li><strong>地址总线</strong><ul><li>它的宽度决定了CPU的<em>寻址能力</em></li><li>8086的地址总线宽度是_20_，所以寻址能力是_1M_（ 2^20  ）</li></ul></li></ul><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247621451257.png-style02" alt=""></p><ul><li><strong>数据总线</strong><ul><li>它的宽度决定了CPU的单次数据传送量，也就是数据<em>传送速度</em></li><li>8086的数据总线宽度是_16_，所以单次最大传递<em>2个字节</em>的数据</li></ul></li><li><strong>控制总线</strong><ul><li>它的宽度决定了CPU对其他器件的<em>控制能力</em>、能有多少种控制</li></ul></li></ul><p><strong>做个小练习</strong></p><ol><li>一个CPU 的寻址能力为8KB,那么它的地址总线的宽度为____</li><li>8080,8088,80286,80386 的<strong>地址总线</strong>宽度分别为16根,20根,24根,32根.那么他们的寻址能力分别为多少____KB, ____MB,____MB,____GB?</li><li>8080,8088,8086,80286,80386 的<strong>数据总线</strong>宽度分别为8根,8根,16根,16根,32根.那么它们一次可以传输的数据为:____B,____B,____B,____B,____B,</li><li>从内存中读取1024字节的数据,8086至少要读____次,80386至少要读取____次.</li></ol><p><strong>解答:</strong></p><ol><li>8KB = 1024 * 8 =  2^10 + 2^3 ,所以地址总线的宽度为13</li><li></li></ol><ul><li>地址总线为16,所以 寻址能力为 2^16 = 2^10 * 2^6 = 64KB</li><li>地址总线为20,所以 寻址能力为 2^20 = 2^10 <em> 2^10 = 1024 </em> 1024 = 1MB;</li><li>地址总线为24,所以 寻址能力为 2^24 = 2^20 <em> 2^4 = 1MB </em> 16 = 16MB;</li><li>地址总线为32,所以 寻址能力为 2^30 = 2^30 <em> 2^2 = 1GB </em> 4 = 4GB;</li></ul><p><strong>答案</strong><br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247622018451.png-style02" alt=""></p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247622662488.png-style02" alt=""></p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247622844191.png-style02" alt=""></p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247622924501.png-style02" alt=""></p><ul><li><p>内存地址空间的大小受CPU地址总线宽度的限制。8086的地址总线宽度为20，可以定位2^20个不同的内存单元（内存地址范围0x00000~0xFFFFF），所以8086的内存空间大小为1MB</p></li><li><p>0x00000~0x9FFFF：主存储器。可读可写</p></li><li><p>0xA0000~0xBFFFF：向显存中写入数据，这些数据会被显卡输出到显示器。可读可写</p></li><li><p>0xC0000~0xFFFFF：存储各种硬件\系统信息。只读</p></li></ul><p>##进制<br><strong>学习进制的障碍</strong></p><blockquote><p>很多人学不好进制，原因是总以十进制为依托去考虑其他进制，需要运算的时候也总是先转换成十进制，这种学习方法是错误的.<br>我们为什么一定要转换十进制呢？仅仅是因为我们对十进制最熟悉，所以才转换.<br>每一种进制都是完美的,想学好进制首先要忘掉十进制，也要忘掉进制间的转换！</p></blockquote><p>###进制的定义</p><ul><li>八进制由8个符号组成:0 1 2 3 4 5 6 7 逢八进一</li><li>十进制由10个符号组成:0 1 2 3 4 5 6 7 8 9逢十进一</li><li>N进制就是由N个符号组成:逢N进一</li></ul><p>#####做个练习</p><ul><li>1 + 1 在____情况下等于 3 ?</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><blockquote><p>十进制由10个符号组成: 0 1 3 2 8 A B E S 7 逢十进一</p></blockquote><p>如果这样定义十进制: 1 + 1 = 3!就对了!</p><p><strong>这样的目的何在?</strong><br>传统我们定义的十进制和自定义的十进制不一样.那么这10个符号如果我们不告诉别人这个符号表,别人是没办法拿到我们的具体数据的!用于加密!</p><blockquote><p><strong>十进制</strong>由十个<strong>符号</strong>组成,逢十进一,<strong>符号</strong>是可以<strong>自定义</strong>的!!</p></blockquote><p>###进制的运算</p><p>#####做个练习</p><ul><li>八进制运算<ul><li>2 + 3 = <strong> , 2 * 3 = </strong> ,4 + 5 = <strong> ,4 * 5 = </strong>.</li><li>277 + 333 = <strong> , 276 * 54 = </strong> , 237 - 54 = <strong> , 234 / 4 = </strong> .</li></ul></li></ul><p>#####八进制加法表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 0  1  2  3  4  5  6  7 </span><br><span class="line">10 11 12 13 14 15 16 17</span><br><span class="line">20 21 22 23 24 25 26 27</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">1+1 = 2</span><br><span class="line">1+2 = 3   2+2 = 4</span><br><span class="line">1+3 = 4   2+3 = 5   3+3 = 6</span><br><span class="line">1+4 = 5   2+4 = 6   3+4 = 7   4+4 = 10  </span><br><span class="line">1+5 = 6   2+5 = 7   3+5 = 10  4+5 = 11  5+5 = 12</span><br><span class="line">1+6 = 7   2+6 = 10  3+6 = 11  4+6 = 12  5+6 = 13  6+6 = 14</span><br><span class="line">1+7 = 10  2+7 = 11  3+7 = 12  4+7 = 13  5+7 = 14  6+7 = 15  7+7 = 16</span><br></pre></td></tr></table></figure></p><p>#####八进制乘法表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27...</span><br><span class="line">1*1 = 1</span><br><span class="line">1*2 = 2  2*2 = 4</span><br><span class="line">1*3 = 3  2*3 = 63*3 = 11</span><br><span class="line">1*4 = 4  2*4 = 103*4 = 14  4*4 = 20</span><br><span class="line">1*5 = 5  2*5 = 123*5 = 17  4*5 = 24  5*5 = 31</span><br><span class="line">1*6 = 6  2*6 = 143*6 = 22  4*6 = 30  5*6 = 36  6*6 = 44</span><br><span class="line">1*7 = 7  2*7 = 163*7 = 25  4*7 = 34  5*7 = 43  6*7 = 52  7*7 = 61</span><br></pre></td></tr></table></figure></p><p>#####实战四则运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   277         236         276         234</span><br><span class="line">+  333       -  54       *  54       /   4</span><br><span class="line">--------    --------    --------    --------</span><br></pre></td></tr></table></figure></p><p>###二进制的简写形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       二进制: 1 0 1 1 1 0 1 1 1 1 0 0</span><br><span class="line">三个二进制一组: 101 110 111 100</span><br><span class="line">       八进制:   5   6   7   4</span><br><span class="line">四个二进制一组: 1011 1011 1100</span><br><span class="line">     十六进制:    b    b    c</span><br></pre></td></tr></table></figure></p><blockquote><p>二进制：从0 写到 1111<br>0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111<br>这种二进制使用起来太麻烦，改成更简单一点的符号：<br>0 1 2 3 4 5 6 7 8 9 A B C D E F 这就是十六进制了</p></blockquote><p>###数据的宽度<br>数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> test()&#123;</span><br><span class="line">    <span class="keyword">int</span> cTemp = <span class="number">0x1FFFFFFFF</span>;</span><br><span class="line">    <span class="keyword">return</span> cTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    printf(<span class="string">"%x\n"</span>,test());</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###计算机中常见的数据宽度</p><ul><li>位(Bit): 1个位就是1个二进制位.0或者1</li><li>字节(Byte): 1个字节由8个Bit组成(8位).内存中的最小单元Byte.</li><li>字(Word): 1个字由2个字节组成(16位),这2个字节分别称为高字节和低字节.</li><li>双字(Doubleword): 1个双字由两个字组成(32位)</li></ul><p>那么计算机存储数据它会分为有符号数和无符号数.那么关于这个看图就理解了!<br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247623206581.jpg-style02" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无符号数,直接换算!</span><br><span class="line">有符号数:正数:  0    1    2    3    4    5    6    7 负数:  F    E    D    B    C    A    9    8      -1   -2   -3   -4   -5   -6   -7   -8</span><br></pre></td></tr></table></figure><p>###自定义进制符号</p><p>#####练习</p><ul><li>现在有10进制数 10个符号分别是：2，9，1，7，6，5，4， 8，3 , A 逢10进1 那么： 123 + 234 = ____</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">十进制:    0  1  2  3  4  5  6  7  8  9</span><br><span class="line">自定义:    2  9  1  7  6  5  4  8  3  A</span><br><span class="line">         92 99 91 97 96 95 94 98 93 9A</span><br><span class="line">         12 19 11 17 16 15 14 18 13 1A</span><br><span class="line">         72 79 71 77 76 75 74 78 73 7A</span><br><span class="line">         62 69 61 67 66 65 64 68 63 6A</span><br><span class="line">         52 59 51 57 56 55 54 58 53 5A</span><br><span class="line">         42 49 41 47 46 45 44 48 43 4A</span><br><span class="line">         82 89 81 87 86 85 84 88 83 8A</span><br><span class="line">         32 39 31 37 36 35 34 38 33 3A</span><br><span class="line">         922</span><br></pre></td></tr></table></figure><p>那么刚才通过10进制运算可以转化10进制然后查表!但是如果是其他进制.我们就不能转换,要直接学会查表</p><ul><li>现在有9进制数 9个符号分别是：2，9，1，7，6，5，4， 8，3 逢9进1 那么： 123 + 234 = ____</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">十进制:    0  1  2  3  4  5  6  7  8  </span><br><span class="line">自定义:    2  9  1  7  6  5  4  8  3  </span><br><span class="line">         92 99 91 97 96 95 94 98 93 </span><br><span class="line">         12 19 11 17 16 15 14 18 13 </span><br><span class="line">         72 79 71 77 76 75 74 78 73 </span><br><span class="line">         62 69 61 67 66 65 64 68 63 </span><br><span class="line">         52 59 51 57 56 55 54 58 53 </span><br><span class="line">         42 49 41 47 46 45 44 48 43 </span><br><span class="line">         82 89 81 87 86 85 84 88 83 </span><br><span class="line">         32 39 31 37 36 35 34 38 33 </span><br><span class="line">         922</span><br></pre></td></tr></table></figure><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><strong>内部部件之间由总线连接</strong><br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247623385765.jpg-style02" alt=""></p><ul><li>对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制</li><li>不同的CPU，寄存器的个数、结构是不相同的</li></ul><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><ul><li><p>ARM64拥有有31个64位的通用寄存器 x0 到 x30,这些寄存器通常用来存放一般性的数据，称为通用寄存器（有时也有特定用途）</p><ul><li>那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.</li><li>比如 w0 就是 x0的低32位!<br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247623516661.jpg-style02" alt=""></li></ul></li><li><p>通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算</p></li><li>假设内存中有块红色内存空间的值是3，现在想把它的值加1，并将结果存储到蓝色内存空间</li></ul><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-28-15247623786930.jpg-style02" alt=""></p><ul><li>CPU首先会将红色内存空间的值放到X0寄存器中：mov X0,红色内存空间</li><li>然后让X0寄存器与1相加：add X0,1</li><li>最后将值赋值给内存空间：mov 蓝色内存空间,X0</li></ul><p>###pc寄存器(program counter)</p><ul><li>为指令指针寄存器，它指示了CPU当前要读取指令的地址</li><li>在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息</li><li>CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义<ul><li>比如 1110 0000 0000 0011 0000 1000 1010 1010 </li><li>可以当做数据   0xE003008AA </li><li>也可以当做指令  mov    x0, x8</li></ul></li><li>CPU根据什么将内存中的信息看做指令？<ul><li>CPU将pc指向的内存单元的内容看做指令</li><li>如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过</li></ul></li></ul><h3 id="bl指令"><a href="#bl指令" class="headerlink" title="bl指令"></a>bl指令</h3><ul><li>CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令</li><li>ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如<ul><li>mov x0,#10、mov x1,#20</li></ul></li><li><p>但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能</p></li><li><p>ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令</p></li></ul><h3 id="bl指令-–-练习"><a href="#bl指令-–-练习" class="headerlink" title="bl指令 – 练习"></a>bl指令 – 练习</h3><p>现在有两段代码!假设程序先执行A,请写出指令执行顺序.最终寄存器x0的值是多少?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_A:</span><br><span class="line">    mov x0,#0xa0</span><br><span class="line">    mov x1,#0x00</span><br><span class="line">    add x1, x0, #0x14</span><br><span class="line">    mov x0,x1</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0,#0x0</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    add x0, x0, #0x10</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 汇编 </category>
          
          <category> 安全攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全攻防 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OpenGL学习 纹理上(五)</title>
      <link href="/2018/02/11/15244707402194/"/>
      <url>/2018/02/11/15244707402194/</url>
      <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="欢迎来到我的博客,请输入密码继续阅读." />    <label for="pass">欢迎来到我的博客,请输入密码继续阅读.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OpenGL学习 基本变化 (四)</title>
      <link href="/2018/02/09/15244691153165/"/>
      <url>/2018/02/09/15244691153165/</url>
      <content type="html"><![CDATA[<h3 id="一、抗锯齿"><a href="#一、抗锯齿" class="headerlink" title="一、抗锯齿"></a>一、抗锯齿</h3><p><strong>混合的两大功能:颜⾊色组合、抗锯⻮齿</strong></p><p>混合处理-抗锯齿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//开启混合处理理 glEnable(GL_BLEND);</span><br><span class="line">//指定混合因⼦子 GLBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">//指定混合⽅方程式 glBlendEquation(GL_FUNC_ADD);</span><br><span class="line">glEnable(GL_POINT_SMOOTH); //对点进⾏行行抗锯⻮齿处理理</span><br><span class="line">glEnable(GL_LINE_SMOOTH);//对线进⾏行行抗锯⻮齿处理理 </span><br><span class="line">glEnable(GL_POLYGON_SMOOTH);//对多边形进⾏行行抗锯⻮齿处理理</span><br></pre></td></tr></table></figure><h3 id="二、多重采样"><a href="#二、多重采样" class="headerlink" title="二、多重采样"></a>二、多重采样</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//1.可以调⽤用 glutInitDisplayMode 添加采样缓存区 glutInitDisplayMode(GLUT_MULTISAMPLE);</span><br><span class="line">//2.可以使⽤用glEnable| glDisable组合使⽤用GLUT_MULTISAMPLE 打开| 关闭 多重采样。</span><br><span class="line">glEnable(GLUT_MULTISAMPLE);</span><br><span class="line">glDisable(GLUT_MULTISAMPLE);</span><br></pre></td></tr></table></figure><h3 id="三、多重采样、抗锯⻮齿混合综合使⽤用"><a href="#三、多重采样、抗锯⻮齿混合综合使⽤用" class="headerlink" title="三、多重采样、抗锯⻮齿混合综合使⽤用"></a>三、多重采样、抗锯⻮齿混合综合使⽤用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glDisable(GLUT_MULTISAMPLE);</span><br><span class="line">glEnable(GL_POINT_SMOOTH);</span><br><span class="line">//Draw some smooth point</span><br><span class="line">glDisable(GL_POINT_SMOOTH);</span><br><span class="line">glDisable(GL_LINE_SMOOTH);</span><br><span class="line">glEnable(GLUT_MULTISAMPLE);</span><br><span class="line">//Draw some smooth polygon</span><br></pre></td></tr></table></figure><h3 id="四、多重采样-拓拓展"><a href="#四、多重采样-拓拓展" class="headerlink" title="四、多重采样 拓拓展"></a>四、多重采样 拓拓展</h3><p>多重采样缓存区在默认情况下使⽤用⽚片段RGB值，并不不包含颜 ⾊色的alpha成分，我们可以通过调⽤用glEnable来修改这个 ⾏行行为:</p><blockquote><ul><li>GL_SAMPLE_ALPHA_TO_COVERAGE 使⽤用alpha值</li><li>GL_SAMPLE_ALPHA_TO_ON 使⽤用alpha值并设为1，并 使⽤用它。</li><li>GL_SAMPLE_COVERAGE 使⽤用glSampleCoverage 所设置的值。</li></ul></blockquote><p>当启⽤用 GL_SAMPLE_COVERAGE 时，可以使⽤用 glSampleCoverage函数允许指定⼀一个特定的值，它是与⽚片 段覆盖值进⾏行行按位与操作的结果。</p><h3 id="五、向量"><a href="#五、向量" class="headerlink" title="五、向量"></a>五、向量</h3><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244696546998.jpg-style01" alt=""></p><blockquote><p>如何定义三维、四维向量量或三维向量量数组、四维向量量数组?<br>M3DVector3f :表示⼀一个三维的向量量(x,y,z)<br>M3DVector4f :表示⼀一个四维的向量量(x,y,z,w)(R,G,B,A)</p></blockquote><h3 id="六、点乘"><a href="#六、点乘" class="headerlink" title="六、点乘"></a>六、点乘</h3><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244697201684.jpg-style01" alt=""></p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244697388234.jpg-style01" alt=""></p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244698154537.jpg-style01" alt=""></p><h3 id="七、使用矩阵堆栈"><a href="#七、使用矩阵堆栈" class="headerlink" title="七、使用矩阵堆栈"></a>七、使用矩阵堆栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//类型</span><br><span class="line">GLMatrixStack::GLMatrixStack(int iStackDepth = 64);</span><br><span class="line"></span><br><span class="line">//在堆栈顶部载⼊入⼀一个单元矩阵</span><br><span class="line">void GLMatrixStack::LoadIdentity(void);</span><br><span class="line"></span><br><span class="line">//在堆栈顶部载⼊入任何矩阵 //参数:4*4矩阵</span><br><span class="line">void GLMatrixStack::LoadMatrix(const M3DMatrix44f m);</span><br><span class="line"></span><br><span class="line">//矩阵乘以矩阵堆栈顶部矩阵，相乘结果存储到堆栈的顶部</span><br><span class="line">void GLMatrixStack::MultMatrix(const M3DMatrix44f);</span><br><span class="line"></span><br><span class="line">//获取矩阵堆栈顶部的值 GetMatrix 函数 //为了了适应GLShaderMananger的使⽤用，或者获取顶部矩阵的副本</span><br><span class="line">const M3DMatrix44f &amp; GLMatrixStack::GetMatrix(void);</span><br><span class="line">void GLMatrixStack::GetMatrix(M3DMatrix44f mMatrix);</span><br></pre></td></tr></table></figure><h3 id="八、压栈、出栈"><a href="#八、压栈、出栈" class="headerlink" title="八、压栈、出栈"></a>八、压栈、出栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//将当前矩阵压⼊入堆栈</span><br><span class="line">void GLMatrixStack::PushMatrix(void);</span><br><span class="line">//将M3DMatrix44f 矩阵对象压⼊入当前矩阵堆栈</span><br><span class="line">void PushMatrix(const M3DMatrix44f mMatrix);</span><br><span class="line">//将GLFame 对象压⼊入矩阵对象</span><br><span class="line">void PushMatrix(GLFame &amp;frame);</span><br><span class="line">//出栈(出栈指的是移除顶部的矩阵对象) void GLMatrixStack::PopMatrix(void);</span><br></pre></td></tr></table></figure><h3 id="九、仿射变换-GLMastrixStack-内建了旋转-平移-缩放"><a href="#九、仿射变换-GLMastrixStack-内建了旋转-平移-缩放" class="headerlink" title="九、仿射变换 GLMastrixStack 内建了旋转\平移\缩放"></a>九、仿射变换 GLMastrixStack 内建了旋转\平移\缩放</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Rotate 函数angle参数是传递的度数，⽽而不不是弧度</span><br><span class="line">void MatrixStack::Rotate(GLfloat angle,GLfloat x,GLfloat</span><br><span class="line">y,GLfloat z);</span><br><span class="line">void MatrixStack::Translate(GLfloat x,GLfloat y,GLfloat z);</span><br><span class="line">void MatrixStack::Scale(GLfloat x,GLfloat y,GLfloat z);</span><br></pre></td></tr></table></figure><h3 id="十、使用照相机-和-角色帧-进行移动"><a href="#十、使用照相机-和-角色帧-进行移动" class="headerlink" title="十、使用照相机 和 角色帧 进行移动"></a>十、使用照相机 和 角色帧 进行移动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class GLFrame</span><br><span class="line">    &#123;</span><br><span class="line">protected:</span><br><span class="line">M3DVector3f vOrigin; // Where am I? M3DVector3f vForward; // Where am I going? M3DVector3f vUp; // Which way is up?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244700886510.jpg-style01" alt=""></p><h3 id="十一、GLFrame"><a href="#十一、GLFrame" class="headerlink" title="十一、GLFrame"></a>十一、GLFrame</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//将堆栈的顶部压⼊入任何矩阵</span><br><span class="line">void GLMatrixStack::LoadMatrix(GLFrame &amp;frame);</span><br><span class="line"></span><br><span class="line">//矩阵乘以矩阵堆栈顶部的矩阵。相乘结果存储在堆栈的顶部 </span><br><span class="line">void GLMatrixStack::MultMatrix(GLFrame &amp;frame);</span><br><span class="line"></span><br><span class="line">//将当前的矩阵压栈</span><br><span class="line">void GLMatrixStack::PushMatrix(GLFrame &amp;frame);</span><br></pre></td></tr></table></figure><h3 id="十二、照相机管理"><a href="#十二、照相机管理" class="headerlink" title="十二、照相机管理"></a>十二、照相机管理</h3><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244701898614.jpg-style01" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//GLFrame函数，这个函数⽤用来检索条件适合的照相矩阵</span><br><span class="line">void GetCameraMatrix(M3DMatrix44f m,bool bRotationOnly = flase);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OpenGL学习 深度测试(三)</title>
      <link href="/2018/02/08/15244657893765/"/>
      <url>/2018/02/08/15244657893765/</url>
      <content type="html"><![CDATA[<h3 id="一、渲染过程是中可能产生的问题"><a href="#一、渲染过程是中可能产生的问题" class="headerlink" title="一、渲染过程是中可能产生的问题"></a>一、渲染过程是中可能产生的问题</h3><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244658266117.jpg-style01" alt=""></p><p>解决办法：<br>1：油画法<br>2：正面、背面剔除。<br>3：深度测试。</p><h4 id="1-1、油画法"><a href="#1-1、油画法" class="headerlink" title="1.1、油画法"></a>1.1、油画法</h4><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244659608381.jpg-style01" alt=""></p><blockquote><p>油画法：比较消耗性能，重复绘制了重叠部分，对于多个图形叠加在一起的，难以分辨哪个是最上层的，导致渲染混乱</p></blockquote><h4 id="1-2、正面背面剔除"><a href="#1-2、正面背面剔除" class="headerlink" title="1.2、正面背面剔除"></a>1.2、正面背面剔除</h4><p>可以调用下面两个方法开启或关闭表面剔除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_CULL_FACE); //开启</span><br><span class="line">glDisable(GL_CULL_FACE); // 关闭</span><br></pre></td></tr></table></figure><p>该函数的原型如下<br><code>void glFrontFace(GLenum mode);</code></p><blockquote><p>mode 参数的可选的值有 GL_CW 和 GL_CCW （默认值是GL_CCW）</p></blockquote><blockquote><p>GL_CW 表示顶点的排列顺序是顺时针的面 是正面。<br>GL_CCW 表示顶点的排列顺序是逆时针的面是正面 （默认值）</p></blockquote><p><code>void glCullFace()</code></p><blockquote><p>GL_FRONT       // 正面剔除<br>GL_BACK         //  背面剔除<br>GL_FRONT_ANF_BACK 正面和反面都要剔除 </p></blockquote><h3 id="二、什么叫深度？"><a href="#二、什么叫深度？" class="headerlink" title="二、什么叫深度？"></a>二、什么叫深度？</h3><p><strong>所谓的深度，就在坐标系中，像素Z坐标距离观察者的距离<br>观察者，可以在任何位置，OpenGL会有专门有一块缓存区来存放Z值，深度缓冲区！<br>每个像素上的Z值。</strong></p><h3 id="三、深度缓冲去区的作用"><a href="#三、深度缓冲去区的作用" class="headerlink" title="三、深度缓冲去区的作用"></a>三、深度缓冲去区的作用</h3><p>一般情况下，我们绘制图形时，后面绘制的会覆盖前面的图形。一般绘制的顺序先后面再前面。<br>产生一个性能问题，就是遮盖部分，先绘制的会被覆盖，这没有任何意义的绘制。<br>深度测试就是用来解决这个问题的<br>它是如何处理的？<br>有了深度缓冲区之后，绘制的时候会检查Z,靠近观察者的覆盖。而不是靠绘制顺序来决定。</p><h3 id="四、如何使用深度缓冲区测试？"><a href="#四、如何使用深度缓冲区测试？" class="headerlink" title="四、如何使用深度缓冲区测试？"></a>四、如何使用深度缓冲区测试？</h3><p>为什么要测试？一旦开启之后就会先测试深度值再绘制</p><p><code>glEnable (GLDEPTHTEST);</code></p><blockquote><p>默认情况下Z值小的情况下会被覆盖<br>如果是观察者，在Z轴的正方向，Z值大的靠近观察者<br>如果是观察者，在Z轴的负方向，Z值小的靠近观察者</p></blockquote><h3 id="五、多边形模型"><a href="#五、多边形模型" class="headerlink" title="五、多边形模型"></a>五、多边形模型</h3><blockquote><p>使用<code>glPolygonMode(Glenum face,Glenum mode)</code> 函数来指定填充方式Face参数:GL_FRONT、GL_BACK、GL_FRONT_AND_BACKMode参数:GL_FILL(默认实心填充) 、GL_LINE、GL_POINT</p></blockquote><h3 id="六、多边形偏移"><a href="#六、多边形偏移" class="headerlink" title="六、多边形偏移"></a>六、多边形偏移</h3><p><strong>深度测试实现深度的过程中，可能产生的2种问题:<br>1、z-fighting(z冲突)<br>2、图形重叠(无法体现深度)</strong></p><h3 id="七、如何解决深度值相同，造成的冲突问题"><a href="#七、如何解决深度值相同，造成的冲突问题" class="headerlink" title="七、如何解决深度值相同，造成的冲突问题"></a>七、如何解决深度值相同，造成的冲突问题</h3><p><strong>第一种方法：</strong><br>在第二次绘制时，稍微偏移一点点解决这个问题。注意：必须非常小心确保Z值的间隙</p><p><strong>第二种方法：</strong><br>采样<code>glPolygonOffset</code> 函数。使得可以调节片段的深度值。使得深度之偏移而不产生悬浮</p><p><code>glPolygonOffset</code> 函数<br><code>void glPolygonOffset(Glfloat factor,Glfloat units);</code></p><blockquote><p>应用到片段上总偏移计算方程式:<br>Depth Offset = (DZ <em> factor) + (r </em> units);<br>DZ:深度值(Z值)r:使得深度缓冲区产生变化的最小值<br>负值，将使得z值距离我们更近，而正值，将使得z值距离我们更远，对于上节课的案例，我们设置factor和units设置为-1，0</p></blockquote><h3 id="八、裁剪"><a href="#八、裁剪" class="headerlink" title="八、裁剪"></a>八、裁剪</h3><p>在OpenGL 提高渲染的一种方式，只刷新屏幕上发生变化的部分。OpenGL 允许我们将要进行渲染的窗口只去指定一个裁剪框。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1 开启裁剪测试</span><br><span class="line">glEnable(GL_SCISSOR_TEST);</span><br><span class="line">//2.关闭裁剪测试</span><br><span class="line">glDisable(GL_SCISSOR_TEST);</span><br><span class="line">//3.指定裁剪窗口</span><br><span class="line">//x,y:指定裁剪框左下角位置;width,height:指定裁剪尺寸</span><br><span class="line">void glScissor(Glint x,Glint y,GLSize width,GLSize height);</span><br></pre></td></tr></table></figure><h3 id="九、混合"><a href="#九、混合" class="headerlink" title="九、混合"></a>九、混合</h3><p>我们把OpenGL 渲染时会把颜色值存在颜色缓存区中，每个片段的深度值也是放在深度缓冲区。当深度缓冲区被关闭时，新的颜色将简单的覆盖原来颜色缓存区存在的颜色值，当深度缓冲区再次打开时，新的颜色片段只是当它们比原来的值更接近邻近的裁剪平面才会替换原来的颜色片段。<br><code>glEnable(GL_BlEND);</code></p><h4 id="9-1-组合颜色"><a href="#9-1-组合颜色" class="headerlink" title="9.1 组合颜色"></a>9.1 组合颜色</h4><p>目标颜色:已经存储在颜色缓存区的颜色值<br>源颜色:作为当前渲染命令结果进入颜色缓存区的颜色值<br>当混合功能被启动时，源颜色和目标颜色的组合方式是混合方程式控制的。在默认情况下，混合方程式如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cf = (Cs * S) + (Cd * D)</span><br><span class="line">Cf :最终计算参数的颜色</span><br><span class="line">Cs : 源颜色</span><br><span class="line">Cd :目标颜色</span><br><span class="line">S:源混合因子</span><br><span class="line">D:目标混合因子</span><br></pre></td></tr></table></figure><h4 id="9-2-设置混合因子"><a href="#9-2-设置混合因子" class="headerlink" title="9.2 设置混合因子"></a>9.2 设置混合因子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置混合因子，需要用到glBlendFun函数</span><br><span class="line">glBlendFunc(GLenum S,GLenum D);</span><br><span class="line">S:源混合因子</span><br><span class="line">D:目标混合因子</span><br></pre></td></tr></table></figure><h4 id="9-3-混合因子枚举列表"><a href="#9-3-混合因子枚举列表" class="headerlink" title="9.3 混合因子枚举列表"></a>9.3 混合因子枚举列表</h4><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244660140634.jpg-style01" alt=""></p><p>表中R、G、B、A 分别代表红、绿、蓝、alpha。<br>表中下标S、D，分别代表源、目标<br>表中C 代表常量颜色(默认黑色)</p><h4 id="9-4总结"><a href="#9-4总结" class="headerlink" title="9.4总结"></a>9.4总结</h4><p>最终颜色是以原先的红色(目标颜色)与 后来的蓝色(源颜色)进行组合。源颜色的alpha值越高，添加的蓝色颜色成分越高，目标颜色所保留的成分就会越少。<br>混合函数经常用于实现在其他一些不透明的物体前面绘制一个透明物体的效果</p><h3 id="十、改变组合方程式"><a href="#十、改变组合方程式" class="headerlink" title="十、改变组合方程式"></a>十、改变组合方程式</h3><p>默认混合方程式:<br><code>Cf = (CsS)+(CdD)</code><br>实际上远不止这一种混合方程式，我们可以从5个不同的方程式中进行选择</p><h4 id="10-1-改变混合方程式的函数-glBlendEquation"><a href="#10-1-改变混合方程式的函数-glBlendEquation" class="headerlink" title="10.1 改变混合方程式的函数 glBlendEquation()"></a>10.1 改变混合方程式的函数 glBlendEquation()</h4><p>选择混合方程式的函数:<br><code>glbBlendEquation(GLenum mode);</code></p><h4 id="10-2-glBlendFuncSeparate-函数"><a href="#10-2-glBlendFuncSeparate-函数" class="headerlink" title="10.2 glBlendFuncSeparate 函数"></a>10.2 glBlendFuncSeparate 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">除了能使用glBlendFunc 来设置混合因子，还可以有更灵活的选择。</span><br><span class="line">strRGB: 源颜色的混合因子</span><br><span class="line">dstRGB: 目标颜色的混合因子</span><br><span class="line">strAlpha: 源颜色的Alpha因子</span><br><span class="line">dstAlpah: 目标颜色的Alpha因子</span><br><span class="line"></span><br><span class="line">void glBlendFuncSeparate(GLenum strRGB,GLenum dstRGB,GLenum strAlpha,GLenumdstAlpha);</span><br></pre></td></tr></table></figure><h4 id="10-3-glBlendFuncSeparate-注意"><a href="#10-3-glBlendFuncSeparate-注意" class="headerlink" title="10.3 glBlendFuncSeparate 注意"></a>10.3 glBlendFuncSeparate 注意</h4><blockquote><p>glBlendFunc 指定 源和目标 RGBA值的混合函数;但是glBlendFuncSeparate函数则允许为RGB 和 Alpha 成分单独指定混合函数。<br>在混合因子表中，GL_CONSTANT_COLOR,GL_ONE_MINUS_CONSTANT_COLOR,GL_CONSTANT_ALPHA,GL_ONE_MINUS_CONSTANT值允许混合方程式中引入一个常量混合颜色。</p></blockquote><h4 id="10-4-常量混合颜色"><a href="#10-4-常量混合颜色" class="headerlink" title="10.4 常量混合颜色"></a>10.4 常量混合颜色</h4><p>常量混合颜色，默认初始化为黑色(0.0f,0.0f,0.0f,0.0f)，但是还是可以修改这个常量混合颜色。<br><code>void glBlendColor(GLclampf red ,GLclampf green ,GLclampf blue ,GLclampf alpha );</code></p>]]></content>
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OpenGL学习 基础渲染(二)</title>
      <link href="/2018/02/07/15244572175577/"/>
      <url>/2018/02/07/15244572175577/</url>
      <content type="html"><![CDATA[<blockquote><p>在OpenGL 3.0之前，OpenGL 包含一个固定功能的管线，它可以在不使用着色器的情况下处理几何与像素数据。在3.1版本开始，固定管线从核心模式去掉。因此现在需要使用着色器来完成工作。<br>使 OpenGL 来说，我们会使 GLSL,(OpenGL Shading Langruage，它是在OpenGL 2.0版本发布的)。 语法与“C、C++”类似。</p></blockquote><h3 id="一、基础图形管线"><a href="#一、基础图形管线" class="headerlink" title="一、基础图形管线"></a>一、基础图形管线</h3><p>OpenGL 中图元只不过是顶点的集合以预定义的方式结合在一起。管线分为:2个部分，上半部分是客户机端，下半部分是服务器端。</p><p>客户端是存储在CPU存储 中的，并且在应用程序中执行 ，或者在主系统内存的驱动程序中执行。驱动程序会将渲染命令和数组组合起来，发送给服务执执 !(在一台典型的个人计算机上，服务器就是实际上就是图形加速卡上的硬件和内存)<br>服务器和 客户机在功能上也是异步的。 它们是各自独力的软件块或硬件块。我们是希望它们2个端都尽量在 不停的工作。客户端不断的把数据块和命令块组合在一起输送到缓冲区，然后缓冲区就会发送到服务器执 。</p><p>如果服务器停止工作等待客户机，或者客户机停止作来等待服务器做好接受更多的命令和准备，我们把这种情况成为管线停滞</p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244572931328.jpg-style01" alt=""></p><h3 id="二、着色器"><a href="#二、着色器" class="headerlink" title="二、着色器"></a>二、着色器</h3><p><strong>渲染过程，必备的两个着色器“顶点着色器”和“片元着色器”。</strong><br>上图的Vertex Shader(顶点着色器) 和 Fragment Shader(片元着色器)<br>着色器是使用GLSL编写的程序，看起来与C语言非常类似。 着色器必须从源代码中编译和链接在一起。最终准备就绪的着色器程序<br>顶点着色器 –&gt;处理从客户机输入的数据、应用变换、进行其他的类型的数学运算来计算关照效果、位移、颜 值等等。(**为了渲染共有3个顶点的三角形，顶点着色器将执 3次，也就是为 了每个顶点执一次)在目前的硬件上有多个执行单元同时运行 ，就意味着所有的3个顶点可以同时进行处理 !</p><p>图上(primitive Assembly 说明的是:3个顶点已经组合在一起， 三角形已经逐个片段的进行光栅化。每个片段通过执片元元着器，进行 填充。 元着器会输出我们将屏幕上看到的最终颜色值。</p><h3 id="三、3种向OpenGL着色器传递渲染数据的方法"><a href="#三、3种向OpenGL着色器传递渲染数据的方法" class="headerlink" title="三、3种向OpenGL着色器传递渲染数据的方法"></a>三、3种向OpenGL着色器传递渲染数据的方法</h3><ul><li>属性</li><li>Uniform</li><li>纹理<h4 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3.1 属性"></a>3.1 属性</h4></li></ul><p><strong>属性：就是对一个顶点都要作改变的数据元素。实际上，顶点位置本身就是一个属性。属性可以是浮点类型、整型、布尔类型。</strong></p><p><strong>属性总是以四维向 的形式进行内部存储的，即使我们不会使用所有的4个分量。</strong>一个顶点位置可能存储(x,y,z)，将占有4个分量中的3个。<br>实际上如果是在平面情况下:只要在xy平面上就能绘制，那么Z分量就会自动设置为0;<br>属性还可以是:纹理坐标、颜色值、关照计算表面法线<br>在顶点程序(shader渲染)可以代表你想要的任何意义。因为都是你设定的。<br>属性会从本地客户机内存中复制存储在图形硬件中的一个缓冲区上。这些属性只提供给顶点着 使 ，对于 元着 有太 意义。<br>声明:这些属性对每个顶点都要做改变，但并不意味着它们的值不能重复。通常情况下，它们都是 不一样样的，但有可能整个数组都是同一值的情况。</p><h4 id="3-2-Uniform"><a href="#3-2-Uniform" class="headerlink" title="3.2 Uniform"></a>3.2 Uniform</h4><p><strong>属性是 种对整个批次属性都取统一值的单一值，它是不变的。</strong></p><p><strong>通过设置uniform变量就紧接着发送一个图元批次命令</strong>。Uniform变量实际上可以无限次限制地使用，设置一个应用于整个表面的单个颜色值，还可以设置一个时间值。在每次渲染某种类型的顶点动画时修改它。<br>注意:这 的uniform 变量每个批次改变一次，而不是每个顶点改变一次。<br>uniform变量最常见的应该是在顶点渲染中设置变换矩阵<br>与属性相同点:可以是浮点值、整数、布尔值<br>与属性不同点:顶点着色器和片元着色器都可以用 uniform变量 。uniform 变量还可以是标量类型、 矢量类型、uniform矩阵。</p><h4 id="3-3-纹理"><a href="#3-3-纹理" class="headerlink" title="3.3 纹理"></a>3.3 纹理</h4><p><strong>传递给着器的第三种数据类型:纹理数据</strong></p><p><strong>在顶点着色器、 片段着色器中都可以对纹理数据进行采样和筛选。</strong><br>典型的应用场景: 片段着色器对一个纹理值进行采样，然后在一个三角形表面应用渲染纹理数据。<br>纹理数据， 不仅仅表现在图形，很多图形文件格式都是以无符号字节(每个颜色通道8位)形式对颜分量进行存储的。</p><h4 id="3-4-输出"><a href="#3-4-输出" class="headerlink" title="3.4 输出"></a>3.4 输出</h4><p>输出数据：简单的从一个阶段传递到下一个阶段。<br>客户端的代码接触不到这些内部变量。我们的OpenGL开发暂时接触不到！</p><h3 id="四、创建坐标系"><a href="#四、创建坐标系" class="headerlink" title="四、创建坐标系"></a>四、创建坐标系</h3><h4 id="4-1-正投影"><a href="#4-1-正投影" class="headerlink" title="4.1 正投影"></a>4.1 正投影</h4><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244573118476.jpg-style01" alt=""></p><p>这就是一个正投影的 例子，在所在3个轴(X,Y,Z)中，它们的范围都是从-100到+100。这个视景体将包括所有的 几何图形。<br>如果你指定 了视景体外的几何图形，就会被裁减掉!(它将沿着视景体的边界进行剪切)在正投影中，所有在这个空间范围内的所有东西都将被呈现在屏幕上。 存在照相机或视点坐标系的概念。</p><h4 id="4-2透视投影"><a href="#4-2透视投影" class="headerlink" title="4.2透视投影"></a>4.2透视投影</h4><p><code>setPerspective(float ffov,float fAspect,float fNear,float fFar)</code><br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244573321853.jpg-style01" alt=""></p><p>透视投影会进行透视除法对距离观察者很远的对象进行缩短和收缩。在投影到屏幕之后，视景体背面与视景体正面的宽度测量标准不同。<br>上图所示:平截头体(frustum)的 何体，它的观察方向是从金字塔的尖端到宽阔端。观察者的视点与金字塔的尖端拉开一定距离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GLFrustum类通过setPerspective  法为我们构建一个平截头体。</span><br><span class="line">参数:</span><br><span class="line">fFov:垂直方向上的视场角度</span><br><span class="line">fAspect:窗口的宽度与高度的纵横 </span><br><span class="line">fNear:近裁剪面距离</span><br><span class="line">fFar:远裁剪面距离</span><br><span class="line">纵横  = 宽(w)/ (h)</span><br><span class="line"></span><br><span class="line">CLFrustum::SetPerspective(float fFov,float fAspect,float fNear,float fFar);</span><br></pre></td></tr></table></figure><h3 id="五、使用存储着色器"><a href="#五、使用存储着色器" class="headerlink" title="五、使用存储着色器"></a>五、使用存储着色器</h3><h4 id="5-1、使用背景"><a href="#5-1、使用背景" class="headerlink" title="5.1、使用背景"></a>5.1、使用背景</h4><h4 id="5-2存储着色器的使用"><a href="#5-2存储着色器的使用" class="headerlink" title="5.2存储着色器的使用"></a>5.2存储着色器的使用</h4><ul><li>单位着色器</li><li>平面着色器</li><li>上色着色器</li><li>默认光源着色器</li><li>点光源着色器</li><li>纹理替换矩阵</li><li>纹理调整着色器</li><li>纹理光源着色器</li></ul><h4 id="5-3-GLShaderManager-的初始化"><a href="#5-3-GLShaderManager-的初始化" class="headerlink" title="5.3 GLShaderManager 的初始化"></a>5.3 GLShaderManager 的初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义着色器</span><br><span class="line">GLShaderMananger shaderManager;</span><br><span class="line"></span><br><span class="line">// 初始化着色器</span><br><span class="line">shaderManager.IntalizeStockShaders()</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">shaderManager userStockManager(参数列表)</span><br></pre></td></tr></table></figure><h4 id="5-4-GLShaderManager-属性"><a href="#5-4-GLShaderManager-属性" class="headerlink" title="5.4 GLShaderManager 属性"></a>5.4 GLShaderManager 属性</h4><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244573506921.jpg-style01" alt=""></p><p>存储着色器为每一个变量都使用一致的内部变量命名规则和相同的属性槽，以上就是存储着色器的属性列表。</p><h4 id="5-5-GLShanderManager-的-uniform值"><a href="#5-5-GLShanderManager-的-uniform值" class="headerlink" title="5.5 GLShanderManager 的 uniform值"></a>5.5 GLShanderManager 的 uniform值</h4><p>一般情况，要对几何图形进行渲染，我们需要给对象递交属性矩阵， 先要绑定我们想要使用的着色器程序上，并提供程序的uniform值。但是<code>GLShanderManager</code> 类可以暂时为我们完成工作。<br><code>useStockShader</code> 函数会选择一个存储着色器并提供这个着色器的uniform值。</p><p><strong>单位着色器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//单位着色器:只是简单地使用默认笛卡尔坐标系(坐标范围(-1.0，1.0))。所有的片段都应用同一种颜色 ，几何图形为心和未渲染的。</span><br><span class="line">//需要设置存储着色器一个属性: GLT_ATTRIBUTE_VERTEX(顶点分量)</span><br><span class="line">//参数2:vColor[4],你需要的颜色</span><br><span class="line"></span><br><span class="line">GLShaderManager::UserStockShader(GLT_ATTRIBUTE_VERTEX,GLfloat vColor[4]);</span><br></pre></td></tr></table></figure><p><strong>平面着色器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//参数1:平面着色器 </span><br><span class="line">//参数2:允许变化的4*4矩阵</span><br><span class="line">//参数3:颜色</span><br><span class="line">//它将统一着色器进行了拓展。允许为几何图形变换指定一个 4 * 4 变换矩阵。经常被称为“模型视图投影矩阵”</span><br><span class="line"></span><br><span class="line">GLShaderManager::UserStockShader(GLT_SHADER_FLAT,GLfloat mvp[16],GLfloat vColor[4]);</span><br></pre></td></tr></table></figure><p><strong>上色着器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在几何图形中应用的变换矩阵。</span><br><span class="line">//需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量 ) 和GLT_ATTRIBUTE_COLOR(颜色分量 ) 2个属性。颜色值将被平滑地插入顶点之间(平滑着色 )</span><br><span class="line"></span><br><span class="line">GLShaderManager::UserStockShader(GLT_SHADER_SHADED,GLfloat mvp[16]);</span><br></pre></td></tr></table></figure><p><strong>默认光源着色器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//参数1:默认光源着色器  </span><br><span class="line">//参数2:模型视图矩阵</span><br><span class="line">//参数3:投影矩阵</span><br><span class="line">//参数4:颜 值</span><br><span class="line">//这种着色器，是对象产 阴影和关照的效果。需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和GLT_ATTRIBUTE_NORMAL(表面法线)</span><br><span class="line"></span><br><span class="line">GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT,GLfloat mvMatrix[16],GLfloatpMatrix[16],GLfloat vColor[4]);</span><br></pre></td></tr></table></figure><p><strong>点光源着色器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//参数1:点光源着色器</span><br><span class="line">//参数2:模型视图矩阵</span><br><span class="line">//参数3:投影矩阵</span><br><span class="line">//参数4:视点坐标光源位置</span><br><span class="line">//参数5:颜色值</span><br><span class="line">//点光源着色器和默认光源着色器很相似，区别在于:光源位置是特定的。同样需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和GLT_ATTRIBUTE_NORMAL(表面法线)</span><br><span class="line"></span><br><span class="line">GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT_DIEF,GLfloatmvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vColor[4]);</span><br></pre></td></tr></table></figure><p><strong>纹理替换矩阵着色器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//着色器通过给定的模型视图投影矩阵，使用绑定到 nTextureUnit (纹 单元) 指定纹理单元的纹理对几何图形进行变化。 段颜 :是直接从纹理样本中直接获取的。</span><br><span class="line">//需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和 GLT_ATTRIBUTE_NORMAL(表面法线)</span><br><span class="line"></span><br><span class="line">GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_REPLACE,GLfloat mvMatrix[16],GLintnTextureUnit);</span><br></pre></td></tr></table></figure><p><strong>纹理调整着色器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//将一个基本色乘以一个取自纹理单元 nTextureUnit 的纹 。需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和 GLT_ATTRIBUTE_TEXTURE0(纹理坐标)</span><br><span class="line"></span><br><span class="line">GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_MODULATE,GLfloatmvMatrix[16],GLfloat vColor[4],GLint nTextureUnit);</span><br></pre></td></tr></table></figure><p><strong>纹理光源着色器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//参数1:纹理光源着色器 </span><br><span class="line">//参数2:投影矩阵</span><br><span class="line">//参数3:视觉空间中的光源位置</span><br><span class="line">//参数4: 何图形的基本色</span><br><span class="line">//参数5:将要使用的纹理单元</span><br><span class="line">//将一个纹理通过漫反射照明计算机进行调整(相乘)。光线在视觉空间中的位置是给定的。</span><br><span class="line">//需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和 GLT_ATTRIBUTE_TEXTURE0(纹理坐标)、GLT_ATTRIBUTE_NORMAL(表面法线)</span><br><span class="line"></span><br><span class="line">GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIEF,GLfloatmvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vBaseColor[4],GLint nTextureUnit);</span><br></pre></td></tr></table></figure><h3 id="六、OpenGL图元"><a href="#六、OpenGL图元" class="headerlink" title="六、OpenGL图元"></a>六、OpenGL图元</h3><ul><li>点</li><li>线</li><li>线带</li><li>线环</li><li>三角形</li><li>三角形金字塔</li><li>三角形带</li><li>三角形扇</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//修改点的大小</span><br><span class="line">glPointSize(4.0f);</span><br><span class="line">//设置点的大小范围，点和点之间的距离</span><br><span class="line">GLfloat sizes[2] = &#123;2.0f,4.0f&#125;;</span><br><span class="line">GLfloat stepSize = 1.0f;</span><br><span class="line">//获取点的大小范围和步长glGetFloatv(GL_POINT_SIZE_RANGE,sizes);</span><br><span class="line">glGetFloatv(GL_POINT_GRAULRITY,&amp;stepSize);</span><br><span class="line">//3.通过使用程序点大小模式设置点大小</span><br><span class="line">glEnable(GL_PROGAM_POINT_SIZE);</span><br><span class="line">//GLSL程序</span><br><span class="line">gl_PointSize = 5.0f;</span><br></pre></td></tr></table></figure><h3 id="七、GLBatch容器-帮助类"><a href="#七、GLBatch容器-帮助类" class="headerlink" title="七、GLBatch容器(帮助类)"></a>七、GLBatch容器(帮助类)</h3><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244573753588.jpg-style01" alt=""></p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244573813628.jpg-style01" alt=""></p>]]></content>
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OpenGL学习 在Mac上搭建OpenGL环境(一)</title>
      <link href="/2018/02/05/15244567239248/"/>
      <url>/2018/02/05/15244567239248/</url>
      <content type="html"><![CDATA[<p>一、准备资源</p><ol><li>CLTools</li><li>glew</li><li>libGLTools.a</li><li>百度云盘资源地址：链接: <a href="https://pan.baidu.com/s/1ebesf8" target="_blank" rel="noopener">https://pan.baidu.com/s/1ebesf8</a> 密码: g99g</li></ol><p>二、现在开始配置 openGL 环境</p><p>1、打开Xcode -&gt; macOS -&gt; Cocoa Application</p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244560096062.jpg-style01" alt=""></p><p>2、选中Build Phases, 选择 Link Binary With Libraries ,点击 +  搜索添加 OpenGl.framework 和 GLUT.framework 两个系统库.</p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244567872134.jpg-style01" alt=""></p><p>3、把下载好的 include 和 libGLTools.a 拖入到项目里面，选中 Copy item if needed 和 Create groups<br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244560540915.jpg-style01" alt=""></p><p><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244560749630.jpg-style01" alt=""></p><p>4、然后点击 Build Settings, 选则All ，找到 Header Search Paths, 把你拖到项目里的 include 文件夹路径 拖到里面。<br>把libGLTools.a 文件拖到Framework 里面<br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244560944363.jpg-style01" alt=""></p><p>5、接着把 AppDelegate.h, AppDelegate.m,ViewController.h,ViewControllers.m 文件删除掉<br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244561074509.jpg-style01" alt=""><br>OpenGL006.jpeg</p><p>6、添加新的文件，选择 C++ File ,Name 设置为main，并且不要勾选下面的 also create a header file,点击Next ,生成main.cpp文件<br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244561195444.jpg-style01" alt=""><br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244561298591.jpg-style01" alt=""></p><p>7、然后把main.m 文件删除掉。<br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244561437251.jpg-style01" alt=""></p><p>8、把下面的代码复制到 main.cpp 里面，然后把项目跑起来 Run B<img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244561563956.jpg-style01" alt=""><br>OpenGL010.jpeg</p><p>三、注意事项与报错处理</p><p>如果报下面的错误<br>ld: library not found for -lGLTools<br>clang: error: linker command failed with exit code 1 (use -v to see invocation)<br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244561673939.jpg-style01" alt=""></p><p>选择General 下面 的林科大Frameworks and Libraries<br>选中 libGLTools.a 点击下面的 一 删除掉，然后点击 + , 选择 Add Other,然后找到你项目里面的 libGLTools.a，选中并点击 open，重新 Run Build 就好了。<br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244561986179.jpg-style01" alt=""><br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244562088552.jpg-style01" alt=""><br><img src="http://p7l9kf5i4.bkt.clouddn.com/2018-04-23-15244562198692.jpg-style01" alt=""></p><p>注意 ：新建的main.cpp 文件里面 必须要有 main 函数，不然直接build 会报错</p>]]></content>
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 开发 CADisplayLink 定时器的了解与使用</title>
      <link href="/2017/09/19/iOS%E5%BC%80%E5%8F%91CADisplayLink-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/09/19/iOS%E5%BC%80%E5%8F%91CADisplayLink-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><h4 id="1、所在框架"><a href="#1、所在框架" class="headerlink" title="1、所在框架"></a>1、所在框架</h4><p><code>CADisplayLink</code>和其它<code>CoreAnimation</code>类一样，都是在QuartzCore.framework里。</p><p><strong>1.1什么是<code>CADisplayLink</code>?</strong></p><p><strong><code>CADisplayLink</code>是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 <code>CADisplayLink</code> 对象，把它添加到一个runloop中，并给它提供一个 target 和selector 在屏幕刷新的时候调用。</strong></p><p>一但 <code>CADisplayLink</code> 以特定的模式注册到runloop之后，每当屏幕需要刷新的时候，runloop就会调用<code>CADisplayLink</code>绑定的target上的selector，这时target可以读到 <code>CADisplayLink</code> 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。</p><p>在添加进runloop的时候我们应该选用高一些的优先级，来保证动画的平滑。可以设想一下，我们在动画的过程中，runloop被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行<code>CADisplayLink</code>的调用，从而造成动画过程的卡顿，使动画不流畅。</p><p><code>duration</code>属性提供了每帧之间的时间，也就是屏幕每次刷新之间的的时间。我们可以使用这个时间来计算出下一帧要显示的UI的数值。但是 <code>duration</code>只是个大概的时间，如果CPU忙于其它计算，就没法保证以相同的频率执行屏幕的绘制操作，这样会跳过几次调用回调方法的机会。<br><code>frameInterval</code>属性是可读可写的NSInteger型值，标识间隔多少帧调用一次selector 方法，默认值是1，即每帧都调用一次。如果每帧都调用一次的话，对于iOS设备来说那刷新频率就是60HZ也就是每秒60次，如果将 frameInterval 设为2 那么就会两帧调用一次，也就是变成了每秒刷新30次。</p><p>我们通过pause属性开控制<code>CADisplayLink</code>的运行。当我们想结束一个<code>CADisplayLink</code>的时候，应该调用-(void)invalidate<br>从runloop中删除并删除之前绑定的 target跟selector<br>另外<code>CADisplayLink</code> 不能被继承。</p><h4 id="2、功能"><a href="#2、功能" class="headerlink" title="2、功能"></a>2、功能</h4><p><code>CADisplayLink</code>最主要的特征是能提供一个周期性的调用我们赋给它的selector的机制，从这点上看它很像定时器NSTimer。</p><h4 id="3、使用方式"><a href="#3、使用方式" class="headerlink" title="3、使用方式"></a>3、使用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)startDisplayLink  </span><br><span class="line">&#123;  </span><br><span class="line">    self.displayLink = [`CADisplayLink`     displayLinkWithTarget:self selector:@selector(handleDisplayLink:)];  </span><br><span class="line">    [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">- (void)handleDisplayLink:(`CADisplayLink` *)displayLink  </span><br><span class="line">&#123;  </span><br><span class="line">      //do something  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">- (void)stopDisplayLink  </span><br><span class="line">&#123;  </span><br><span class="line">    [self.displayLink invalidate];  </span><br><span class="line">    self.displayLink = nil;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当把<code>CADisplayLink</code>对象add到runloop中后，selector就能被周期性调用，类似于NSTimer被启动了；执行invalidate操作时，<code>CADisplayLink</code>对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。</p><p><code>CADisplayLink</code> 与 NSTimer 有什么不同</p><p>iOS设备的屏幕刷新频率是固定的，<code>CADisplayLink</code>在正常情况下会在每次刷新结束都被调用，精确度相当高。<br>NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。<br><code>CADisplayLink</code>使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 <code>CADisplayLink</code>比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。</p><h3 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h3><p>下面结合<code>NSTimer</code>来介绍<code>CADisplayLink</code>，与NSTimer不同的地方有：</p><h4 id="1、原理不同"><a href="#1、原理不同" class="headerlink" title="1、原理不同"></a>1、原理不同</h4><p><code>CADisplayLink</code>是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。<code>CADisplayLink</code>以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向<code>CADisplayLink</code>指定的target发送一次指定的selector消息， <code>CADisplayLink</code>类对应的selector就会被调用一次。<br>NSTimer以指定的模式注册到runloop后，每当设定的周期时间到达后，runloop会向指定的target发送一次指定的selector消息。</p><h4 id="2、周期设置方式不同"><a href="#2、周期设置方式不同" class="headerlink" title="2、周期设置方式不同"></a>2、周期设置方式不同</h4><p>iOS设备的屏幕刷新频率(FPS)是60Hz，因此<code>CADisplayLink</code>的selector默认调用周期是每秒60次，这个周期可以通过frameInterval属性设置，<code>CADisplayLink</code>的selector每秒调用次数=60/frameInterval。比如当frameInterval设为2，每秒调用就变成30次。因此，<code>CADisplayLink</code>周期的设置方式略显不便。<br>NSTimer的selector调用周期可以在初始化时直接设定，相对就灵活的多。</p><h4 id="3、精确度不同"><a href="#3、精确度不同" class="headerlink" title="3、精确度不同"></a>3、精确度不同</h4><p>iOS设备的屏幕刷新频率是固定的，<code>CADisplayLink</code>在正常情况下会在每次刷新结束都被调用，精确度相当高。<br>NSTimer的精确度就显得低了点，比如<code>NSTimer</code>的触发时间到的时候，runloop如果在忙于别的调用，触发时间就会推迟到下一个runloop周期。更有甚者，在OS X v10.9以后为了尽量避免在<code>NSTimer</code>触发时间到了而去中断当前处理的任务，NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间范围。</p><h4 id="4、使用场合"><a href="#4、使用场合" class="headerlink" title="4、使用场合"></a>4、使用场合</h4><p>从原理上不难看出，<code>CADisplayLink</code>使用场合相对专一，适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。<br>NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。</p><h3 id="三、重要属性"><a href="#三、重要属性" class="headerlink" title="三、重要属性"></a>三、重要属性</h3><p>下面不完整的列出了<code>CADisplayLink</code>的几个重要属性：</p><h4 id="1、frameInterval"><a href="#1、frameInterval" class="headerlink" title="1、frameInterval"></a>1、frameInterval</h4><p>可读可写的<code>NSInteger</code>型值，标识间隔多少帧调用一次<code>selector</code>方法，默认值是1，即每帧都调用一次。官方文档中强调，当该值被设定小于1时，结果是不可预知的。</p><h4 id="2、duration"><a href="#2、duration" class="headerlink" title="2、duration"></a>2、duration</h4><p>只读的<code>CFTimeInterval</code>值，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在<code>target</code>的<code>selector</code>被首次调用以后才会被赋值。<code>selector</code>的调用间隔时间计算方式是：时间=duration×frameInterval。<br>现存的iOS设备屏幕的FPS都是60Hz，这一点可以从<code>CADisplayLink</code>的<code>duration</code>属性看出来。duration的值都是0.166666…，即1/60。尽管如此，我们并没法确定苹果不会改变FPS，如果以后某一天将FPS提升到了120Hz了怎么办呢？这时，你设置了<code>frameInterval</code>属性值为2期望每秒刷新30次，却发现每秒刷新了60次，结果可想而知，出于安全考虑，还是先根据<code>duration</code>判断屏幕的FPS再去使用<code>CADisplayLink</code>。</p><h4 id="3、timestamp"><a href="#3、timestamp" class="headerlink" title="3、timestamp"></a>3、timestamp</h4><p>只读的<code>CFTimeInterval</code>值，表示屏幕显示的上一帧的时间戳，这个属性通常被target用来计算下一帧中应该显示的内容。</p><p>虽然名为时间戳，但这和常见的unix时间戳差异很大，事实上这是<code>CoreAnimation</code>使用的时间格式。每个CALayer都有一个本地时间（CALayer本地时间的具体作用会在后续文章中说明），可以获取当前CALayer的本地时间并打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFTimeInterval localLayerTime = [myLayer convertTime:CACurrentMediaTime() fromLayer:nil];  </span><br><span class="line">NSLog(@&quot;localLayerTime:%f&quot;,localLayerTime);</span><br></pre></td></tr></table></figure><h3 id="四、注意"><a href="#四、注意" class="headerlink" title="四、注意"></a>四、注意</h3><p>iOS并不能保证能以每秒60次的频率调用回调方法，这取决于：</p><h4 id="1、CPU的空闲程度"><a href="#1、CPU的空闲程度" class="headerlink" title="1、CPU的空闲程度"></a>1、CPU的空闲程度</h4><p>如果CPU忙于其它计算，就没法保证以60HZ执行屏幕的绘制动作，导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。</p><h4 id="2、执行回调方法所用的时间"><a href="#2、执行回调方法所用的时间" class="headerlink" title="2、执行回调方法所用的时间"></a>2、执行回调方法所用的时间</h4><p>如果执行回调时间大于重绘每帧的间隔时间，就会导致跳过若干次回调调用机会，这取决于执行时间长短。</p><h4 id="3-通常来讲"><a href="#3-通常来讲" class="headerlink" title="3.通常来讲"></a>3.通常来讲</h4><p>iOS设备的刷新频率事60HZ也就是每秒60次。那么每一次刷新的时间就是1/60秒 大概16.7毫秒。当我们的<code>frameInterval</code>值为1的时候我们需要保证的是 <code>CADisplayLink</code>调用的｀target｀的函数计算时间不应该大于 16.7否则就会出现严重的丢帧现象。</p><h3 id="五、参考文档"><a href="#五、参考文档" class="headerlink" title="五、参考文档"></a>五、参考文档</h3><h5 id="1、官方文档"><a href="#1、官方文档" class="headerlink" title="1、官方文档"></a>1、官方文档</h5><h5 id="2、官方使用CADisplayLink播放视频的例子"><a href="#2、官方使用CADisplayLink播放视频的例子" class="headerlink" title="2、官方使用CADisplayLink播放视频的例子"></a>2、官方使用<code>CADisplayLink</code>播放视频的例子</h5>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS 开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FMDB 数据库简单基本操作</title>
      <link href="/2017/06/27/FMDB-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/06/27/FMDB-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.创建表: create table if not exists 表名 (字段名1, 字段名2…); 例如：创建 t_student 表 id（id自增长）</span><br><span class="line"></span><br><span class="line">create table if not exists t_student (id integer primary key autoincrement, name text not null, age integer)</span><br><span class="line">2.增加数据: insert into 表名 (字段名1, 字段名2, …) values(字段1的值, 字段2的值, …); 例如：在 t_student 表插入name，age字段</span><br><span class="line"></span><br><span class="line">insert into t_student (name,age) values (@”Jack”,@17);</span><br><span class="line">3.1根据条件删除数据： delete from 表名 where 条件; 例如：</span><br><span class="line">删除 t_student 表中 name 字段为 Jack 的数据</span><br><span class="line"></span><br><span class="line">delete from t_student where name = @”Jack”;</span><br><span class="line">3.2删除表中所有的数据： delete from 表名； 例如：</span><br><span class="line"></span><br><span class="line">delete from t_student;</span><br><span class="line">4.根据条件更改某个数据 update 表名 set 字段1 = ‘值1’, 字段2 = ‘值2’ where 字段1 = ‘字段1的当前值’ 例如：</span><br><span class="line"></span><br><span class="line">update t_student set name = ‘lily’, age = ‘16’ where name = ‘Jack’</span><br><span class="line">5.1根据条件查找 select from 表名 where 字段1 = ‘字段1的值’ 例如：</span><br><span class="line"></span><br><span class="line">select from t_student where age = ‘16’</span><br><span class="line">5.2查找所有数据 select from 表名 例如：</span><br><span class="line"></span><br><span class="line">select from t_student</span><br><span class="line">5.3排序查找： select from 表名 order by 字段 例如：</span><br><span class="line"></span><br><span class="line">select from t_student order by age asc （升序，默认）</span><br><span class="line">select * from t_student order by age desc （降序） 3.</span><br><span class="line">6.删除表： drop table 表名 例如：</span><br><span class="line"></span><br><span class="line">drop table t_student</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> FMDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FMDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发权限设置</title>
      <link href="/2017/05/05/iOS%E5%BC%80%E5%8F%91%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/"/>
      <url>/2017/05/05/iOS%E5%BC%80%E5%8F%91%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>iOS 8.0之后调用系统的API需要配置相关的配置信息才能正常使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 相册 --&gt;</span><br><span class="line">&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问相册&lt;/string&gt;</span><br><span class="line">&lt;!-- 相机 --&gt;</span><br><span class="line">&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问相机&lt;/string&gt;</span><br><span class="line">&lt;!-- 麦克风 --&gt;</span><br><span class="line">&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问麦克风&lt;/string&gt;</span><br><span class="line">&lt;!-- 位置 --&gt;</span><br><span class="line">&lt;key&gt;NSLocationUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问位置&lt;/string&gt;</span><br><span class="line">&lt;!-- 在使用期间访问位置 --&gt;</span><br><span class="line">&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能在使用期间访问位置&lt;/string&gt;</span><br><span class="line">&lt;!-- 始终访问位置 --&gt;</span><br><span class="line">&lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能始终访问位置&lt;/string&gt;</span><br><span class="line">&lt;!-- 日历 --&gt;</span><br><span class="line">&lt;key&gt;NSCalendarsUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问日历&lt;/string&gt;</span><br><span class="line">&lt;!-- 提醒事项 --&gt;</span><br><span class="line">&lt;key&gt;NSRemindersUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问提醒事项&lt;/string&gt;</span><br><span class="line">&lt;!-- 运动与健身 --&gt;</span><br><span class="line">&lt;key&gt;NSMotionUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问运动与健身&lt;/string&gt;</span><br><span class="line">&lt;!-- 健康更新 --&gt;</span><br><span class="line">&lt;key&gt;NSHealthUpdateUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问健康更新 &lt;/string&gt;</span><br><span class="line">&lt;!-- 健康分享 --&gt;</span><br><span class="line">&lt;key&gt;NSHealthShareUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问健康分享&lt;/string&gt;</span><br><span class="line">&lt;!-- 蓝牙 --&gt;</span><br><span class="line">&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问蓝牙&lt;/string&gt;</span><br><span class="line">&lt;!-- 媒体资料库 --&gt;</span><br><span class="line">&lt;key&gt;NSAppleMusicUsageDescription&lt;/key&gt;</span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问媒体资料库&lt;/string&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS 开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 开发 UITableViewCell的重用机制</title>
      <link href="/2017/04/16/iOS%E5%BC%80%E5%8F%91UITableViewCell%E7%9A%84%E9%87%8D%E7%94%A8%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/04/16/iOS%E5%BC%80%E5%8F%91UITableViewCell%E7%9A%84%E9%87%8D%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>首先,我们要明白我们为什么需要使用这种机制,其次,这种机制的原理是什么.<br>我们先举个例子来说明.一个UITableView中有许多需要显示的cell,但是我们不可能每个都会浏览到,那么如果我们把这些数据全部都加载进去,是不是造成了内存的负担呢.</p><p>我们所能显示的区域通常只有一个屏幕的大小,那么那些屏幕之外的信息是不需要一次性全都加载完的,只有当我们滑动屏幕需要浏览的时候,我们才需要它加载进来.因此,就有了我们要介绍的这部分内容,UITabelViewCell的重用机制.</p><p>重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell,我们只创建屏幕可显示的最大的cell个数+1,然后去循环重复使用这些cell,既节省空间,又达到我们需要显示的效果.<br>这种机制下系统默认有一个可变数组NSMutableArray<em> visiableCells,用来保存当前显示的cell.一个可变字典NSMutableDictnery</em> reusableTableCells,用来保存可重复利用的cell.(之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 设置单元格  indexPath :单元格当前所在位置 -- 哪个分区哪一行等</span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath //UITableViewDataSource</span><br><span class="line">&#123;</span><br><span class="line">    static NSString *identifier = @&quot;cell&quot; ;</span><br><span class="line">    //相当于从集合中找寻完全出屏幕的单元格.</span><br><span class="line">    // identifier : 因为一个表视图中可能存在多种样式的单元格,咱们把相同样式的单元格放到同一个集合里面,为这个集合加标示符,当我们需要用到某种样式的单元格的时候,根据不同的标示符,从不同的集合中找寻单元格.</span><br><span class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier] ;</span><br><span class="line">    // 如果从集合中未找到单元格,也就是集合中还没有单元格,也就是还没有单元格出屏幕,那么我们就需要创建单元格</span><br><span class="line">    if (!cell)</span><br><span class="line">    &#123;</span><br><span class="line">        // 创建cell的时候需要标示符(Identifier)是因为,当该cell出屏幕的时候需要根据标示符放到对应的集合中.</span><br><span class="line">        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@&quot;cell&quot;] ;</span><br><span class="line">    return cell ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">系统第一次执行</span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">这个方法的时候, reusableTableCells为空,</span><br><span class="line">[tableView dequeueReusableCellWithIdentifier:identifier]</span><br><span class="line">的返回值为nil,我们需要通过</span><br><span class="line">[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier]</span><br><span class="line">方式来创建.</span><br></pre></td></tr></table></figure><blockquote><p>当我们的数据过多,整个屏幕的cell显示不完全时,这个方法的执行情况是 :</p></blockquote><blockquote><p>(1) 先执行<br><code>[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier]</code><br>创建整个屏幕能显示的cell数+1的cell(当我们拖动UITableView的时候,第一个cell没有移出屏幕,最下面的cell就已经存在),并指定相同或者不同的标示符identifier.把创建出的屏幕能显示的cell全部都加入到visiableCells数组中(最后一个创建的先不加入数组)，reusableTableCells为空.</p></blockquote><blockquote><p>(2)当我们拖动屏幕时,顶端的cell移出屏幕并加入到reusableTableCells字典中,键为identifier ,并把之前已经创建的但是没有加入到visiableCells的cell加入到visiableCells数组中.</p></blockquote><blockquote><p>(3)当我们接着拖动的时候,因为reusableTableCells中已经有值，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用，执行[tableView dequeueReusableCellWithIdentifier: identifier]，返回一个标示符为identifier的cell。该cell移出reusableTableCells之后加入到visiableCells；顶端的cell移出visiableCells并加入到reusableTableCells.如果visiableCells数组中没有找到identifier类型的cell,则再次重新alloc一个.</p></blockquote><p>在iOS6之后系统加入了一种单元格注册的方法.<br><code>[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier: identifier];</code></p><blockquote><p>这个方法的作用是,当我们从重用队列中取cell的时候,如果没有,系统会帮我们创建我们给定类型的cell,如果有,则直接重用. 这种方式cell的样式为系统默认样式.</p></blockquote><p>在设置cell的方法中只需要:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    // 重用队列中取单元格 由于上面已经注册过单元格,系统会帮我们做判断,不用再次手动判断单元格是否存在</span><br><span class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier: identifier forIndexPath:indexPath] ;</span><br><span class="line">    return cell ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS 开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 开发 APP的生命周期和UIViewController的生命周期</title>
      <link href="/2017/03/12/iOS%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2017/03/12/iOS%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<h3 id="一-iOS程序的启动执行顺序"><a href="#一-iOS程序的启动执行顺序" class="headerlink" title="一. iOS程序的启动执行顺序"></a>一. iOS程序的启动执行顺序</h3><h4 id="1-具体执行流程"><a href="#1-具体执行流程" class="headerlink" title="1.具体执行流程"></a>1.具体执行流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">程序入口</span><br><span class="line">进入main函数，设置AppDelegate称为函数的代理</span><br><span class="line"></span><br><span class="line">程序完成加载</span><br><span class="line"></span><br><span class="line">[AppDelegate application:didFinishLaunchingWithOptions:]</span><br><span class="line"></span><br><span class="line">创建window窗口</span><br><span class="line"></span><br><span class="line">程序被激活</span><br><span class="line"></span><br><span class="line">[AppDelegate applicationDidBecomeActive:]</span><br><span class="line"></span><br><span class="line">当点击command+H时(针对模拟器,手机是当点击home键)</span><br><span class="line">程序取消激活状态</span><br><span class="line"></span><br><span class="line">[AppDelegate applicationWillResignActive:];</span><br><span class="line"></span><br><span class="line">程序进入后台</span><br><span class="line"></span><br><span class="line">[AppDelegate applicationDidEnterBackground:];</span><br><span class="line"></span><br><span class="line">点击进入工程</span><br><span class="line">程序进入前台</span><br><span class="line"></span><br><span class="line">[AppDelegate applicationWillEnterForeground:]</span><br><span class="line"></span><br><span class="line">程序被激活</span><br><span class="line"></span><br><span class="line">[AppDelegate applicationDidBecomeActive:];</span><br></pre></td></tr></table></figure><h4 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h4><blockquote><p>对于applicationWillResignActive(非活动)与applicationDidEnterBackground(后台)这两个的区别。<br>applicationWillResignActive(非活动):<br>比如当有电话进来或短信进来或锁屏等情况下，这时应用程序挂起进入非活动状态，也就是手机界面还是显示着你当前的应用程序的窗口，只不过被别的任务强制占用了，也可能是即将进入后台状态(因为要先进入非活动状态然后进入后台状态)</p></blockquote><blockquote><p>applicationDidEnterBackground(后台):<br>指当前窗口不是你的App,大多数程序进入这个后台会在这个状态上停留一会，时间到之后会进入挂起状态(Suspended)。如果你程序特殊处理后可以长期处于后台状态也可以运行。<br>Suspended (挂起): 程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</p></blockquote><p>###二. UIViewController 的 生命周期</p><p>当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序</p><p>1、 alloc 创建对象，分配空间</p><p>2、init (initWithNibName) 初始化对象，初始化数据</p><p>3、loadView 从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图</p><p>4、viewDidLoad 载入完成，可以进行自定义数据以及动态创建其他控件</p><p>5、viewWillAppear 视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了</p><p>6、viewDidAppear 视图已在屏幕上渲染完成<br>当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反</p><p>1、viewWillDisappear 视图将被从屏幕上移除之前执行</p><p>2、viewDidDisappear 视图已经被从屏幕上移除，用户看不到这个视图了</p><p>3、dealloc 视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放</p><blockquote><p>关于viewDidUnload ：在发生内存警告的时候如果本视图不是当前屏幕上正在显示的视图的话， viewDidUnload将会被执行，本视图的所有子视图将被销毁，以释放内存,此时开发者需要手动对viewLoad、viewDidLoad中创建的对象释放内存。 因为当这个视图再次显示在屏幕上的时候，viewLoad、viewDidLoad 再次被调用，以便再次构造视图。</p></blockquote><p>当我们创建一个UIViewController类的对象时，通常系统会生成几个默认的方法，这些方法大多与视图的调用有关，但是在视图调用时，这些方法的调用顺序如何，需要整理下。<br>通常上述方法包括如下几种，这些方法都是UIViewController类的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad；</span><br><span class="line"></span><br><span class="line">- (void)viewDidUnload；</span><br><span class="line"> </span><br><span class="line">- (void)viewWillAppear:(BOOL)animated；</span><br><span class="line"> </span><br><span class="line">- (void)viewDidAppear:(BOOL)animated；</span><br><span class="line"> </span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated；</span><br><span class="line"> </span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated；</span><br></pre></td></tr></table></figure><p>下面介绍下APP在运行时的调用顺序。</p><p>1）- (void)viewDidLoad；</p><p>一个APP在载入时会先通过调用loadView方法或者载入IB中创建的初始界面的方法，将视图载入到内存中。然后会调用viewDidLoad方法来进行进一步的设置。通常，我们对于各种初始数据的载入，初始设定等很多内容，都会在这个方法中实现，所以这个方法是一个很常用，很重要的方法。</p><p>但是要注意，这个方法只会在APP刚开始加载的时候调用一次，以后都不会再调用它了，所以只能用来做初始设置。</p><p>2) - (void)viewDidUnload;</p><p>在内存足够的情况下，软件的视图通常会一直保存在内存中，但是如果内存不够，一些没有正在显示的viewcontroller就会收到内存不够的警告，然后就会释放自己拥有的视图，以达到释放内存的目的。但是系统只会释放内存，并不会释放对象的所有权，所以通常我们需要在这里将不需要在内存中保留的对象释放所有权，也就是将其指针置为nil。</p><p>这个方法通常并不会在视图变换的时候被调用，而只会在系统退出或者收到内存警告的时候才会被调用。但是由于我们需要保证在收到内存警告的时候能够对其作出反应，所以这个方法通常我们都需要去实现。</p><p>另外，即使在设备上按了Home键之后，系统也不一定会调用这个方法，因为IOS4之后，系统允许将APP在后台挂起，并将其继续滞留在内存中，因此，viewcontroller并不会调用这个方法来清除内存。</p><p>3）- (void)viewWillAppear:(BOOL)animated;</p><p>系统在载入所有数据后，将会在屏幕上显示视图，这时会先调用这个方法。通常我们会利用这个方法，对即将显示的视图做进一步的设置。例如，我们可以利用这个方法来设置设备不同方向时该如何显示。</p><p>另外一方面，当APP有多个视图时，在视图间切换时，并不会再次载入viewDidLoad方法，所以如果在调入视图时，需要对数据做更新，就只能在这个方法内实现了。所以这个方法也非常常用。</p><p>4) - (void)viewDidAppear:(BOOL)animated；</p><p>有时候，由于一些特殊的原因，我们不能在viewWillApper方法里，对视图进行更新。那么可以重写这个方法，在这里对正在显示的视图进行进一步的设置。</p><p>5) - (void)viewWillDisappear:(BOOL)animated；</p><p>在视图变换时，当前视图在即将被移除、或者被覆盖时，会调用这个方法进行一些善后的处理和设置。</p><p>由于在IOS4之后，系统允许将APP在后台挂起，所以在按了Home键之后，系统并不会调用这个方法，因为就这个APP本身而言，APP显示的view，仍是挂起时候的view，所以并不会调用这个方法。</p><p>6) - (void)viewDidDisappear:(BOOL)animated；</p><p>我们可以重写这个方法，对已经消失，或者被覆盖，或者已经隐藏了的视图做一些其他操作。</p><p>上述方法的流程图可以简单用如下表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运行APP —&gt; 载入视图 —&gt; 调用viewDidLoad方法 —&gt; 调用viewWillAppear方法 —&gt; 调用viewDidAppear方法 —&gt; 正常运行 —&gt;</span><br><span class="line"></span><br><span class="line">…………..</span><br><span class="line"></span><br><span class="line">—&gt;释放对象所有权 &lt;— 调用viewDidUnload &lt;— 收到内存警告 &lt;— 调用viewDidDisappear &lt;— 调用viewWillDisappear &lt;— APP需要调用另一个view</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS 开发 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
