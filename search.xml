<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OpenGL学习 纹理(五)]]></title>
    <url>%2F2018%2F02%2F11%2F15244707402194%2F</url>
    <content type="text"><![CDATA[一.原始图像数据1.图像存储空间 = 图像 width 图像 height 每个像素的字节数例如:有一张 RGB 的图像(每个颜色通道8位),图像的宽度199个像素,每行需要多少存储空间? 199 * 3 = 597字节 二 认识函数2.1 函数123456789//改变像素存储⽅方式void glPixelStorei(GLenum pname,GLint param);//恢复像素存储⽅方式void glPixelStoref(GLenum pname,GLfloat param);//举例例://参数1:GL_UNPACK_ALIGNMENT 指定OpenGL 如何从数据缓存区中解包图像 数据//参数2:表示参数GL_UNPACK_ALIGNMENT 设置的值//GL_UNPACK_ALIGNMENT 指内存中每个像素⾏行行起点的排列列请求，允许设置为1 (byte排列列)、2(排列列为偶数byte的⾏行行)、4(字word排列列)、8(⾏行行从双字节 边界开始)glPixelStorei(GL_UNPACK_ALIGNMENT,1); 2.2 . 认识函数 从颜⾊色缓存区内容作为像素图直接读取1234567//参数1:x,矩形左下⻆角的窗⼝口坐标//参数2:y,矩形左下⻆角的窗⼝口坐标//参数3:width,矩形的宽，以像素为单位 //参数4:height,矩形的⾼高，以像素为单位//参数5:format,OpenGL 的像素格式，参考 表6-1 //参数6:type,解释参数pixels指向的数据，告诉OpenGL 使⽤用缓存区中的什什么 数据类型来存储颜⾊色分量量，像素数据的数据类型，参考 表6-2 //参数7:pixels,指向图形数据的指针void glReadPixels(GLint x,GLint y,GLSizei width,GLSizei height, GLenum format, GLenum type,const void * pixels); 2.3 . 认识函数 载⼊入纹理理12345678910111213141516* target:`GL_TEXTURE_1D`、`GL_TEXTURE_2D`、`GL_TEXTURE_3D`。* Level:指定所加载的mip贴图层次。⼀一般我们都把这个参数设置为0。* internalformat:每个纹理理单元中存储多少颜⾊色成分。* width、height、depth参数:指加载纹理理的宽度、⾼高度、深度。==注意!==这些值必须是 2的整数次⽅方。(这是因为OpenGL 旧版本上的遗留留下的⼀一个要求。当然现在已经可以⽀支持不不是 2的整数次⽅方。但是开发者们还是习惯使⽤用以2的整数次⽅方去设置这些参数。)* border参数:允许为纹理理贴图指定⼀一个边界宽度。* format、type、data参数:与我们在讲glDrawPixels 函数对于的参数相同void glTexImage1D(GLenum target,GLint level,GLint internalformat,GLsizei width,GLint border,GLenum format,GLenum type,void *data);void glTexImage2D(GLenum target,GLint level,GLint internalformat,GLsizei width,GLsizei height,GLint border,GLenum format,GLenum type,void * data);void glTexImage3D(GLenum target,GLint level,GLint internalformat,GLSizei width,GLsizei height,GLsizei depth,GLint border,GLenum format,GLenum type,void *data); 2.4 认识函数 使⽤用颜⾊色缓存区加载数据,形成新的纹理理使⽤用12345void glCopyTexImage1D(GLenum target,GLint level,GLenum internalformt,GLint x,GLint y,GLsizei width,GLint border); void glCopyTexImage2D(GLenum target,GLint level,GLenum internalformt,GLint x,GLint y,GLsizei width,GLsizei height,GLint border); x,y 在颜⾊色缓存区中指定了了开始读取纹理理数据的位置; 缓存区⾥里里的数据，是源缓存区通过glReadBuffer设置的。注意:不不存在glCopyTextImage3D ，因为我们⽆无法从2D 颜⾊色缓存区中获取体积 数据。 2.5 更更新纹理理12345678void glTexSubImage1D(GLenum target,GLint level,GLint xOffset,GLsizei width,GLenum format,GLenum type,const GLvoid *data);void glTexSubImage2D(GLenum target,GLint level,GLint xOffset,GLint yOffset,GLsizei width,GLsizei height,GLenum format,GLenum type,const GLvoid *data);void glTexSubImage3D(GLenum target,GLint level,GLint xOffset,GLint yOffset,GLint zOffset,GLsizei width,GLsizei height,GLsizei depth,Glenum type,const GLvoid * data); 2.6 插⼊入替换纹理理12345678void glCopyTexSubImage1D(GLenum target,GLint level,GLint xoffset,GLint x,GLint y,GLsizeiwidth); void glCopyTexSubImage2D(GLenum target,GLint level,GLint xoffset,GLint yOffset,GLint x,GL y,GLsizei width,GLsizei height);void glCopyTexSubImage3D(GLenum target,GLint level,GLint xoffset,GLint yOffset,GLint zOffset,GLint x,GLint y,GLsizei width,GLsizei height); 三 纹理理对象123456789//使⽤用函数分配纹理理对象//指定纹理理对象的数量量 和 指针(指针指向⼀一个⽆无符号整形数组，由纹理理对象标识符填充)。 void glGenTextures(GLsizei n,GLuint * textTures);//绑定纹理理状态 //参数target:GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D //参数texture:需要绑定的纹理理对象void glBindTexture(GLenum target,GLunit texture);//删除绑定纹理理对象//纹理理对象 以及 纹理理对象指针(指针指向⼀一个⽆无符号整形数组，由纹理理对象标识符填充)。 void glDeleteTextures(GLsizei n,GLuint *textures);//测试纹理理对象是否有效 //如果texture是⼀一个已经分配空间的纹理理对象，那么这个函数会返回GL_TRUE,否则会返回GL_FALSE。 GLboolean glIsTexture(GLuint texture); 3.1 设置纹理理参数1234567//参数1:target,指定这些参数将要应⽤用在那个纹理理模式上，⽐比如GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D //参数2:pname,指定需要设置那个纹理理参数//参数3:param,设定特定的纹理理参数的值glTexParameterf(GLenum target,GLenum pname,GLFloat param);glTexParameteri(GLenum target,GLenum pname,GLint param);glTexParameterfv(GLenum target,GLenum pname,GLFloat *param);glTexParameteriv(GLenum target,GLenum pname,GLint *param); 3.2 设置过滤⽅方式 邻近过滤(GL_NEAREST) 线性过滤(GL_LINEAR) 2种纹理理过滤⽅方式⽐比较 12345678910glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST) 纹理理缩⼩小时,使⽤用邻近过滤glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST) 纹理理放⼤大时,使⽤用线性过滤glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_HEAREST);glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_HEAREST);glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); 3.3 设置环绕⽅方式 123456参数1:GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D 参数2:GL_TEXTURE_WRAP_S、GL_TEXTURE_T、GL_TEXTURE_R,针对s,t,r坐标 参数3:GL_REPEAT、GL_CLAMP、GL_CLAMP_TO_EDGE、GL_CLAMP_TO_BORDERGL_REPEAT:OpenGL 在纹理理坐标超过1.0的⽅方向上对纹理理进⾏行行重复; GL_CLAMP:所需的纹理理单元取⾃自纹理理边界或TEXTURE_BORDER_COLOR. GL_CLAMP_TO_EDGE环绕模式强制对范围之外的纹理理坐标沿着合法的纹理理单元的最后⼀一⾏行行或者最后⼀一列列来进⾏行行采样。 GL_CLAMP_TO_BORDER:在纹理理坐标在0.0到1.0范围之外的只使⽤用边界纹理理单元。边界纹理理单元是作为围绕基本图像的额外的⾏行行和列列，并与基本纹理理图像⼀一起加载的。glTextParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAR_S,GL_CLAMP_TO_EDGE);glTextParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAR_T,GL_CLAMP_TO_EDGE); OpenGL 像素格式 四 设置Mip 贴图1234//设置mip贴图基层glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_BASE_LEVEL,0); //设置mip贴图最⼤大层glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAX_LEVEL,0);]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习 基本变化 (四)]]></title>
    <url>%2F2018%2F02%2F09%2F15244691153165%2F</url>
    <content type="text"><![CDATA[一、抗锯齿混合的两大功能:颜⾊色组合、抗锯⻮齿 混合处理-抗锯齿 123456//开启混合处理理 glEnable(GL_BLEND);//指定混合因⼦子 GLBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);//指定混合⽅方程式 glBlendEquation(GL_FUNC_ADD);glEnable(GL_POINT_SMOOTH); //对点进⾏行行抗锯⻮齿处理理glEnable(GL_LINE_SMOOTH);//对线进⾏行行抗锯⻮齿处理理 glEnable(GL_POLYGON_SMOOTH);//对多边形进⾏行行抗锯⻮齿处理理 二、多重采样1234//1.可以调⽤用 glutInitDisplayMode 添加采样缓存区 glutInitDisplayMode(GLUT_MULTISAMPLE);//2.可以使⽤用glEnable| glDisable组合使⽤用GLUT_MULTISAMPLE 打开| 关闭 多重采样。glEnable(GLUT_MULTISAMPLE);glDisable(GLUT_MULTISAMPLE); 三、多重采样、抗锯⻮齿混合综合使⽤用1234567glDisable(GLUT_MULTISAMPLE);glEnable(GL_POINT_SMOOTH);//Draw some smooth pointglDisable(GL_POINT_SMOOTH);glDisable(GL_LINE_SMOOTH);glEnable(GLUT_MULTISAMPLE);//Draw some smooth polygon 四、多重采样 拓拓展多重采样缓存区在默认情况下使⽤用⽚片段RGB值，并不不包含颜 ⾊色的alpha成分，我们可以通过调⽤用glEnable来修改这个 ⾏行行为: GL_SAMPLE_ALPHA_TO_COVERAGE 使⽤用alpha值 GL_SAMPLE_ALPHA_TO_ON 使⽤用alpha值并设为1，并 使⽤用它。 GL_SAMPLE_COVERAGE 使⽤用glSampleCoverage 所设置的值。 当启⽤用 GL_SAMPLE_COVERAGE 时，可以使⽤用 glSampleCoverage函数允许指定⼀一个特定的值，它是与⽚片 段覆盖值进⾏行行按位与操作的结果。 五、向量 如何定义三维、四维向量量或三维向量量数组、四维向量量数组?M3DVector3f :表示⼀一个三维的向量量(x,y,z)M3DVector4f :表示⼀一个四维的向量量(x,y,z,w)(R,G,B,A) 六、点乘 七、使用矩阵堆栈123456789101112131415//类型GLMatrixStack::GLMatrixStack(int iStackDepth = 64);//在堆栈顶部载⼊入⼀一个单元矩阵void GLMatrixStack::LoadIdentity(void);//在堆栈顶部载⼊入任何矩阵 //参数:4*4矩阵void GLMatrixStack::LoadMatrix(const M3DMatrix44f m);//矩阵乘以矩阵堆栈顶部矩阵，相乘结果存储到堆栈的顶部void GLMatrixStack::MultMatrix(const M3DMatrix44f);//获取矩阵堆栈顶部的值 GetMatrix 函数 //为了了适应GLShaderMananger的使⽤用，或者获取顶部矩阵的副本const M3DMatrix44f &amp; GLMatrixStack::GetMatrix(void);void GLMatrixStack::GetMatrix(M3DMatrix44f mMatrix); 八、压栈、出栈1234567//将当前矩阵压⼊入堆栈void GLMatrixStack::PushMatrix(void);//将M3DMatrix44f 矩阵对象压⼊入当前矩阵堆栈void PushMatrix(const M3DMatrix44f mMatrix);//将GLFame 对象压⼊入矩阵对象void PushMatrix(GLFame &amp;frame);//出栈(出栈指的是移除顶部的矩阵对象) void GLMatrixStack::PopMatrix(void); 九、仿射变换 GLMastrixStack 内建了旋转\平移\缩放12345//Rotate 函数angle参数是传递的度数，⽽而不不是弧度void MatrixStack::Rotate(GLfloat angle,GLfloat x,GLfloaty,GLfloat z);void MatrixStack::Translate(GLfloat x,GLfloat y,GLfloat z);void MatrixStack::Scale(GLfloat x,GLfloat y,GLfloat z); 十、使用照相机 和 角色帧 进行移动12345class GLFrame &#123;protected:M3DVector3f vOrigin; // Where am I? M3DVector3f vForward; // Where am I going? M3DVector3f vUp; // Which way is up?&#125; 十一、GLFrame12345678//将堆栈的顶部压⼊入任何矩阵void GLMatrixStack::LoadMatrix(GLFrame &amp;frame);//矩阵乘以矩阵堆栈顶部的矩阵。相乘结果存储在堆栈的顶部 void GLMatrixStack::MultMatrix(GLFrame &amp;frame);//将当前的矩阵压栈void GLMatrixStack::PushMatrix(GLFrame &amp;frame); 十二、照相机管理 12//GLFrame函数，这个函数⽤用来检索条件适合的照相矩阵void GetCameraMatrix(M3DMatrix44f m,bool bRotationOnly = flase);]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习 深度测试(三)]]></title>
    <url>%2F2018%2F02%2F08%2F15244657893765%2F</url>
    <content type="text"><![CDATA[一、渲染过程是中可能产生的问题 解决办法：1：油画法2：正面、背面剔除。3：深度测试。 1.1、油画法 油画法：比较消耗性能，重复绘制了重叠部分，对于多个图形叠加在一起的，难以分辨哪个是最上层的，导致渲染混乱 1.2、正面背面剔除可以调用下面两个方法开启或关闭表面剔除 12glEnable(GL_CULL_FACE); //开启glDisable(GL_CULL_FACE); // 关闭 该函数的原型如下void glFrontFace(GLenum mode); mode 参数的可选的值有 GL_CW 和 GL_CCW （默认值是GL_CCW） GL_CW 表示顶点的排列顺序是顺时针的面 是正面。GL_CCW 表示顶点的排列顺序是逆时针的面是正面 （默认值） void glCullFace() GL_FRONT // 正面剔除GL_BACK // 背面剔除GL_FRONT_ANF_BACK 正面和反面都要剔除 二、什么叫深度？所谓的深度，就在坐标系中，像素Z坐标距离观察者的距离观察者，可以在任何位置，OpenGL会有专门有一块缓存区来存放Z值，深度缓冲区！每个像素上的Z值。 三、深度缓冲去区的作用一般情况下，我们绘制图形时，后面绘制的会覆盖前面的图形。一般绘制的顺序先后面再前面。产生一个性能问题，就是遮盖部分，先绘制的会被覆盖，这没有任何意义的绘制。深度测试就是用来解决这个问题的它是如何处理的？有了深度缓冲区之后，绘制的时候会检查Z,靠近观察者的覆盖。而不是靠绘制顺序来决定。 四、如何使用深度缓冲区测试？为什么要测试？一旦开启之后就会先测试深度值再绘制 glEnable (GLDEPTHTEST); 默认情况下Z值小的情况下会被覆盖如果是观察者，在Z轴的正方向，Z值大的靠近观察者如果是观察者，在Z轴的负方向，Z值小的靠近观察者 五、多边形模型 使用glPolygonMode(Glenum face,Glenum mode) 函数来指定填充方式Face参数:GL_FRONT、GL_BACK、GL_FRONT_AND_BACKMode参数:GL_FILL(默认实心填充) 、GL_LINE、GL_POINT 六、多边形偏移深度测试实现深度的过程中，可能产生的2种问题:1、z-fighting(z冲突)2、图形重叠(无法体现深度) 七、如何解决深度值相同，造成的冲突问题第一种方法：在第二次绘制时，稍微偏移一点点解决这个问题。注意：必须非常小心确保Z值的间隙 第二种方法：采样glPolygonOffset 函数。使得可以调节片段的深度值。使得深度之偏移而不产生悬浮 glPolygonOffset 函数void glPolygonOffset(Glfloat factor,Glfloat units); 应用到片段上总偏移计算方程式:Depth Offset = (DZ factor) + (r units);DZ:深度值(Z值)r:使得深度缓冲区产生变化的最小值负值，将使得z值距离我们更近，而正值，将使得z值距离我们更远，对于上节课的案例，我们设置factor和units设置为-1，0 八、裁剪在OpenGL 提高渲染的一种方式，只刷新屏幕上发生变化的部分。OpenGL 允许我们将要进行渲染的窗口只去指定一个裁剪框。 1234567//1 开启裁剪测试glEnable(GL_SCISSOR_TEST);//2.关闭裁剪测试glDisable(GL_SCISSOR_TEST);//3.指定裁剪窗口//x,y:指定裁剪框左下角位置;width,height:指定裁剪尺寸void glScissor(Glint x,Glint y,GLSize width,GLSize height); 九、混合我们把OpenGL 渲染时会把颜色值存在颜色缓存区中，每个片段的深度值也是放在深度缓冲区。当深度缓冲区被关闭时，新的颜色将简单的覆盖原来颜色缓存区存在的颜色值，当深度缓冲区再次打开时，新的颜色片段只是当它们比原来的值更接近邻近的裁剪平面才会替换原来的颜色片段。glEnable(GL_BlEND); 9.1 组合颜色目标颜色:已经存储在颜色缓存区的颜色值源颜色:作为当前渲染命令结果进入颜色缓存区的颜色值当混合功能被启动时，源颜色和目标颜色的组合方式是混合方程式控制的。在默认情况下，混合方程式如下所示: 123456Cf = (Cs * S) + (Cd * D)Cf :最终计算参数的颜色Cs : 源颜色Cd :目标颜色S:源混合因子D:目标混合因子 9.2 设置混合因子1234设置混合因子，需要用到glBlendFun函数glBlendFunc(GLenum S,GLenum D);S:源混合因子D:目标混合因子 9.3 混合因子枚举列表 表中R、G、B、A 分别代表红、绿、蓝、alpha。表中下标S、D，分别代表源、目标表中C 代表常量颜色(默认黑色) 9.4总结最终颜色是以原先的红色(目标颜色)与 后来的蓝色(源颜色)进行组合。源颜色的alpha值越高，添加的蓝色颜色成分越高，目标颜色所保留的成分就会越少。混合函数经常用于实现在其他一些不透明的物体前面绘制一个透明物体的效果 十、改变组合方程式默认混合方程式:Cf = (CsS)+(CdD)实际上远不止这一种混合方程式，我们可以从5个不同的方程式中进行选择 10.1 改变混合方程式的函数 glBlendEquation()选择混合方程式的函数:glbBlendEquation(GLenum mode); 10.2 glBlendFuncSeparate 函数1234567除了能使用glBlendFunc 来设置混合因子，还可以有更灵活的选择。strRGB: 源颜色的混合因子dstRGB: 目标颜色的混合因子strAlpha: 源颜色的Alpha因子dstAlpah: 目标颜色的Alpha因子void glBlendFuncSeparate(GLenum strRGB,GLenum dstRGB,GLenum strAlpha,GLenumdstAlpha); 10.3 glBlendFuncSeparate 注意 glBlendFunc 指定 源和目标 RGBA值的混合函数;但是glBlendFuncSeparate函数则允许为RGB 和 Alpha 成分单独指定混合函数。在混合因子表中，GL_CONSTANT_COLOR,GL_ONE_MINUS_CONSTANT_COLOR,GL_CONSTANT_ALPHA,GL_ONE_MINUS_CONSTANT值允许混合方程式中引入一个常量混合颜色。 10.4 常量混合颜色常量混合颜色，默认初始化为黑色(0.0f,0.0f,0.0f,0.0f)，但是还是可以修改这个常量混合颜色。void glBlendColor(GLclampf red ,GLclampf green ,GLclampf blue ,GLclampf alpha );]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习 基础渲染(二)]]></title>
    <url>%2F2018%2F02%2F07%2F15244572175577%2F</url>
    <content type="text"><![CDATA[在OpenGL 3.0之前，OpenGL 包含一个固定功能的管线，它可以在不使用着色器的情况下处理几何与像素数据。在3.1版本开始，固定管线从核心模式去掉。因此现在需要使用着色器来完成工作。使 OpenGL 来说，我们会使 GLSL,(OpenGL Shading Langruage，它是在OpenGL 2.0版本发布的)。 语法与“C、C++”类似。 一、基础图形管线OpenGL 中图元只不过是顶点的集合以预定义的方式结合在一起。管线分为:2个部分，上半部分是客户机端，下半部分是服务器端。 客户端是存储在CPU存储 中的，并且在应用程序中执行 ，或者在主系统内存的驱动程序中执行。驱动程序会将渲染命令和数组组合起来，发送给服务执执 !(在一台典型的个人计算机上，服务器就是实际上就是图形加速卡上的硬件和内存)服务器和 客户机在功能上也是异步的。 它们是各自独力的软件块或硬件块。我们是希望它们2个端都尽量在 不停的工作。客户端不断的把数据块和命令块组合在一起输送到缓冲区，然后缓冲区就会发送到服务器执 。 如果服务器停止工作等待客户机，或者客户机停止作来等待服务器做好接受更多的命令和准备，我们把这种情况成为管线停滞 二、着色器渲染过程，必备的两个着色器“顶点着色器”和“片元着色器”。上图的Vertex Shader(顶点着色器) 和 Fragment Shader(片元着色器)着色器是使用GLSL编写的程序，看起来与C语言非常类似。 着色器必须从源代码中编译和链接在一起。最终准备就绪的着色器程序顶点着色器 –&gt;处理从客户机输入的数据、应用变换、进行其他的类型的数学运算来计算关照效果、位移、颜 值等等。(**为了渲染共有3个顶点的三角形，顶点着色器将执 3次，也就是为 了每个顶点执一次)在目前的硬件上有多个执行单元同时运行 ，就意味着所有的3个顶点可以同时进行处理 ! 图上(primitive Assembly 说明的是:3个顶点已经组合在一起， 三角形已经逐个片段的进行光栅化。每个片段通过执片元元着器，进行 填充。 元着器会输出我们将屏幕上看到的最终颜色值。 三、3种向OpenGL着色器传递渲染数据的方法 属性 Uniform 纹理3.1 属性 属性：就是对一个顶点都要作改变的数据元素。实际上，顶点位置本身就是一个属性。属性可以是浮点类型、整型、布尔类型。 属性总是以四维向 的形式进行内部存储的，即使我们不会使用所有的4个分量。一个顶点位置可能存储(x,y,z)，将占有4个分量中的3个。实际上如果是在平面情况下:只要在xy平面上就能绘制，那么Z分量就会自动设置为0;属性还可以是:纹理坐标、颜色值、关照计算表面法线在顶点程序(shader渲染)可以代表你想要的任何意义。因为都是你设定的。属性会从本地客户机内存中复制存储在图形硬件中的一个缓冲区上。这些属性只提供给顶点着 使 ，对于 元着 有太 意义。声明:这些属性对每个顶点都要做改变，但并不意味着它们的值不能重复。通常情况下，它们都是 不一样样的，但有可能整个数组都是同一值的情况。 3.2 Uniform属性是 种对整个批次属性都取统一值的单一值，它是不变的。 通过设置uniform变量就紧接着发送一个图元批次命令。Uniform变量实际上可以无限次限制地使用，设置一个应用于整个表面的单个颜色值，还可以设置一个时间值。在每次渲染某种类型的顶点动画时修改它。注意:这 的uniform 变量每个批次改变一次，而不是每个顶点改变一次。uniform变量最常见的应该是在顶点渲染中设置变换矩阵与属性相同点:可以是浮点值、整数、布尔值与属性不同点:顶点着色器和片元着色器都可以用 uniform变量 。uniform 变量还可以是标量类型、 矢量类型、uniform矩阵。 3.3 纹理传递给着器的第三种数据类型:纹理数据 在顶点着色器、 片段着色器中都可以对纹理数据进行采样和筛选。典型的应用场景: 片段着色器对一个纹理值进行采样，然后在一个三角形表面应用渲染纹理数据。纹理数据， 不仅仅表现在图形，很多图形文件格式都是以无符号字节(每个颜色通道8位)形式对颜分量进行存储的。 3.4 输出输出数据：简单的从一个阶段传递到下一个阶段。客户端的代码接触不到这些内部变量。我们的OpenGL开发暂时接触不到！ 四、创建坐标系4.1 正投影 这就是一个正投影的 例子，在所在3个轴(X,Y,Z)中，它们的范围都是从-100到+100。这个视景体将包括所有的 几何图形。如果你指定 了视景体外的几何图形，就会被裁减掉!(它将沿着视景体的边界进行剪切)在正投影中，所有在这个空间范围内的所有东西都将被呈现在屏幕上。 存在照相机或视点坐标系的概念。 4.2透视投影setPerspective(float ffov,float fAspect,float fNear,float fFar) 透视投影会进行透视除法对距离观察者很远的对象进行缩短和收缩。在投影到屏幕之后，视景体背面与视景体正面的宽度测量标准不同。上图所示:平截头体(frustum)的 何体，它的观察方向是从金字塔的尖端到宽阔端。观察者的视点与金字塔的尖端拉开一定距离。 123456789GLFrustum类通过setPerspective 法为我们构建一个平截头体。参数:fFov:垂直方向上的视场角度fAspect:窗口的宽度与高度的纵横 fNear:近裁剪面距离fFar:远裁剪面距离纵横 = 宽(w)/ (h)CLFrustum::SetPerspective(float fFov,float fAspect,float fNear,float fFar); 五、使用存储着色器5.1、使用背景5.2存储着色器的使用 单位着色器 平面着色器 上色着色器 默认光源着色器 点光源着色器 纹理替换矩阵 纹理调整着色器 纹理光源着色器 5.3 GLShaderManager 的初始化12345678// 定义着色器GLShaderMananger shaderManager;// 初始化着色器shaderManager.IntalizeStockShaders()//使用shaderManager userStockManager(参数列表) 5.4 GLShaderManager 属性 存储着色器为每一个变量都使用一致的内部变量命名规则和相同的属性槽，以上就是存储着色器的属性列表。 5.5 GLShanderManager 的 uniform值一般情况，要对几何图形进行渲染，我们需要给对象递交属性矩阵， 先要绑定我们想要使用的着色器程序上，并提供程序的uniform值。但是GLShanderManager 类可以暂时为我们完成工作。useStockShader 函数会选择一个存储着色器并提供这个着色器的uniform值。 单位着色器 12345//单位着色器:只是简单地使用默认笛卡尔坐标系(坐标范围(-1.0，1.0))。所有的片段都应用同一种颜色 ，几何图形为心和未渲染的。//需要设置存储着色器一个属性: GLT_ATTRIBUTE_VERTEX(顶点分量)//参数2:vColor[4],你需要的颜色GLShaderManager::UserStockShader(GLT_ATTRIBUTE_VERTEX,GLfloat vColor[4]); 平面着色器 123456//参数1:平面着色器 //参数2:允许变化的4*4矩阵//参数3:颜色//它将统一着色器进行了拓展。允许为几何图形变换指定一个 4 * 4 变换矩阵。经常被称为“模型视图投影矩阵”GLShaderManager::UserStockShader(GLT_SHADER_FLAT,GLfloat mvp[16],GLfloat vColor[4]); 上色着器 1234//在几何图形中应用的变换矩阵。//需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量 ) 和GLT_ATTRIBUTE_COLOR(颜色分量 ) 2个属性。颜色值将被平滑地插入顶点之间(平滑着色 )GLShaderManager::UserStockShader(GLT_SHADER_SHADED,GLfloat mvp[16]); 默认光源着色器 1234567//参数1:默认光源着色器 //参数2:模型视图矩阵//参数3:投影矩阵//参数4:颜 值//这种着色器，是对象产 阴影和关照的效果。需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和GLT_ATTRIBUTE_NORMAL(表面法线)GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT,GLfloat mvMatrix[16],GLfloatpMatrix[16],GLfloat vColor[4]); 点光源着色器 12345678//参数1:点光源着色器//参数2:模型视图矩阵//参数3:投影矩阵//参数4:视点坐标光源位置//参数5:颜色值//点光源着色器和默认光源着色器很相似，区别在于:光源位置是特定的。同样需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和GLT_ATTRIBUTE_NORMAL(表面法线)GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT_DIEF,GLfloatmvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vColor[4]); 纹理替换矩阵着色器 1234//着色器通过给定的模型视图投影矩阵，使用绑定到 nTextureUnit (纹 单元) 指定纹理单元的纹理对几何图形进行变化。 段颜 :是直接从纹理样本中直接获取的。//需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和 GLT_ATTRIBUTE_NORMAL(表面法线)GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_REPLACE,GLfloat mvMatrix[16],GLintnTextureUnit); 纹理调整着色器 123//将一个基本色乘以一个取自纹理单元 nTextureUnit 的纹 。需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和 GLT_ATTRIBUTE_TEXTURE0(纹理坐标)GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_MODULATE,GLfloatmvMatrix[16],GLfloat vColor[4],GLint nTextureUnit); 纹理光源着色器 123456789//参数1:纹理光源着色器 //参数2:投影矩阵//参数3:视觉空间中的光源位置//参数4: 何图形的基本色//参数5:将要使用的纹理单元//将一个纹理通过漫反射照明计算机进行调整(相乘)。光线在视觉空间中的位置是给定的。//需要设置存储着色器的 GLT_ATTRIBUTE_VERTEX(顶点分量) 和 GLT_ATTRIBUTE_TEXTURE0(纹理坐标)、GLT_ATTRIBUTE_NORMAL(表面法线)GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIEF,GLfloatmvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vBaseColor[4],GLint nTextureUnit); 六、OpenGL图元 点 线 线带 线环 三角形 三角形金字塔 三角形带 三角形扇 1234567891011//修改点的大小glPointSize(4.0f);//设置点的大小范围，点和点之间的距离GLfloat sizes[2] = &#123;2.0f,4.0f&#125;;GLfloat stepSize = 1.0f;//获取点的大小范围和步长glGetFloatv(GL_POINT_SIZE_RANGE,sizes);glGetFloatv(GL_POINT_GRAULRITY,&amp;stepSize);//3.通过使用程序点大小模式设置点大小glEnable(GL_PROGAM_POINT_SIZE);//GLSL程序gl_PointSize = 5.0f; 七、GLBatch容器(帮助类)]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习 在Mac上搭建OpenGL环境(一)]]></title>
    <url>%2F2018%2F02%2F05%2F15244567239248%2F</url>
    <content type="text"><![CDATA[一、准备资源 CLTools glew libGLTools.a 百度云盘资源地址：链接: https://pan.baidu.com/s/1ebesf8 密码: g99g 二、现在开始配置 openGL 环境 1、打开Xcode -&gt; macOS -&gt; Cocoa Application 2、选中Build Phases, 选择 Link Binary With Libraries ,点击 + 搜索添加 OpenGl.framework 和 GLUT.framework 两个系统库. 3、把下载好的 include 和 libGLTools.a 拖入到项目里面，选中 Copy item if needed 和 Create groups 4、然后点击 Build Settings, 选则All ，找到 Header Search Paths, 把你拖到项目里的 include 文件夹路径 拖到里面。把libGLTools.a 文件拖到Framework 里面 5、接着把 AppDelegate.h, AppDelegate.m,ViewController.h,ViewControllers.m 文件删除掉OpenGL006.jpeg 6、添加新的文件，选择 C++ File ,Name 设置为main，并且不要勾选下面的 also create a header file,点击Next ,生成main.cpp文件 7、然后把main.m 文件删除掉。 8、把下面的代码复制到 main.cpp 里面，然后把项目跑起来 Run BOpenGL010.jpeg 三、注意事项与报错处理 如果报下面的错误ld: library not found for -lGLToolsclang: error: linker command failed with exit code 1 (use -v to see invocation) 选择General 下面 的林科大Frameworks and Libraries选中 libGLTools.a 点击下面的 一 删除掉，然后点击 + , 选择 Add Other,然后找到你项目里面的 libGLTools.a，选中并点击 open，重新 Run Build 就好了。 注意 ：新建的main.cpp 文件里面 必须要有 main 函数，不然直接build 会报错]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 CADisplayLink 定时器的了解与使用]]></title>
    <url>%2F2017%2F09%2F19%2FiOS%E5%BC%80%E5%8F%91CADisplayLink-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、简介1、所在框架CADisplayLink和其它CoreAnimation类一样，都是在QuartzCore.framework里。 1.1什么是CADisplayLink? CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 CADisplayLink 对象，把它添加到一个runloop中，并给它提供一个 target 和selector 在屏幕刷新的时候调用。 一但 CADisplayLink 以特定的模式注册到runloop之后，每当屏幕需要刷新的时候，runloop就会调用CADisplayLink绑定的target上的selector，这时target可以读到 CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。 在添加进runloop的时候我们应该选用高一些的优先级，来保证动画的平滑。可以设想一下，我们在动画的过程中，runloop被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行CADisplayLink的调用，从而造成动画过程的卡顿，使动画不流畅。 duration属性提供了每帧之间的时间，也就是屏幕每次刷新之间的的时间。我们可以使用这个时间来计算出下一帧要显示的UI的数值。但是 duration只是个大概的时间，如果CPU忙于其它计算，就没法保证以相同的频率执行屏幕的绘制操作，这样会跳过几次调用回调方法的机会。frameInterval属性是可读可写的NSInteger型值，标识间隔多少帧调用一次selector 方法，默认值是1，即每帧都调用一次。如果每帧都调用一次的话，对于iOS设备来说那刷新频率就是60HZ也就是每秒60次，如果将 frameInterval 设为2 那么就会两帧调用一次，也就是变成了每秒刷新30次。 我们通过pause属性开控制CADisplayLink的运行。当我们想结束一个CADisplayLink的时候，应该调用-(void)invalidate从runloop中删除并删除之前绑定的 target跟selector另外CADisplayLink 不能被继承。 2、功能CADisplayLink最主要的特征是能提供一个周期性的调用我们赋给它的selector的机制，从这点上看它很像定时器NSTimer。 3、使用方式12345678910111213141516- (void)startDisplayLink &#123; self.displayLink = [`CADisplayLink` displayLinkWithTarget:self selector:@selector(handleDisplayLink:)]; [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; &#125; - (void)handleDisplayLink:(`CADisplayLink` *)displayLink &#123; //do something &#125; - (void)stopDisplayLink &#123; [self.displayLink invalidate]; self.displayLink = nil; &#125; 当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于NSTimer被启动了；执行invalidate操作时，CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。 CADisplayLink 与 NSTimer 有什么不同 iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。 二、特性下面结合NSTimer来介绍CADisplayLink，与NSTimer不同的地方有： 1、原理不同CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。NSTimer以指定的模式注册到runloop后，每当设定的周期时间到达后，runloop会向指定的target发送一次指定的selector消息。 2、周期设置方式不同iOS设备的屏幕刷新频率(FPS)是60Hz，因此CADisplayLink的selector默认调用周期是每秒60次，这个周期可以通过frameInterval属性设置，CADisplayLink的selector每秒调用次数=60/frameInterval。比如当frameInterval设为2，每秒调用就变成30次。因此，CADisplayLink周期的设置方式略显不便。NSTimer的selector调用周期可以在初始化时直接设定，相对就灵活的多。 3、精确度不同iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在忙于别的调用，触发时间就会推迟到下一个runloop周期。更有甚者，在OS X v10.9以后为了尽量避免在NSTimer触发时间到了而去中断当前处理的任务，NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间范围。 4、使用场合从原理上不难看出，CADisplayLink使用场合相对专一，适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。 三、重要属性下面不完整的列出了CADisplayLink的几个重要属性： 1、frameInterval可读可写的NSInteger型值，标识间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。官方文档中强调，当该值被设定小于1时，结果是不可预知的。 2、duration只读的CFTimeInterval值，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：时间=duration×frameInterval。现存的iOS设备屏幕的FPS都是60Hz，这一点可以从CADisplayLink的duration属性看出来。duration的值都是0.166666…，即1/60。尽管如此，我们并没法确定苹果不会改变FPS，如果以后某一天将FPS提升到了120Hz了怎么办呢？这时，你设置了frameInterval属性值为2期望每秒刷新30次，却发现每秒刷新了60次，结果可想而知，出于安全考虑，还是先根据duration判断屏幕的FPS再去使用CADisplayLink。 3、timestamp只读的CFTimeInterval值，表示屏幕显示的上一帧的时间戳，这个属性通常被target用来计算下一帧中应该显示的内容。 虽然名为时间戳，但这和常见的unix时间戳差异很大，事实上这是CoreAnimation使用的时间格式。每个CALayer都有一个本地时间（CALayer本地时间的具体作用会在后续文章中说明），可以获取当前CALayer的本地时间并打印： 12CFTimeInterval localLayerTime = [myLayer convertTime:CACurrentMediaTime() fromLayer:nil]; NSLog(@&quot;localLayerTime:%f&quot;,localLayerTime); 四、注意iOS并不能保证能以每秒60次的频率调用回调方法，这取决于： 1、CPU的空闲程度如果CPU忙于其它计算，就没法保证以60HZ执行屏幕的绘制动作，导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。 2、执行回调方法所用的时间如果执行回调时间大于重绘每帧的间隔时间，就会导致跳过若干次回调调用机会，这取决于执行时间长短。 3.通常来讲iOS设备的刷新频率事60HZ也就是每秒60次。那么每一次刷新的时间就是1/60秒 大概16.7毫秒。当我们的frameInterval值为1的时候我们需要保证的是 CADisplayLink调用的｀target｀的函数计算时间不应该大于 16.7否则就会出现严重的丢帧现象。 五、参考文档1、官方文档2、官方使用CADisplayLink播放视频的例子]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FMDB 数据库简单基本操作]]></title>
    <url>%2F2017%2F06%2F27%2FFMDB-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728291.创建表: create table if not exists 表名 (字段名1, 字段名2…); 例如：创建 t_student 表 id（id自增长）create table if not exists t_student (id integer primary key autoincrement, name text not null, age integer)2.增加数据: insert into 表名 (字段名1, 字段名2, …) values(字段1的值, 字段2的值, …); 例如：在 t_student 表插入name，age字段insert into t_student (name,age) values (@”Jack”,@17);3.1根据条件删除数据： delete from 表名 where 条件; 例如：删除 t_student 表中 name 字段为 Jack 的数据delete from t_student where name = @”Jack”;3.2删除表中所有的数据： delete from 表名； 例如：delete from t_student;4.根据条件更改某个数据 update 表名 set 字段1 = ‘值1’, 字段2 = ‘值2’ where 字段1 = ‘字段1的当前值’ 例如：update t_student set name = ‘lily’, age = ‘16’ where name = ‘Jack’5.1根据条件查找 select from 表名 where 字段1 = ‘字段1的值’ 例如：select from t_student where age = ‘16’5.2查找所有数据 select from 表名 例如：select from t_student5.3排序查找： select from 表名 order by 字段 例如：select from t_student order by age asc （升序，默认）select * from t_student order by age desc （降序） 3.6.删除表： drop table 表名 例如：drop table t_student]]></content>
      <categories>
        <category>FMDB</category>
      </categories>
      <tags>
        <tag>FMDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发权限设置]]></title>
    <url>%2F2017%2F05%2F05%2FiOS%E5%BC%80%E5%8F%91%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[iOS 8.0之后调用系统的API需要配置相关的配置信息才能正常使用 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 相册 --&gt;&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问相册&lt;/string&gt;&lt;!-- 相机 --&gt;&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问相机&lt;/string&gt;&lt;!-- 麦克风 --&gt;&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问麦克风&lt;/string&gt;&lt;!-- 位置 --&gt;&lt;key&gt;NSLocationUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问位置&lt;/string&gt;&lt;!-- 在使用期间访问位置 --&gt;&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能在使用期间访问位置&lt;/string&gt;&lt;!-- 始终访问位置 --&gt;&lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能始终访问位置&lt;/string&gt;&lt;!-- 日历 --&gt;&lt;key&gt;NSCalendarsUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问日历&lt;/string&gt;&lt;!-- 提醒事项 --&gt;&lt;key&gt;NSRemindersUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问提醒事项&lt;/string&gt;&lt;!-- 运动与健身 --&gt;&lt;key&gt;NSMotionUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问运动与健身&lt;/string&gt;&lt;!-- 健康更新 --&gt;&lt;key&gt;NSHealthUpdateUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问健康更新 &lt;/string&gt;&lt;!-- 健康分享 --&gt;&lt;key&gt;NSHealthShareUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问健康分享&lt;/string&gt;&lt;!-- 蓝牙 --&gt;&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问蓝牙&lt;/string&gt;&lt;!-- 媒体资料库 --&gt;&lt;key&gt;NSAppleMusicUsageDescription&lt;/key&gt;&lt;string&gt;App需要您的同意,才能访问媒体资料库&lt;/string&gt;]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 UITableViewCell的重用机制]]></title>
    <url>%2F2017%2F04%2F16%2FiOS%E5%BC%80%E5%8F%91UITableViewCell%E7%9A%84%E9%87%8D%E7%94%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[首先,我们要明白我们为什么需要使用这种机制,其次,这种机制的原理是什么.我们先举个例子来说明.一个UITableView中有许多需要显示的cell,但是我们不可能每个都会浏览到,那么如果我们把这些数据全部都加载进去,是不是造成了内存的负担呢. 我们所能显示的区域通常只有一个屏幕的大小,那么那些屏幕之外的信息是不需要一次性全都加载完的,只有当我们滑动屏幕需要浏览的时候,我们才需要它加载进来.因此,就有了我们要介绍的这部分内容,UITabelViewCell的重用机制. 重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell,我们只创建屏幕可显示的最大的cell个数+1,然后去循环重复使用这些cell,既节省空间,又达到我们需要显示的效果.这种机制下系统默认有一个可变数组NSMutableArray visiableCells,用来保存当前显示的cell.一个可变字典NSMutableDictnery reusableTableCells,用来保存可重复利用的cell.(之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell). 1234567891011121314// 设置单元格 indexPath :单元格当前所在位置 -- 哪个分区哪一行等- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath //UITableViewDataSource&#123; static NSString *identifier = @&quot;cell&quot; ; //相当于从集合中找寻完全出屏幕的单元格. // identifier : 因为一个表视图中可能存在多种样式的单元格,咱们把相同样式的单元格放到同一个集合里面,为这个集合加标示符,当我们需要用到某种样式的单元格的时候,根据不同的标示符,从不同的集合中找寻单元格. UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier] ; // 如果从集合中未找到单元格,也就是集合中还没有单元格,也就是还没有单元格出屏幕,那么我们就需要创建单元格 if (!cell) &#123; // 创建cell的时候需要标示符(Identifier)是因为,当该cell出屏幕的时候需要根据标示符放到对应的集合中. cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@&quot;cell&quot;] ; return cell ;&#125; 1234567系统第一次执行- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath这个方法的时候, reusableTableCells为空,[tableView dequeueReusableCellWithIdentifier:identifier]的返回值为nil,我们需要通过[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier]方式来创建. 当我们的数据过多,整个屏幕的cell显示不完全时,这个方法的执行情况是 : (1) 先执行[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier]创建整个屏幕能显示的cell数+1的cell(当我们拖动UITableView的时候,第一个cell没有移出屏幕,最下面的cell就已经存在),并指定相同或者不同的标示符identifier.把创建出的屏幕能显示的cell全部都加入到visiableCells数组中(最后一个创建的先不加入数组)，reusableTableCells为空. (2)当我们拖动屏幕时,顶端的cell移出屏幕并加入到reusableTableCells字典中,键为identifier ,并把之前已经创建的但是没有加入到visiableCells的cell加入到visiableCells数组中. (3)当我们接着拖动的时候,因为reusableTableCells中已经有值，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用，执行[tableView dequeueReusableCellWithIdentifier: identifier]，返回一个标示符为identifier的cell。该cell移出reusableTableCells之后加入到visiableCells；顶端的cell移出visiableCells并加入到reusableTableCells.如果visiableCells数组中没有找到identifier类型的cell,则再次重新alloc一个. 在iOS6之后系统加入了一种单元格注册的方法.[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier: identifier]; 这个方法的作用是,当我们从重用队列中取cell的时候,如果没有,系统会帮我们创建我们给定类型的cell,如果有,则直接重用. 这种方式cell的样式为系统默认样式. 在设置cell的方法中只需要: 123456- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 重用队列中取单元格 由于上面已经注册过单元格,系统会帮我们做判断,不用再次手动判断单元格是否存在 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier: identifier forIndexPath:indexPath] ; return cell ;&#125;]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 APP的生命周期和UIViewController的生命周期]]></title>
    <url>%2F2017%2F03%2F12%2FiOS%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[一. iOS程序的启动执行顺序1.具体执行流程123456789101112131415161718192021222324252627282930程序入口进入main函数，设置AppDelegate称为函数的代理程序完成加载[AppDelegate application:didFinishLaunchingWithOptions:]创建window窗口程序被激活[AppDelegate applicationDidBecomeActive:]当点击command+H时(针对模拟器,手机是当点击home键)程序取消激活状态[AppDelegate applicationWillResignActive:];程序进入后台[AppDelegate applicationDidEnterBackground:];点击进入工程程序进入前台[AppDelegate applicationWillEnterForeground:]程序被激活[AppDelegate applicationDidBecomeActive:]; 2.分析 对于applicationWillResignActive(非活动)与applicationDidEnterBackground(后台)这两个的区别。applicationWillResignActive(非活动):比如当有电话进来或短信进来或锁屏等情况下，这时应用程序挂起进入非活动状态，也就是手机界面还是显示着你当前的应用程序的窗口，只不过被别的任务强制占用了，也可能是即将进入后台状态(因为要先进入非活动状态然后进入后台状态) applicationDidEnterBackground(后台):指当前窗口不是你的App,大多数程序进入这个后台会在这个状态上停留一会，时间到之后会进入挂起状态(Suspended)。如果你程序特殊处理后可以长期处于后台状态也可以运行。Suspended (挂起): 程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。 ###二. UIViewController 的 生命周期 当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序 1、 alloc 创建对象，分配空间 2、init (initWithNibName) 初始化对象，初始化数据 3、loadView 从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图 4、viewDidLoad 载入完成，可以进行自定义数据以及动态创建其他控件 5、viewWillAppear 视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了 6、viewDidAppear 视图已在屏幕上渲染完成当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反 1、viewWillDisappear 视图将被从屏幕上移除之前执行 2、viewDidDisappear 视图已经被从屏幕上移除，用户看不到这个视图了 3、dealloc 视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放 关于viewDidUnload ：在发生内存警告的时候如果本视图不是当前屏幕上正在显示的视图的话， viewDidUnload将会被执行，本视图的所有子视图将被销毁，以释放内存,此时开发者需要手动对viewLoad、viewDidLoad中创建的对象释放内存。 因为当这个视图再次显示在屏幕上的时候，viewLoad、viewDidLoad 再次被调用，以便再次构造视图。 当我们创建一个UIViewController类的对象时，通常系统会生成几个默认的方法，这些方法大多与视图的调用有关，但是在视图调用时，这些方法的调用顺序如何，需要整理下。通常上述方法包括如下几种，这些方法都是UIViewController类的方法： 1234567891011- (void)viewDidLoad；- (void)viewDidUnload； - (void)viewWillAppear:(BOOL)animated； - (void)viewDidAppear:(BOOL)animated； - (void)viewWillDisappear:(BOOL)animated； - (void)viewDidDisappear:(BOOL)animated； 下面介绍下APP在运行时的调用顺序。 1）- (void)viewDidLoad； 一个APP在载入时会先通过调用loadView方法或者载入IB中创建的初始界面的方法，将视图载入到内存中。然后会调用viewDidLoad方法来进行进一步的设置。通常，我们对于各种初始数据的载入，初始设定等很多内容，都会在这个方法中实现，所以这个方法是一个很常用，很重要的方法。 但是要注意，这个方法只会在APP刚开始加载的时候调用一次，以后都不会再调用它了，所以只能用来做初始设置。 2) - (void)viewDidUnload; 在内存足够的情况下，软件的视图通常会一直保存在内存中，但是如果内存不够，一些没有正在显示的viewcontroller就会收到内存不够的警告，然后就会释放自己拥有的视图，以达到释放内存的目的。但是系统只会释放内存，并不会释放对象的所有权，所以通常我们需要在这里将不需要在内存中保留的对象释放所有权，也就是将其指针置为nil。 这个方法通常并不会在视图变换的时候被调用，而只会在系统退出或者收到内存警告的时候才会被调用。但是由于我们需要保证在收到内存警告的时候能够对其作出反应，所以这个方法通常我们都需要去实现。 另外，即使在设备上按了Home键之后，系统也不一定会调用这个方法，因为IOS4之后，系统允许将APP在后台挂起，并将其继续滞留在内存中，因此，viewcontroller并不会调用这个方法来清除内存。 3）- (void)viewWillAppear:(BOOL)animated; 系统在载入所有数据后，将会在屏幕上显示视图，这时会先调用这个方法。通常我们会利用这个方法，对即将显示的视图做进一步的设置。例如，我们可以利用这个方法来设置设备不同方向时该如何显示。 另外一方面，当APP有多个视图时，在视图间切换时，并不会再次载入viewDidLoad方法，所以如果在调入视图时，需要对数据做更新，就只能在这个方法内实现了。所以这个方法也非常常用。 4) - (void)viewDidAppear:(BOOL)animated； 有时候，由于一些特殊的原因，我们不能在viewWillApper方法里，对视图进行更新。那么可以重写这个方法，在这里对正在显示的视图进行进一步的设置。 5) - (void)viewWillDisappear:(BOOL)animated； 在视图变换时，当前视图在即将被移除、或者被覆盖时，会调用这个方法进行一些善后的处理和设置。 由于在IOS4之后，系统允许将APP在后台挂起，所以在按了Home键之后，系统并不会调用这个方法，因为就这个APP本身而言，APP显示的view，仍是挂起时候的view，所以并不会调用这个方法。 6) - (void)viewDidDisappear:(BOOL)animated； 我们可以重写这个方法，对已经消失，或者被覆盖，或者已经隐藏了的视图做一些其他操作。 上述方法的流程图可以简单用如下表示： 12345运行APP —&gt; 载入视图 —&gt; 调用viewDidLoad方法 —&gt; 调用viewWillAppear方法 —&gt; 调用viewDidAppear方法 —&gt; 正常运行 —&gt;…………..—&gt;释放对象所有权 &lt;— 调用viewDidUnload &lt;— 收到内存警告 &lt;— 调用viewDidDisappear &lt;— 调用viewWillDisappear &lt;— APP需要调用另一个view]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
</search>
